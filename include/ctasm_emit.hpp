#pragma once
#include "ctasm.hpp"
namespace ctasm{
template<typename ...T>
using expseq_v = expand_byte_seq_v<T...>;
//  aaa X86 [NONE]   [] 37 
template<class T, class Enable = bool> struct asm_aaa {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','a','a', str...>, hold<T...>> {
    using value = typename asm_aaa<hold<T...>>::value;
};
template <>
struct asm_aaa<hold<>, bool> { using value = expseq_v<byte_seq<0x37>>; };
//  aad X86 [I]   [] D5 
template<class T, class Enable = bool> struct asm_aad {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','a','d', str...>, hold<T...>> {
    using value = typename asm_aad<hold<T...>>::value;
};
template <class Y> 
struct asm_aad<hold<ax, Y>, typename u8_8<Y>::type>{
  using value = expseq_v<byte_seq<0xD5>, typename u8_8<Y>::value>;
};
//  aam X86 [I]   [] D4 
template<class T, class Enable = bool> struct asm_aam {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','a','m', str...>, hold<T...>> {
    using value = typename asm_aam<hold<T...>>::value;
};
template <class Y> 
struct asm_aam<hold<ax, Y>, typename u8_8<Y>::type>{
  using value = expseq_v<byte_seq<0xD4>, typename u8_8<Y>::value>;
};
//  aas X86 [NONE]   [] 3F 
template<class T, class Enable = bool> struct asm_aas {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','a','s', str...>, hold<T...>> {
    using value = typename asm_aas<hold<T...>>::value;
};
template <>
struct asm_aas<hold<>, bool> { using value = expseq_v<byte_seq<0x3F>>; };
//  adc ANY [I]   [] 14 
template<class T, class Enable = bool> struct asm_adc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','c', str...>, hold<T...>> {
    using value = typename asm_adc<hold<T...>>::value;
};
template <class Y> 
struct asm_adc<hold<al, Y>, typename u8_8<Y>::type>{
  using value = expseq_v<byte_seq<0x14>, typename u8_8<Y>::value>;
};
//  adc ANY [I]   [66] 15 

template <class Y> 
struct asm_adc<hold<ax, Y>, typename u16_8<Y>::type>{
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x15>, typename u16_8<Y>::value>;
};
//  adc ANY [I]   [] 15 

template <class Y> 
struct asm_adc<hold<eax, Y>, typename u32_8<Y>::type>{
  using value = expseq_v<byte_seq<0x15>, typename u32_8<Y>::value>;
};
//  adc X64 [I]   [] 15 

template <class Y> 
struct asm_adc<hold<rax, Y>, typename i32_8<Y>::type>{
  using value = expseq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x15>, typename i32_8<Y>::value>;
};
//  adc ANY [MI] 2  [] 80 

template<typename ...T, class Y>
struct asm_adc<hold<ptr<reg8, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x80>, mrm_v<hold<reg<2>>, T...>, typename u8_8<Y>::value>;
};

//  adc ANY [MI] 2  [66] 81 

template<typename ...T, class Y>
struct asm_adc<hold<ptr<reg16, T...>, Y>, typename u16_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<2>>, T...>, typename u16_8<Y>::value>;
};

//  adc ANY [MI] 2  [] 81 

template<typename ...T, class Y>
struct asm_adc<hold<ptr<reg32, T...>, Y>, typename u32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<2>>, T...>, typename u32_8<Y>::value>;
};

//  adc X64 [MI] 2  [] 81 

template<typename ...T, class Y>
struct asm_adc<hold<ptr<reg64, T...>, Y>, typename i32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<2>>, T...>, typename i32_8<Y>::value>;
};

//  adc ANY [MI] 2  [66] 83 

template<typename ...T, class Y>
struct asm_adc<hold<ptr<reg16, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<2>>, T...>, typename i8_8<Y>::value>;
};

//  adc ANY [MI] 2  [] 83 

template<typename ...T, class Y>
struct asm_adc<hold<ptr<reg32, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<2>>, T...>, typename i8_8<Y>::value>;
};

//  adc X64 [MI] 2  [] 83 

template<typename ...T, class Y>
struct asm_adc<hold<ptr<reg64, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<2>>, T...>, typename i8_8<Y>::value>;
};

//  adc ANY [MR] r  [] 10 

template<typename ...T, typename ...Y>
struct asm_adc<hold<ptr<reg8, T...>, zip<reg8>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x10>, mrm_v<hold<Y...>, T...>>;
};

//  adc ANY [MR] r  [66] 11 

template<typename ...T, typename ...Y>
struct asm_adc<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x11>, mrm_v<hold<Y...>, T...>>;
};

//  adc ANY [MR] r  [] 11 

template<typename ...T, typename ...Y>
struct asm_adc<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x11>, mrm_v<hold<Y...>, T...>>;
};

//  adc X64 [MR] r  [] 11 

template<typename ...T, typename ...Y>
struct asm_adc<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x11>, mrm_v<hold<Y...>, T...>>;
};

//  adc ANY [RM] r  [] 12 

template<typename ...T, typename ...Y>
struct asm_adc<hold<zip<reg8>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_adc<hold<zip<reg8>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x12>, mrm_v<hold<T...>, Y...>>;
};

//  adc ANY [RM] r  [66] 13 

template<typename ...T, typename ...Y>
struct asm_adc<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x13>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_adc<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x13>, mrm_v<hold<T...>, Y...>>;
};

//  adc ANY [RM] r  [] 13 

template<typename ...T, typename ...Y>
struct asm_adc<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x13>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_adc<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x13>, mrm_v<hold<T...>, Y...>>;
};

//  adc X64 [RM] r  [] 13 

template<typename ...T, typename ...Y>
struct asm_adc<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x13>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_adc<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x13>, mrm_v<hold<T...>, Y...>>;
};

//  adcx ANY [RM] r  [66] F6 
template<class T, class Enable = bool> struct asm_adcx {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','c','x', str...>, hold<T...>> {
    using value = typename asm_adcx<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_adcx<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_adcx<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, mrm_v<hold<T...>, Y...>>;
};

//  adcx X64 [RM] r  [66] F6 

template<typename ...T, typename ...Y>
struct asm_adcx<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_adcx<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, mrm_v<hold<T...>, Y...>>;
};

//  add ANY [I]   [] 04 
template<class T, class Enable = bool> struct asm_add {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','d', str...>, hold<T...>> {
    using value = typename asm_add<hold<T...>>::value;
};
template <class Y> 
struct asm_add<hold<al, Y>, typename u8_8<Y>::type>{
  using value = expseq_v<byte_seq<0x04>, typename u8_8<Y>::value>;
};
//  add ANY [I]   [66] 05 

template <class Y> 
struct asm_add<hold<ax, Y>, typename u16_8<Y>::type>{
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x05>, typename u16_8<Y>::value>;
};
//  add ANY [I]   [] 05 

template <class Y> 
struct asm_add<hold<eax, Y>, typename u32_8<Y>::type>{
  using value = expseq_v<byte_seq<0x05>, typename u32_8<Y>::value>;
};
//  add X64 [I]   [] 05 

template <class Y> 
struct asm_add<hold<rax, Y>, typename i32_8<Y>::type>{
  using value = expseq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x05>, typename i32_8<Y>::value>;
};
//  add ANY [MI] 0  [] 80 

template<typename ...T, class Y>
struct asm_add<hold<ptr<reg8, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x80>, mrm_v<hold<reg<0>>, T...>, typename u8_8<Y>::value>;
};

//  add ANY [MI] 0  [66] 81 

template<typename ...T, class Y>
struct asm_add<hold<ptr<reg16, T...>, Y>, typename u16_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<0>>, T...>, typename u16_8<Y>::value>;
};

//  add ANY [MI] 0  [] 81 

template<typename ...T, class Y>
struct asm_add<hold<ptr<reg32, T...>, Y>, typename u32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<0>>, T...>, typename u32_8<Y>::value>;
};

//  add X64 [MI] 0  [] 81 

template<typename ...T, class Y>
struct asm_add<hold<ptr<reg64, T...>, Y>, typename i32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<0>>, T...>, typename i32_8<Y>::value>;
};

//  add ANY [MI] 0  [66] 83 

template<typename ...T, class Y>
struct asm_add<hold<ptr<reg16, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<0>>, T...>, typename i8_8<Y>::value>;
};

//  add ANY [MI] 0  [] 83 

template<typename ...T, class Y>
struct asm_add<hold<ptr<reg32, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<0>>, T...>, typename i8_8<Y>::value>;
};

//  add X64 [MI] 0  [] 83 

template<typename ...T, class Y>
struct asm_add<hold<ptr<reg64, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<0>>, T...>, typename i8_8<Y>::value>;
};

//  add ANY [MR] r  [] 00 

template<typename ...T, typename ...Y>
struct asm_add<hold<ptr<reg8, T...>, zip<reg8>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x00>, mrm_v<hold<Y...>, T...>>;
};

//  add ANY [MR] r  [66] 01 

template<typename ...T, typename ...Y>
struct asm_add<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, mrm_v<hold<Y...>, T...>>;
};

//  add ANY [MR] r  [] 01 

template<typename ...T, typename ...Y>
struct asm_add<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, mrm_v<hold<Y...>, T...>>;
};

//  add X64 [MR] r  [] 01 

template<typename ...T, typename ...Y>
struct asm_add<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, mrm_v<hold<Y...>, T...>>;
};

//  add ANY [RM] r  [] 02 

template<typename ...T, typename ...Y>
struct asm_add<hold<zip<reg8>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x02>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_add<hold<zip<reg8>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x02>, mrm_v<hold<T...>, Y...>>;
};

//  add ANY [RM] r  [66] 03 

template<typename ...T, typename ...Y>
struct asm_add<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x03>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_add<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x03>, mrm_v<hold<T...>, Y...>>;
};

//  add ANY [RM] r  [] 03 

template<typename ...T, typename ...Y>
struct asm_add<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x03>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_add<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x03>, mrm_v<hold<T...>, Y...>>;
};

//  add X64 [RM] r  [] 03 

template<typename ...T, typename ...Y>
struct asm_add<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x03>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_add<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x03>, mrm_v<hold<T...>, Y...>>;
};

//  addpd ANY [RM] r  [66] 58 
template<class T, class Enable = bool> struct asm_addpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','d','p','d', str...>, hold<T...>> {
    using value = typename asm_addpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_addpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x58>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_addpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x58>, mrm_v<hold<T...>, Y...>>;
};

//  addps ANY [RM] r  [] 58 
template<class T, class Enable = bool> struct asm_addps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','d','p','s', str...>, hold<T...>> {
    using value = typename asm_addps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_addps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x58>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_addps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x58>, mrm_v<hold<T...>, Y...>>;
};

//  addsd ANY [RM] r  [F2] 58 
template<class T, class Enable = bool> struct asm_addsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','d','s','d', str...>, hold<T...>> {
    using value = typename asm_addsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_addsd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x58>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_addsd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x58>, mrm_v<hold<T...>, Y...>>;
};

//  addss ANY [RM] r  [F3] 58 
template<class T, class Enable = bool> struct asm_addss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','d','s','s', str...>, hold<T...>> {
    using value = typename asm_addss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_addss<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x58>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_addss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x58>, mrm_v<hold<T...>, Y...>>;
};

//  addsubpd ANY [RM] r  [66] D0 
template<class T, class Enable = bool> struct asm_addsubpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','d','s','u','b','p','d', str...>, hold<T...>> {
    using value = typename asm_addsubpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_addsubpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_addsubpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD0>, mrm_v<hold<T...>, Y...>>;
};

//  addsubps ANY [RM] r  [F2] D0 
template<class T, class Enable = bool> struct asm_addsubps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','d','s','u','b','p','s', str...>, hold<T...>> {
    using value = typename asm_addsubps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_addsubps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_addsubps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD0>, mrm_v<hold<T...>, Y...>>;
};

//  adox ANY [RM] r  [F3] F6 
template<class T, class Enable = bool> struct asm_adox {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','o','x', str...>, hold<T...>> {
    using value = typename asm_adox<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_adox<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_adox<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, mrm_v<hold<T...>, Y...>>;
};

//  adox X64 [RM] r  [F3] F6 

template<typename ...T, typename ...Y>
struct asm_adox<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_adox<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, mrm_v<hold<T...>, Y...>>;
};

//  aesdec ANY [RM] r  [66] DE 
template<class T, class Enable = bool> struct asm_aesdec {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','e','s','d','e','c', str...>, hold<T...>> {
    using value = typename asm_aesdec<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_aesdec<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_aesdec<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDE>, mrm_v<hold<T...>, Y...>>;
};

//  aesdeclast ANY [RM] r  [66] DF 
template<class T, class Enable = bool> struct asm_aesdeclast {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','e','s','d','e','c','l','a','s','t', str...>, hold<T...>> {
    using value = typename asm_aesdeclast<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_aesdeclast<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_aesdeclast<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDF>, mrm_v<hold<T...>, Y...>>;
};

//  aesenc ANY [RM] r  [66] DC 
template<class T, class Enable = bool> struct asm_aesenc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','e','s','e','n','c', str...>, hold<T...>> {
    using value = typename asm_aesenc<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_aesenc<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_aesenc<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDC>, mrm_v<hold<T...>, Y...>>;
};

//  aesenclast ANY [RM] r  [66] DD 
template<class T, class Enable = bool> struct asm_aesenclast {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','e','s','e','n','c','l','a','s','t', str...>, hold<T...>> {
    using value = typename asm_aesenclast<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_aesenclast<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDD>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_aesenclast<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDD>, mrm_v<hold<T...>, Y...>>;
};

//  aesimc ANY [RM] r  [66] DB 
template<class T, class Enable = bool> struct asm_aesimc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','e','s','i','m','c', str...>, hold<T...>> {
    using value = typename asm_aesimc<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_aesimc<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDB>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_aesimc<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDB>, mrm_v<hold<T...>, Y...>>;
};

//  aeskeygenassist ANY [RMI] r  [66] DF 
template<class T, class Enable = bool> struct asm_aeskeygenassist {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','e','s','k','e','y','g','e','n','a','s','s','i','s','t', str...>, hold<T...>> {
    using value = typename asm_aeskeygenassist<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_aeskeygenassist<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_aeskeygenassist<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDF>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  and ANY [I]   [] 24 
template<class T, class Enable = bool> struct asm_and {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','n','d', str...>, hold<T...>> {
    using value = typename asm_and<hold<T...>>::value;
};
template <class Y> 
struct asm_and<hold<al, Y>, typename u8_8<Y>::type>{
  using value = expseq_v<byte_seq<0x24>, typename u8_8<Y>::value>;
};
//  and ANY [I]   [66] 25 

template <class Y> 
struct asm_and<hold<ax, Y>, typename u16_8<Y>::type>{
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x25>, typename u16_8<Y>::value>;
};
//  and ANY [I]   [] 25 

template <class Y> 
struct asm_and<hold<eax, Y>, typename u32_8<Y>::type>{
  using value = expseq_v<byte_seq<0x25>, typename u32_8<Y>::value>;
};
//  and X64 [I]   [] 25 

template <class Y> 
struct asm_and<hold<rax, Y>, typename u32_8<Y>::type>{
  using value = expseq_v<byte_seq<0x25>, typename u32_8<Y>::value>;
};
//  and X64 [I]   [] 25 

template <class Y> 
struct asm_and<hold<rax, Y>, typename i32_8<Y>::type>{
  using value = expseq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x25>, typename i32_8<Y>::value>;
};
//  and ANY [MI] 4  [] 80 

template<typename ...T, class Y>
struct asm_and<hold<ptr<reg8, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x80>, mrm_v<hold<reg<4>>, T...>, typename u8_8<Y>::value>;
};

//  and ANY [MI] 4  [66] 81 

template<typename ...T, class Y>
struct asm_and<hold<ptr<reg16, T...>, Y>, typename u16_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<4>>, T...>, typename u16_8<Y>::value>;
};

//  and ANY [MI] 4  [] 81 

template<typename ...T, class Y>
struct asm_and<hold<ptr<reg32, T...>, Y>, typename u32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<4>>, T...>, typename u32_8<Y>::value>;
};

//  and X64 [MI] 4  [] 81 

//  and X64 [MI] 4  [] 81 

template<typename ...T, class Y>
struct asm_and<hold<ptr<reg64, T...>, Y>, typename i32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<4>>, T...>, typename i32_8<Y>::value>;
};

//  and ANY [MI] 4  [66] 83 

template<typename ...T, class Y>
struct asm_and<hold<ptr<reg16, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<4>>, T...>, typename u8_8<Y>::value>;
};

//  and ANY [MI] 4  [] 83 

template<typename ...T, class Y>
struct asm_and<hold<ptr<reg32, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<4>>, T...>, typename u8_8<Y>::value>;
};

//  and X64 [MI] 4  [] 83 

template<typename ...T, class Y>
struct asm_and<hold<ptr<reg64, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<4>>, T...>, typename u8_8<Y>::value>;
};

//  and ANY [MR] r  [] 20 

template<typename ...T, typename ...Y>
struct asm_and<hold<ptr<reg8, T...>, zip<reg8>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x20>, mrm_v<hold<Y...>, T...>>;
};

//  and ANY [MR] r  [66] 21 

template<typename ...T, typename ...Y>
struct asm_and<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x21>, mrm_v<hold<Y...>, T...>>;
};

//  and ANY [MR] r  [] 21 

template<typename ...T, typename ...Y>
struct asm_and<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x21>, mrm_v<hold<Y...>, T...>>;
};

//  and X64 [MR] r  [] 21 

template<typename ...T, typename ...Y>
struct asm_and<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x21>, mrm_v<hold<Y...>, T...>>;
};

//  and ANY [RM] r  [] 22 

template<typename ...T, typename ...Y>
struct asm_and<hold<zip<reg8>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x22>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_and<hold<zip<reg8>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x22>, mrm_v<hold<T...>, Y...>>;
};

//  and ANY [RM] r  [66] 23 

template<typename ...T, typename ...Y>
struct asm_and<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x23>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_and<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x23>, mrm_v<hold<T...>, Y...>>;
};

//  and ANY [RM] r  [] 23 

template<typename ...T, typename ...Y>
struct asm_and<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x23>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_and<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x23>, mrm_v<hold<T...>, Y...>>;
};

//  and X64 [RM] r  [] 23 

template<typename ...T, typename ...Y>
struct asm_and<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x23>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_and<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x23>, mrm_v<hold<T...>, Y...>>;
};

//  andn ANY [RVM] r  [] F2 
template<class T, class Enable = bool> struct asm_andn {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','n','d','n', str...>, hold<T...>> {
    using value = typename asm_andn<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_andn<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xF2>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_andn<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xF2>, mrm_v<hold<T...>, Z...>>;
};

//  andn X64 [RVM] r  [] F2 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_andn<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xF2>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_andn<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xF2>, mrm_v<hold<T...>, Z...>>;
};

//  andnpd ANY [RM] r  [66] 55 
template<class T, class Enable = bool> struct asm_andnpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','n','d','n','p','d', str...>, hold<T...>> {
    using value = typename asm_andnpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_andnpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x55>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_andnpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x55>, mrm_v<hold<T...>, Y...>>;
};

//  andnps ANY [RM] r  [] 55 
template<class T, class Enable = bool> struct asm_andnps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','n','d','n','p','s', str...>, hold<T...>> {
    using value = typename asm_andnps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_andnps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x55>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_andnps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x55>, mrm_v<hold<T...>, Y...>>;
};

//  andpd ANY [RM] r  [66] 54 
template<class T, class Enable = bool> struct asm_andpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','n','d','p','d', str...>, hold<T...>> {
    using value = typename asm_andpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_andpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x54>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_andpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x54>, mrm_v<hold<T...>, Y...>>;
};

//  andps ANY [RM] r  [] 54 
template<class T, class Enable = bool> struct asm_andps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','n','d','p','s', str...>, hold<T...>> {
    using value = typename asm_andps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_andps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x54>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_andps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x54>, mrm_v<hold<T...>, Y...>>;
};

//  arpl X86 [MR] r  [] 63 
template<class T, class Enable = bool> struct asm_arpl {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','r','p','l', str...>, hold<T...>> {
    using value = typename asm_arpl<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_arpl<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x63>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_arpl<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x63>, mrm_v<hold<Y...>, T...>>;
};

//  bextr ANY [RMV] r  [] F7 
template<class T, class Enable = bool> struct asm_bextr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','e','x','t','r', str...>, hold<T...>> {
    using value = typename asm_bextr<hold<T...>>::value;
};
//  bextr X64 [RMV] r  [] F7 

//  blcfill ANY [VM] 1  [] 01 
template<class T, class Enable = bool> struct asm_blcfill {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','c','f','i','l','l', str...>, hold<T...>> {
    using value = typename asm_blcfill<hold<T...>>::value;
};
//  blcfill X64 [VM] 1  [] 01 

//  blci ANY [VM] 6  [] 02 
template<class T, class Enable = bool> struct asm_blci {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','c','i', str...>, hold<T...>> {
    using value = typename asm_blci<hold<T...>>::value;
};
//  blci X64 [VM] 6  [] 02 

//  blcic ANY [VM] 5  [] 01 
template<class T, class Enable = bool> struct asm_blcic {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','c','i','c', str...>, hold<T...>> {
    using value = typename asm_blcic<hold<T...>>::value;
};
//  blcic X64 [VM] 5  [] 01 

//  blcmsk ANY [VM] 1  [] 02 
template<class T, class Enable = bool> struct asm_blcmsk {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','c','m','s','k', str...>, hold<T...>> {
    using value = typename asm_blcmsk<hold<T...>>::value;
};
//  blcmsk X64 [VM] 1  [] 02 

//  blcs ANY [VM] 3  [] 01 
template<class T, class Enable = bool> struct asm_blcs {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','c','s', str...>, hold<T...>> {
    using value = typename asm_blcs<hold<T...>>::value;
};
//  blcs X64 [VM] 3  [] 01 

//  blendpd ANY [RMI] r  [66] 0D 
template<class T, class Enable = bool> struct asm_blendpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','e','n','d','p','d', str...>, hold<T...>> {
    using value = typename asm_blendpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_blendpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0D>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_blendpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0D>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  blendps ANY [RMI] r  [66] 0C 
template<class T, class Enable = bool> struct asm_blendps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','e','n','d','p','s', str...>, hold<T...>> {
    using value = typename asm_blendps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_blendps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0C>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_blendps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0C>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  blendvpd ANY [RM] r  [66] 15 
template<class T, class Enable = bool> struct asm_blendvpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','e','n','d','v','p','d', str...>, hold<T...>> {
    using value = typename asm_blendvpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_blendvpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x15>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_blendvpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x15>, mrm_v<hold<T...>, Y...>>;
};

//  blendvps ANY [RM] r  [66] 14 
template<class T, class Enable = bool> struct asm_blendvps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','e','n','d','v','p','s', str...>, hold<T...>> {
    using value = typename asm_blendvps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_blendvps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x14>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_blendvps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x14>, mrm_v<hold<T...>, Y...>>;
};

//  blsfill ANY [VM] 2  [] 01 
template<class T, class Enable = bool> struct asm_blsfill {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','s','f','i','l','l', str...>, hold<T...>> {
    using value = typename asm_blsfill<hold<T...>>::value;
};
//  blsfill X64 [VM] 2  [] 01 

//  blsi ANY [VM] 3  [] F3 
template<class T, class Enable = bool> struct asm_blsi {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','s','i', str...>, hold<T...>> {
    using value = typename asm_blsi<hold<T...>>::value;
};
//  blsi X64 [VM] 3  [] F3 

//  blsic ANY [VM] 6  [] 01 
template<class T, class Enable = bool> struct asm_blsic {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','s','i','c', str...>, hold<T...>> {
    using value = typename asm_blsic<hold<T...>>::value;
};
//  blsic X64 [VM] 6  [] 01 

//  blsmsk ANY [VM] 2  [] F3 
template<class T, class Enable = bool> struct asm_blsmsk {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','s','m','s','k', str...>, hold<T...>> {
    using value = typename asm_blsmsk<hold<T...>>::value;
};
//  blsmsk X64 [VM] 2  [] F3 

//  blsr ANY [VM] 1  [] F3 
template<class T, class Enable = bool> struct asm_blsr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','s','r', str...>, hold<T...>> {
    using value = typename asm_blsr<hold<T...>>::value;
};
//  blsr X64 [VM] 1  [] F3 

//  bound X86 [RM] r  [66] 62 
template<class T, class Enable = bool> struct asm_bound {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','o','u','n','d', str...>, hold<T...>> {
    using value = typename asm_bound<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_bound<hold<zip<reg16>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x62>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_bound<hold<zip<reg16>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x62>, mrm_v<hold<T...>, Y...>>;
};

//  bound X86 [RM] r  [] 62 

template<typename ...T, typename ...Y>
struct asm_bound<hold<zip<reg32>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x62>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_bound<hold<zip<reg32>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x62>, mrm_v<hold<T...>, Y...>>;
};

//  bsf ANY [RM] r  [66] BC 
template<class T, class Enable = bool> struct asm_bsf {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','s','f', str...>, hold<T...>> {
    using value = typename asm_bsf<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_bsf<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBC>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_bsf<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBC>, mrm_v<hold<T...>, Y...>>;
};

//  bsf ANY [RM] r  [] BC 

template<typename ...T, typename ...Y>
struct asm_bsf<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBC>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_bsf<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBC>, mrm_v<hold<T...>, Y...>>;
};

//  bsf X64 [RM] r  [] BC 

template<typename ...T, typename ...Y>
struct asm_bsf<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBC>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_bsf<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBC>, mrm_v<hold<T...>, Y...>>;
};

//  bsr ANY [RM] r  [66] BD 
template<class T, class Enable = bool> struct asm_bsr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','s','r', str...>, hold<T...>> {
    using value = typename asm_bsr<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_bsr<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBD>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_bsr<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBD>, mrm_v<hold<T...>, Y...>>;
};

//  bsr ANY [RM] r  [] BD 

template<typename ...T, typename ...Y>
struct asm_bsr<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBD>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_bsr<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBD>, mrm_v<hold<T...>, Y...>>;
};

//  bsr X64 [RM] r  [] BD 

template<typename ...T, typename ...Y>
struct asm_bsr<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBD>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_bsr<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBD>, mrm_v<hold<T...>, Y...>>;
};

//  bswap ANY [O]   [66] C8 
template<class T, class Enable = bool> struct asm_bswap {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','s','w','a','p', str...>, hold<T...>> {
    using value = typename asm_bswap<hold<T...>>::value;
};
//  bswap ANY [O]   [] C8 

//  bswap X64 [O]   [] C8 

//  bt ANY [MI] 4  [66] BA 
template<class T, class Enable = bool> struct asm_bt {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','t', str...>, hold<T...>> {
    using value = typename asm_bt<hold<T...>>::value;
};
template<typename ...T, class Y>
struct asm_bt<hold<ptr<reg16, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, mrm_v<hold<reg<4>>, T...>, typename u8_8<Y>::value>;
};

//  bt ANY [MI] 4  [] BA 

template<typename ...T, class Y>
struct asm_bt<hold<ptr<reg32, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, mrm_v<hold<reg<4>>, T...>, typename u8_8<Y>::value>;
};

//  bt X64 [MI] 4  [] BA 

template<typename ...T, class Y>
struct asm_bt<hold<ptr<reg64, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, mrm_v<hold<reg<4>>, T...>, typename u8_8<Y>::value>;
};

//  bt ANY [MR] r  [66] A3 

template<typename ...T, typename ...Y>
struct asm_bt<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xA3>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_bt<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xA3>, mrm_v<hold<Y...>, T...>>;
};

//  bt ANY [MR] r  [] A3 

template<typename ...T, typename ...Y>
struct asm_bt<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xA3>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_bt<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xA3>, mrm_v<hold<Y...>, T...>>;
};

//  bt X64 [MR] r  [] A3 

template<typename ...T, typename ...Y>
struct asm_bt<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xA3>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_bt<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xA3>, mrm_v<hold<Y...>, T...>>;
};

//  btc ANY [MI] 7  [66] BA 
template<class T, class Enable = bool> struct asm_btc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','t','c', str...>, hold<T...>> {
    using value = typename asm_btc<hold<T...>>::value;
};
template<typename ...T, class Y>
struct asm_btc<hold<ptr<reg16, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, mrm_v<hold<reg<7>>, T...>, typename u8_8<Y>::value>;
};

//  btc ANY [MI] 7  [] BA 

template<typename ...T, class Y>
struct asm_btc<hold<ptr<reg32, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, mrm_v<hold<reg<7>>, T...>, typename u8_8<Y>::value>;
};

//  btc X64 [MI] 7  [] BA 

template<typename ...T, class Y>
struct asm_btc<hold<ptr<reg64, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, mrm_v<hold<reg<7>>, T...>, typename u8_8<Y>::value>;
};

//  btc ANY [MR] r  [66] BB 

template<typename ...T, typename ...Y>
struct asm_btc<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xBB>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_btc<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBB>, mrm_v<hold<Y...>, T...>>;
};

//  btc ANY [MR] r  [] BB 

template<typename ...T, typename ...Y>
struct asm_btc<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xBB>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_btc<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBB>, mrm_v<hold<Y...>, T...>>;
};

//  btc X64 [MR] r  [] BB 

template<typename ...T, typename ...Y>
struct asm_btc<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xBB>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_btc<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBB>, mrm_v<hold<Y...>, T...>>;
};

//  btr ANY [MI] 6  [66] BA 
template<class T, class Enable = bool> struct asm_btr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','t','r', str...>, hold<T...>> {
    using value = typename asm_btr<hold<T...>>::value;
};
template<typename ...T, class Y>
struct asm_btr<hold<ptr<reg16, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, mrm_v<hold<reg<6>>, T...>, typename u8_8<Y>::value>;
};

//  btr ANY [MI] 6  [] BA 

template<typename ...T, class Y>
struct asm_btr<hold<ptr<reg32, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, mrm_v<hold<reg<6>>, T...>, typename u8_8<Y>::value>;
};

//  btr X64 [MI] 6  [] BA 

template<typename ...T, class Y>
struct asm_btr<hold<ptr<reg64, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, mrm_v<hold<reg<6>>, T...>, typename u8_8<Y>::value>;
};

//  btr ANY [MR] r  [66] B3 

template<typename ...T, typename ...Y>
struct asm_btr<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xB3>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_btr<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xB3>, mrm_v<hold<Y...>, T...>>;
};

//  btr ANY [MR] r  [] B3 

template<typename ...T, typename ...Y>
struct asm_btr<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xB3>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_btr<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xB3>, mrm_v<hold<Y...>, T...>>;
};

//  btr X64 [MR] r  [] B3 

template<typename ...T, typename ...Y>
struct asm_btr<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xB3>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_btr<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xB3>, mrm_v<hold<Y...>, T...>>;
};

//  bts ANY [MI] 5  [66] BA 
template<class T, class Enable = bool> struct asm_bts {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','t','s', str...>, hold<T...>> {
    using value = typename asm_bts<hold<T...>>::value;
};
template<typename ...T, class Y>
struct asm_bts<hold<ptr<reg16, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, mrm_v<hold<reg<5>>, T...>, typename u8_8<Y>::value>;
};

//  bts ANY [MI] 5  [] BA 

template<typename ...T, class Y>
struct asm_bts<hold<ptr<reg32, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, mrm_v<hold<reg<5>>, T...>, typename u8_8<Y>::value>;
};

//  bts X64 [MI] 5  [] BA 

template<typename ...T, class Y>
struct asm_bts<hold<ptr<reg64, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, mrm_v<hold<reg<5>>, T...>, typename u8_8<Y>::value>;
};

//  bts ANY [MR] r  [66] AB 

template<typename ...T, typename ...Y>
struct asm_bts<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAB>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_bts<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAB>, mrm_v<hold<Y...>, T...>>;
};

//  bts ANY [MR] r  [] AB 

template<typename ...T, typename ...Y>
struct asm_bts<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAB>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_bts<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAB>, mrm_v<hold<Y...>, T...>>;
};

//  bts X64 [MR] r  [] AB 

template<typename ...T, typename ...Y>
struct asm_bts<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAB>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_bts<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAB>, mrm_v<hold<Y...>, T...>>;
};

//  bzhi ANY [RMV] r  [] F5 
template<class T, class Enable = bool> struct asm_bzhi {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','z','h','i', str...>, hold<T...>> {
    using value = typename asm_bzhi<hold<T...>>::value;
};
//  bzhi X64 [RMV] r  [] F5 

//  call X86 [D]   [66] E8 
template<class T, class Enable = bool> struct asm_call {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','a','l','l', str...>, hold<T...>> {
    using value = typename asm_call<hold<T...>>::value;
};
template<uint16_t N>
struct asm_call<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0xE8>, typename rel16<N>::value>; };
//  call ANY [D]   [] E8 

template<uint32_t N>
struct asm_call<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0xE8>, typename rel32<N>::value>; };
//  call X86 [M] 2  [66] FF 

template<typename ...T>
struct asm_call<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_call<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<2>>, T...>>;
};

//  call X86 [M] 2  [] FF 

template<typename ...T>
struct asm_call<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_call<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<2>>, T...>>;
};

//  call X64 [M] 2  [] FF 

template<typename ...T>
struct asm_call<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_call<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<2>>, T...>>;
};

//  cbw ANY [NONE]   [66] 98 
template<class T, class Enable = bool> struct asm_cbw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','b','w', str...>, hold<T...>> {
    using value = typename asm_cbw<hold<T...>>::value;
};
template <>
struct asm_cbw<hold<>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x98>>; };
//  cdq ANY [NONE]   [] 99 
template<class T, class Enable = bool> struct asm_cdq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','d','q', str...>, hold<T...>> {
    using value = typename asm_cdq<hold<T...>>::value;
};
template <>
struct asm_cdq<hold<>, bool> { using value = expseq_v<byte_seq<0x99>>; };
//  cdqe X64 [NONE]   [] 98 
template<class T, class Enable = bool> struct asm_cdqe {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','d','q','e', str...>, hold<T...>> {
    using value = typename asm_cdqe<hold<T...>>::value;
};
template <>
struct asm_cdqe<hold<>, bool> { using value = expseq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x98>>; };
//  clac ANY [NONE]   [] CA 
template<class T, class Enable = bool> struct asm_clac {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','a','c', str...>, hold<T...>> {
    using value = typename asm_clac<hold<T...>>::value;
};
template <> struct asm_clac<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xCA>>; };
//  clc ANY [NONE]   [] F8 
template<class T, class Enable = bool> struct asm_clc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','c', str...>, hold<T...>> {
    using value = typename asm_clc<hold<T...>>::value;
};
template <> struct asm_clc<hold<>, bool> { using value = expseq_v<byte_seq<0xF8>>; };
//  cld ANY [NONE]   [] FC 
template<class T, class Enable = bool> struct asm_cld {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','d', str...>, hold<T...>> {
    using value = typename asm_cld<hold<T...>>::value;
};
template <> struct asm_cld<hold<>, bool> { using value = expseq_v<byte_seq<0xFC>>; };
//  cldemote ANY [M] 0  [] 1C 
template<class T, class Enable = bool> struct asm_cldemote {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','d','e','m','o','t','e', str...>, hold<T...>> {
    using value = typename asm_cldemote<hold<T...>>::value;
};
template<typename ...T>
struct asm_cldemote<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x1C>, mrm_v<hold<reg<0>>, T...>>;
};

//  clflush ANY [M] 7  [] AE 
template<class T, class Enable = bool> struct asm_clflush {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','f','l','u','s','h', str...>, hold<T...>> {
    using value = typename asm_clflush<hold<T...>>::value;
};
template<typename ...T>
struct asm_clflush<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, mrm_v<hold<reg<7>>, T...>>;
};

//  clflushopt ANY [M] 7  [66] AE 
template<class T, class Enable = bool> struct asm_clflushopt {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','f','l','u','s','h','o','p','t', str...>, hold<T...>> {
    using value = typename asm_clflushopt<hold<T...>>::value;
};
template<typename ...T>
struct asm_clflushopt<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, mrm_v<hold<reg<7>>, T...>>;
};

//  clgi ANY [NONE]   [] DD 
template<class T, class Enable = bool> struct asm_clgi {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','g','i', str...>, hold<T...>> {
    using value = typename asm_clgi<hold<T...>>::value;
};
template <> struct asm_clgi<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xDD>>; };
//  cli ANY [NONE]   [] FA 
template<class T, class Enable = bool> struct asm_cli {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','i', str...>, hold<T...>> {
    using value = typename asm_cli<hold<T...>>::value;
};
template <> struct asm_cli<hold<>, bool> { using value = expseq_v<byte_seq<0xFA>>; };
//  clrssbsy ANY [M] 6  [F3] AE 
template<class T, class Enable = bool> struct asm_clrssbsy {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','r','s','s','b','s','y', str...>, hold<T...>> {
    using value = typename asm_clrssbsy<hold<T...>>::value;
};
template<typename ...T>
struct asm_clrssbsy<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

template<typename ...T>
struct asm_clrssbsy<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, mrm_v<hold<reg<6>>, T...>>;
};

//  clts ANY [NONE]   [] 06 
template<class T, class Enable = bool> struct asm_clts {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','t','s', str...>, hold<T...>> {
    using value = typename asm_clts<hold<T...>>::value;
};
template <> struct asm_clts<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x06>>; };
//  clui X64 [NONE]   [F3] EE 
template<class T, class Enable = bool> struct asm_clui {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','u','i', str...>, hold<T...>> {
    using value = typename asm_clui<hold<T...>>::value;
};
template <> struct asm_clui<hold<>, bool> { using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x01>, byte_seq<0xEE>>; };
//  clwb ANY [M] 6  [66] AE 
template<class T, class Enable = bool> struct asm_clwb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','w','b', str...>, hold<T...>> {
    using value = typename asm_clwb<hold<T...>>::value;
};
template<typename ...T>
struct asm_clwb<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, mrm_v<hold<reg<6>>, T...>>;
};

//  clzero ANY [NONE]   [] FC 
template<class T, class Enable = bool> struct asm_clzero {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','z','e','r','o', str...>, hold<T...>> {
    using value = typename asm_clzero<hold<T...>>::value;
};
template <>
struct asm_clzero<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xFC>>; };
//  cmc ANY [NONE]   [] F5 
template<class T, class Enable = bool> struct asm_cmc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','c', str...>, hold<T...>> {
    using value = typename asm_cmc<hold<T...>>::value;
};
template <> struct asm_cmc<hold<>, bool> { using value = expseq_v<byte_seq<0xF5>>; };
//  cmova ANY [RM] r  [66] 47 
template<class T, class Enable = bool> struct asm_cmova {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','a', str...>, hold<T...>> {
    using value = typename asm_cmova<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmova<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x47>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmova<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x47>, mrm_v<hold<T...>, Y...>>;
};

//  cmova ANY [RM] r  [] 47 

template<typename ...T, typename ...Y>
struct asm_cmova<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x47>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmova<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x47>, mrm_v<hold<T...>, Y...>>;
};

//  cmova X64 [RM] r  [] 47 

template<typename ...T, typename ...Y>
struct asm_cmova<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x47>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmova<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x47>, mrm_v<hold<T...>, Y...>>;
};

//  cmovae ANY [RM] r  [66] 43 
template<class T, class Enable = bool> struct asm_cmovae {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','a','e', str...>, hold<T...>> {
    using value = typename asm_cmovae<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovae<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x43>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovae<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x43>, mrm_v<hold<T...>, Y...>>;
};

//  cmovae ANY [RM] r  [] 43 

template<typename ...T, typename ...Y>
struct asm_cmovae<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x43>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovae<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x43>, mrm_v<hold<T...>, Y...>>;
};

//  cmovae X64 [RM] r  [] 43 

template<typename ...T, typename ...Y>
struct asm_cmovae<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x43>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovae<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x43>, mrm_v<hold<T...>, Y...>>;
};

//  cmovb ANY [RM] r  [66] 42 
template<class T, class Enable = bool> struct asm_cmovb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','b', str...>, hold<T...>> {
    using value = typename asm_cmovb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovb<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovb<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, mrm_v<hold<T...>, Y...>>;
};

//  cmovb ANY [RM] r  [] 42 

template<typename ...T, typename ...Y>
struct asm_cmovb<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovb<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, mrm_v<hold<T...>, Y...>>;
};

//  cmovb X64 [RM] r  [] 42 

template<typename ...T, typename ...Y>
struct asm_cmovb<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovb<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, mrm_v<hold<T...>, Y...>>;
};

//  cmovbe ANY [RM] r  [66] 46 
template<class T, class Enable = bool> struct asm_cmovbe {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','b','e', str...>, hold<T...>> {
    using value = typename asm_cmovbe<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovbe<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x46>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovbe<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x46>, mrm_v<hold<T...>, Y...>>;
};

//  cmovbe ANY [RM] r  [] 46 

template<typename ...T, typename ...Y>
struct asm_cmovbe<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x46>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovbe<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x46>, mrm_v<hold<T...>, Y...>>;
};

//  cmovbe X64 [RM] r  [] 46 

template<typename ...T, typename ...Y>
struct asm_cmovbe<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x46>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovbe<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x46>, mrm_v<hold<T...>, Y...>>;
};

//  cmovc ANY [RM] r  [66] 42 
template<class T, class Enable = bool> struct asm_cmovc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','c', str...>, hold<T...>> {
    using value = typename asm_cmovc<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovc<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovc<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, mrm_v<hold<T...>, Y...>>;
};

//  cmovc ANY [RM] r  [] 42 

template<typename ...T, typename ...Y>
struct asm_cmovc<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovc<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, mrm_v<hold<T...>, Y...>>;
};

//  cmovc X64 [RM] r  [] 42 

template<typename ...T, typename ...Y>
struct asm_cmovc<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovc<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, mrm_v<hold<T...>, Y...>>;
};

//  cmove ANY [RM] r  [66] 44 
template<class T, class Enable = bool> struct asm_cmove {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','e', str...>, hold<T...>> {
    using value = typename asm_cmove<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmove<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x44>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmove<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x44>, mrm_v<hold<T...>, Y...>>;
};

//  cmove ANY [RM] r  [] 44 

template<typename ...T, typename ...Y>
struct asm_cmove<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x44>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmove<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x44>, mrm_v<hold<T...>, Y...>>;
};

//  cmove X64 [RM] r  [] 44 

template<typename ...T, typename ...Y>
struct asm_cmove<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x44>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmove<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x44>, mrm_v<hold<T...>, Y...>>;
};

//  cmovg ANY [RM] r  [66] 4F 
template<class T, class Enable = bool> struct asm_cmovg {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','g', str...>, hold<T...>> {
    using value = typename asm_cmovg<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovg<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovg<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4F>, mrm_v<hold<T...>, Y...>>;
};

//  cmovg ANY [RM] r  [] 4F 

template<typename ...T, typename ...Y>
struct asm_cmovg<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovg<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4F>, mrm_v<hold<T...>, Y...>>;
};

//  cmovg X64 [RM] r  [] 4F 

template<typename ...T, typename ...Y>
struct asm_cmovg<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovg<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4F>, mrm_v<hold<T...>, Y...>>;
};

//  cmovge ANY [RM] r  [66] 4D 
template<class T, class Enable = bool> struct asm_cmovge {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','g','e', str...>, hold<T...>> {
    using value = typename asm_cmovge<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovge<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovge<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4D>, mrm_v<hold<T...>, Y...>>;
};

//  cmovge ANY [RM] r  [] 4D 

template<typename ...T, typename ...Y>
struct asm_cmovge<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovge<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4D>, mrm_v<hold<T...>, Y...>>;
};

//  cmovge X64 [RM] r  [] 4D 

template<typename ...T, typename ...Y>
struct asm_cmovge<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovge<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4D>, mrm_v<hold<T...>, Y...>>;
};

//  cmovl ANY [RM] r  [66] 4C 
template<class T, class Enable = bool> struct asm_cmovl {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','l', str...>, hold<T...>> {
    using value = typename asm_cmovl<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovl<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovl<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4C>, mrm_v<hold<T...>, Y...>>;
};

//  cmovl ANY [RM] r  [] 4C 

template<typename ...T, typename ...Y>
struct asm_cmovl<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovl<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4C>, mrm_v<hold<T...>, Y...>>;
};

//  cmovl X64 [RM] r  [] 4C 

template<typename ...T, typename ...Y>
struct asm_cmovl<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovl<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4C>, mrm_v<hold<T...>, Y...>>;
};

//  cmovle ANY [RM] r  [66] 4E 
template<class T, class Enable = bool> struct asm_cmovle {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','l','e', str...>, hold<T...>> {
    using value = typename asm_cmovle<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovle<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovle<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4E>, mrm_v<hold<T...>, Y...>>;
};

//  cmovle ANY [RM] r  [] 4E 

template<typename ...T, typename ...Y>
struct asm_cmovle<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovle<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4E>, mrm_v<hold<T...>, Y...>>;
};

//  cmovle X64 [RM] r  [] 4E 

template<typename ...T, typename ...Y>
struct asm_cmovle<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovle<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4E>, mrm_v<hold<T...>, Y...>>;
};

//  cmovna ANY [RM] r  [66] 46 
template<class T, class Enable = bool> struct asm_cmovna {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','a', str...>, hold<T...>> {
    using value = typename asm_cmovna<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovna<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x46>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovna<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x46>, mrm_v<hold<T...>, Y...>>;
};

//  cmovna ANY [RM] r  [] 46 

template<typename ...T, typename ...Y>
struct asm_cmovna<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x46>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovna<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x46>, mrm_v<hold<T...>, Y...>>;
};

//  cmovna X64 [RM] r  [] 46 

template<typename ...T, typename ...Y>
struct asm_cmovna<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x46>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovna<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x46>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnae ANY [RM] r  [66] 42 
template<class T, class Enable = bool> struct asm_cmovnae {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','a','e', str...>, hold<T...>> {
    using value = typename asm_cmovnae<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovnae<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnae<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnae ANY [RM] r  [] 42 

template<typename ...T, typename ...Y>
struct asm_cmovnae<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnae<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnae X64 [RM] r  [] 42 

template<typename ...T, typename ...Y>
struct asm_cmovnae<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnae<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnb ANY [RM] r  [66] 43 
template<class T, class Enable = bool> struct asm_cmovnb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','b', str...>, hold<T...>> {
    using value = typename asm_cmovnb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovnb<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x43>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnb<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x43>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnb ANY [RM] r  [] 43 

template<typename ...T, typename ...Y>
struct asm_cmovnb<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x43>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnb<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x43>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnb X64 [RM] r  [] 43 

template<typename ...T, typename ...Y>
struct asm_cmovnb<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x43>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnb<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x43>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnbe ANY [RM] r  [66] 47 
template<class T, class Enable = bool> struct asm_cmovnbe {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','b','e', str...>, hold<T...>> {
    using value = typename asm_cmovnbe<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovnbe<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x47>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnbe<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x47>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnbe ANY [RM] r  [] 47 

template<typename ...T, typename ...Y>
struct asm_cmovnbe<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x47>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnbe<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x47>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnbe X64 [RM] r  [] 47 

template<typename ...T, typename ...Y>
struct asm_cmovnbe<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x47>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnbe<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x47>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnc ANY [RM] r  [66] 43 
template<class T, class Enable = bool> struct asm_cmovnc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','c', str...>, hold<T...>> {
    using value = typename asm_cmovnc<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovnc<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x43>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnc<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x43>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnc ANY [RM] r  [] 43 

template<typename ...T, typename ...Y>
struct asm_cmovnc<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x43>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnc<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x43>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnc X64 [RM] r  [] 43 

template<typename ...T, typename ...Y>
struct asm_cmovnc<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x43>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnc<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x43>, mrm_v<hold<T...>, Y...>>;
};

//  cmovne ANY [RM] r  [66] 45 
template<class T, class Enable = bool> struct asm_cmovne {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','e', str...>, hold<T...>> {
    using value = typename asm_cmovne<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovne<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x45>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovne<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x45>, mrm_v<hold<T...>, Y...>>;
};

//  cmovne ANY [RM] r  [] 45 

template<typename ...T, typename ...Y>
struct asm_cmovne<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x45>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovne<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x45>, mrm_v<hold<T...>, Y...>>;
};

//  cmovne X64 [RM] r  [] 45 

template<typename ...T, typename ...Y>
struct asm_cmovne<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x45>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovne<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x45>, mrm_v<hold<T...>, Y...>>;
};

//  cmovng ANY [RM] r  [66] 4E 
template<class T, class Enable = bool> struct asm_cmovng {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','g', str...>, hold<T...>> {
    using value = typename asm_cmovng<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovng<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovng<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4E>, mrm_v<hold<T...>, Y...>>;
};

//  cmovng ANY [RM] r  [] 4E 

template<typename ...T, typename ...Y>
struct asm_cmovng<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovng<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4E>, mrm_v<hold<T...>, Y...>>;
};

//  cmovng X64 [RM] r  [] 4E 

template<typename ...T, typename ...Y>
struct asm_cmovng<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovng<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4E>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnge ANY [RM] r  [66] 4C 
template<class T, class Enable = bool> struct asm_cmovnge {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','g','e', str...>, hold<T...>> {
    using value = typename asm_cmovnge<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovnge<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnge<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4C>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnge ANY [RM] r  [] 4C 

template<typename ...T, typename ...Y>
struct asm_cmovnge<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnge<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4C>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnge X64 [RM] r  [] 4C 

template<typename ...T, typename ...Y>
struct asm_cmovnge<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnge<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4C>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnl ANY [RM] r  [66] 4D 
template<class T, class Enable = bool> struct asm_cmovnl {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','l', str...>, hold<T...>> {
    using value = typename asm_cmovnl<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovnl<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnl<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4D>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnl ANY [RM] r  [] 4D 

template<typename ...T, typename ...Y>
struct asm_cmovnl<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnl<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4D>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnl X64 [RM] r  [] 4D 

template<typename ...T, typename ...Y>
struct asm_cmovnl<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnl<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4D>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnle ANY [RM] r  [66] 4F 
template<class T, class Enable = bool> struct asm_cmovnle {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','l','e', str...>, hold<T...>> {
    using value = typename asm_cmovnle<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovnle<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnle<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4F>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnle ANY [RM] r  [] 4F 

template<typename ...T, typename ...Y>
struct asm_cmovnle<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnle<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4F>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnle X64 [RM] r  [] 4F 

template<typename ...T, typename ...Y>
struct asm_cmovnle<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnle<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4F>, mrm_v<hold<T...>, Y...>>;
};

//  cmovno ANY [RM] r  [66] 41 
template<class T, class Enable = bool> struct asm_cmovno {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','o', str...>, hold<T...>> {
    using value = typename asm_cmovno<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovno<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x41>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovno<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x41>, mrm_v<hold<T...>, Y...>>;
};

//  cmovno ANY [RM] r  [] 41 

template<typename ...T, typename ...Y>
struct asm_cmovno<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x41>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovno<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x41>, mrm_v<hold<T...>, Y...>>;
};

//  cmovno X64 [RM] r  [] 41 

template<typename ...T, typename ...Y>
struct asm_cmovno<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x41>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovno<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x41>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnp ANY [RM] r  [66] 4B 
template<class T, class Enable = bool> struct asm_cmovnp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','p', str...>, hold<T...>> {
    using value = typename asm_cmovnp<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovnp<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnp<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4B>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnp ANY [RM] r  [] 4B 

template<typename ...T, typename ...Y>
struct asm_cmovnp<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnp<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4B>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnp X64 [RM] r  [] 4B 

template<typename ...T, typename ...Y>
struct asm_cmovnp<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnp<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4B>, mrm_v<hold<T...>, Y...>>;
};

//  cmovns ANY [RM] r  [66] 49 
template<class T, class Enable = bool> struct asm_cmovns {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','s', str...>, hold<T...>> {
    using value = typename asm_cmovns<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovns<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x49>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovns<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x49>, mrm_v<hold<T...>, Y...>>;
};

//  cmovns ANY [RM] r  [] 49 

template<typename ...T, typename ...Y>
struct asm_cmovns<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x49>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovns<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x49>, mrm_v<hold<T...>, Y...>>;
};

//  cmovns X64 [RM] r  [] 49 

template<typename ...T, typename ...Y>
struct asm_cmovns<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x49>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovns<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x49>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnz ANY [RM] r  [66] 45 
template<class T, class Enable = bool> struct asm_cmovnz {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','z', str...>, hold<T...>> {
    using value = typename asm_cmovnz<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovnz<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x45>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnz<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x45>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnz ANY [RM] r  [] 45 

template<typename ...T, typename ...Y>
struct asm_cmovnz<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x45>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnz<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x45>, mrm_v<hold<T...>, Y...>>;
};

//  cmovnz X64 [RM] r  [] 45 

template<typename ...T, typename ...Y>
struct asm_cmovnz<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x45>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovnz<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x45>, mrm_v<hold<T...>, Y...>>;
};

//  cmovo ANY [RM] r  [66] 40 
template<class T, class Enable = bool> struct asm_cmovo {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','o', str...>, hold<T...>> {
    using value = typename asm_cmovo<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovo<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x40>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovo<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x40>, mrm_v<hold<T...>, Y...>>;
};

//  cmovo ANY [RM] r  [] 40 

template<typename ...T, typename ...Y>
struct asm_cmovo<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x40>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovo<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x40>, mrm_v<hold<T...>, Y...>>;
};

//  cmovo X64 [RM] r  [] 40 

template<typename ...T, typename ...Y>
struct asm_cmovo<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x40>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovo<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x40>, mrm_v<hold<T...>, Y...>>;
};

//  cmovp ANY [RM] r  [66] 4A 
template<class T, class Enable = bool> struct asm_cmovp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','p', str...>, hold<T...>> {
    using value = typename asm_cmovp<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovp<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovp<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4A>, mrm_v<hold<T...>, Y...>>;
};

//  cmovp ANY [RM] r  [] 4A 

template<typename ...T, typename ...Y>
struct asm_cmovp<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovp<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4A>, mrm_v<hold<T...>, Y...>>;
};

//  cmovp X64 [RM] r  [] 4A 

template<typename ...T, typename ...Y>
struct asm_cmovp<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovp<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4A>, mrm_v<hold<T...>, Y...>>;
};

//  cmovpe ANY [RM] r  [66] 4A 
template<class T, class Enable = bool> struct asm_cmovpe {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','p','e', str...>, hold<T...>> {
    using value = typename asm_cmovpe<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovpe<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovpe<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4A>, mrm_v<hold<T...>, Y...>>;
};

//  cmovpe ANY [RM] r  [] 4A 

template<typename ...T, typename ...Y>
struct asm_cmovpe<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovpe<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4A>, mrm_v<hold<T...>, Y...>>;
};

//  cmovpe X64 [RM] r  [] 4A 

template<typename ...T, typename ...Y>
struct asm_cmovpe<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovpe<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4A>, mrm_v<hold<T...>, Y...>>;
};

//  cmovpo ANY [RM] r  [66] 4B 
template<class T, class Enable = bool> struct asm_cmovpo {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','p','o', str...>, hold<T...>> {
    using value = typename asm_cmovpo<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovpo<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovpo<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4B>, mrm_v<hold<T...>, Y...>>;
};

//  cmovpo ANY [RM] r  [] 4B 

template<typename ...T, typename ...Y>
struct asm_cmovpo<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovpo<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4B>, mrm_v<hold<T...>, Y...>>;
};

//  cmovpo X64 [RM] r  [] 4B 

template<typename ...T, typename ...Y>
struct asm_cmovpo<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovpo<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4B>, mrm_v<hold<T...>, Y...>>;
};

//  cmovs ANY [RM] r  [66] 48 
template<class T, class Enable = bool> struct asm_cmovs {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','s', str...>, hold<T...>> {
    using value = typename asm_cmovs<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovs<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x48>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovs<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x48>, mrm_v<hold<T...>, Y...>>;
};

//  cmovs ANY [RM] r  [] 48 

template<typename ...T, typename ...Y>
struct asm_cmovs<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x48>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovs<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x48>, mrm_v<hold<T...>, Y...>>;
};

//  cmovs X64 [RM] r  [] 48 

template<typename ...T, typename ...Y>
struct asm_cmovs<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x48>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovs<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x48>, mrm_v<hold<T...>, Y...>>;
};

//  cmovz ANY [RM] r  [66] 44 
template<class T, class Enable = bool> struct asm_cmovz {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','z', str...>, hold<T...>> {
    using value = typename asm_cmovz<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmovz<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x44>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovz<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x44>, mrm_v<hold<T...>, Y...>>;
};

//  cmovz ANY [RM] r  [] 44 

template<typename ...T, typename ...Y>
struct asm_cmovz<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x44>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovz<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x44>, mrm_v<hold<T...>, Y...>>;
};

//  cmovz X64 [RM] r  [] 44 

template<typename ...T, typename ...Y>
struct asm_cmovz<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x44>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmovz<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x44>, mrm_v<hold<T...>, Y...>>;
};

//  cmp ANY [I]   [] 3C 
template<class T, class Enable = bool> struct asm_cmp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p', str...>, hold<T...>> {
    using value = typename asm_cmp<hold<T...>>::value;
};
template <class Y> 
struct asm_cmp<hold<al, Y>, typename u8_8<Y>::type>{
  using value = expseq_v<byte_seq<0x3C>, typename u8_8<Y>::value>;
};
//  cmp ANY [I]   [66] 3D 

template <class Y> 
struct asm_cmp<hold<ax, Y>, typename u16_8<Y>::type>{
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x3D>, typename u16_8<Y>::value>;
};
//  cmp ANY [I]   [] 3D 

template <class Y> 
struct asm_cmp<hold<eax, Y>, typename u32_8<Y>::type>{
  using value = expseq_v<byte_seq<0x3D>, typename u32_8<Y>::value>;
};
//  cmp X64 [I]   [] 3D 

template <class Y> 
struct asm_cmp<hold<rax, Y>, typename i32_8<Y>::type>{
  using value = expseq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x3D>, typename i32_8<Y>::value>;
};
//  cmp ANY [MI] 7  [] 80 

template<typename ...T, class Y>
struct asm_cmp<hold<ptr<reg8, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x80>, mrm_v<hold<reg<7>>, T...>, typename u8_8<Y>::value>;
};

//  cmp ANY [MI] 7  [66] 81 

template<typename ...T, class Y>
struct asm_cmp<hold<ptr<reg16, T...>, Y>, typename u16_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<7>>, T...>, typename u16_8<Y>::value>;
};

//  cmp ANY [MI] 7  [] 81 

template<typename ...T, class Y>
struct asm_cmp<hold<ptr<reg32, T...>, Y>, typename u32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<7>>, T...>, typename u32_8<Y>::value>;
};

//  cmp X64 [MI] 7  [] 81 

template<typename ...T, class Y>
struct asm_cmp<hold<ptr<reg64, T...>, Y>, typename i32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<7>>, T...>, typename i32_8<Y>::value>;
};

//  cmp ANY [MI] 7  [66] 83 

template<typename ...T, class Y>
struct asm_cmp<hold<ptr<reg16, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<7>>, T...>, typename i8_8<Y>::value>;
};

//  cmp ANY [MI] 7  [] 83 

template<typename ...T, class Y>
struct asm_cmp<hold<ptr<reg32, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<7>>, T...>, typename i8_8<Y>::value>;
};

//  cmp X64 [MI] 7  [] 83 

template<typename ...T, class Y>
struct asm_cmp<hold<ptr<reg64, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<7>>, T...>, typename i8_8<Y>::value>;
};

//  cmp ANY [MR] r  [] 38 

template<typename ...T, typename ...Y>
struct asm_cmp<hold<ptr<reg8, T...>, zip<reg8>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x38>, mrm_v<hold<Y...>, T...>>;
};

//  cmp ANY [MR] r  [66] 39 

template<typename ...T, typename ...Y>
struct asm_cmp<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x39>, mrm_v<hold<Y...>, T...>>;
};

//  cmp ANY [MR] r  [] 39 

template<typename ...T, typename ...Y>
struct asm_cmp<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x39>, mrm_v<hold<Y...>, T...>>;
};

//  cmp X64 [MR] r  [] 39 

template<typename ...T, typename ...Y>
struct asm_cmp<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x39>, mrm_v<hold<Y...>, T...>>;
};

//  cmp ANY [RM] r  [] 3A 

template<typename ...T, typename ...Y>
struct asm_cmp<hold<zip<reg8>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmp<hold<zip<reg8>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3A>, mrm_v<hold<T...>, Y...>>;
};

//  cmp ANY [RM] r  [66] 3B 

template<typename ...T, typename ...Y>
struct asm_cmp<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmp<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3B>, mrm_v<hold<T...>, Y...>>;
};

//  cmp ANY [RM] r  [] 3B 

template<typename ...T, typename ...Y>
struct asm_cmp<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmp<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3B>, mrm_v<hold<T...>, Y...>>;
};

//  cmp X64 [RM] r  [] 3B 

template<typename ...T, typename ...Y>
struct asm_cmp<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmp<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3B>, mrm_v<hold<T...>, Y...>>;
};

//  cmppd ANY [RMI] r  [66] C2 
template<class T, class Enable = bool> struct asm_cmppd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','p','d', str...>, hold<T...>> {
    using value = typename asm_cmppd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_cmppd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC2>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_cmppd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC2>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  cmpps ANY [RMI] r  [] C2 
template<class T, class Enable = bool> struct asm_cmpps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','p','s', str...>, hold<T...>> {
    using value = typename asm_cmpps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_cmpps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC2>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_cmpps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC2>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  cmpsb ANY [NONE]   [] A6 
template<class T, class Enable = bool> struct asm_cmpsb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','s','b', str...>, hold<T...>> {
    using value = typename asm_cmpsb<hold<T...>>::value;
};
template <>
struct asm_cmpsb<hold<>, bool> { using value = expseq_v<byte_seq<0xA6>>; };
//  cmpsd ANY [NONE]   [] A7 
template<class T, class Enable = bool> struct asm_cmpsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','s','d', str...>, hold<T...>> {
    using value = typename asm_cmpsd<hold<T...>>::value;
};
template <>
struct asm_cmpsd<hold<>, bool> { using value = expseq_v<byte_seq<0xA7>>; };
//  cmpsd ANY [RMI] r  [F2] C2 

template<typename ...T, typename ...Y, class Z>
struct asm_cmpsd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC2>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_cmpsd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC2>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  cmpsq X64 [NONE]   [] A7 
template<class T, class Enable = bool> struct asm_cmpsq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','s','q', str...>, hold<T...>> {
    using value = typename asm_cmpsq<hold<T...>>::value;
};
template <>
struct asm_cmpsq<hold<>, bool> { using value = expseq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0xA7>>; };
//  cmpss ANY [RMI] r  [F3] C2 
template<class T, class Enable = bool> struct asm_cmpss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','s','s', str...>, hold<T...>> {
    using value = typename asm_cmpss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_cmpss<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC2>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_cmpss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC2>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  cmpsw ANY [NONE]   [66] A7 
template<class T, class Enable = bool> struct asm_cmpsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','s','w', str...>, hold<T...>> {
    using value = typename asm_cmpsw<hold<T...>>::value;
};
template <>
struct asm_cmpsw<hold<>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0xA7>>; };
//  cmpxchg ANY [MR] r  [] B0 
template<class T, class Enable = bool> struct asm_cmpxchg {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','x','c','h','g', str...>, hold<T...>> {
    using value = typename asm_cmpxchg<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cmpxchg<hold<zip<reg8>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xB0>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmpxchg<hold<ptr<reg8, T...>, zip<reg8>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xB0>, mrm_v<hold<Y...>, T...>>;
};

//  cmpxchg ANY [MR] r  [66] B1 

template<typename ...T, typename ...Y>
struct asm_cmpxchg<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xB1>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmpxchg<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xB1>, mrm_v<hold<Y...>, T...>>;
};

//  cmpxchg ANY [MR] r  [] B1 

template<typename ...T, typename ...Y>
struct asm_cmpxchg<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xB1>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmpxchg<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xB1>, mrm_v<hold<Y...>, T...>>;
};

//  cmpxchg X64 [MR] r  [] B1 

template<typename ...T, typename ...Y>
struct asm_cmpxchg<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xB1>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cmpxchg<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xB1>, mrm_v<hold<Y...>, T...>>;
};

//  cmpxchg16b X64 [M] 1  [] C7 
template<class T, class Enable = bool> struct asm_cmpxchg16b {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','x','c','h','g','1','6','b', str...>, hold<T...>> {
    using value = typename asm_cmpxchg16b<hold<T...>>::value;
};
template<typename ...T>
struct asm_cmpxchg16b<hold<zip<reg128>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_cmpxchg16b<hold<ptr<reg128, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, mrm_v<hold<reg<1>>, T...>>;
};

//  cmpxchg8b ANY [M] 1  [] C7 
template<class T, class Enable = bool> struct asm_cmpxchg8b {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','x','c','h','g','8','b', str...>, hold<T...>> {
    using value = typename asm_cmpxchg8b<hold<T...>>::value;
};
template<typename ...T>
struct asm_cmpxchg8b<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_cmpxchg8b<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, mrm_v<hold<reg<1>>, T...>>;
};

//  comisd ANY [RM] r  [66] 2F 
template<class T, class Enable = bool> struct asm_comisd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','o','m','i','s','d', str...>, hold<T...>> {
    using value = typename asm_comisd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_comisd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_comisd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2F>, mrm_v<hold<T...>, Y...>>;
};

//  comiss ANY [RM] r  [] 2F 
template<class T, class Enable = bool> struct asm_comiss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','o','m','i','s','s', str...>, hold<T...>> {
    using value = typename asm_comiss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_comiss<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_comiss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2F>, mrm_v<hold<T...>, Y...>>;
};

//  cpuid ANY [NONE]   [] A2 
template<class T, class Enable = bool> struct asm_cpuid {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','p','u','i','d', str...>, hold<T...>> {
    using value = typename asm_cpuid<hold<T...>>::value;
};
template <>
struct asm_cpuid<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0xA2>>; };
//  cqo X64 [NONE]   [] 99 
template<class T, class Enable = bool> struct asm_cqo {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','q','o', str...>, hold<T...>> {
    using value = typename asm_cqo<hold<T...>>::value;
};
template <>
struct asm_cqo<hold<>, bool> { using value = expseq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x99>>; };
//  crc32 ANY [RM] r  [F2] F0 
template<class T, class Enable = bool> struct asm_crc32 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','r','c','3','2', str...>, hold<T...>> {
    using value = typename asm_crc32<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_crc32<hold<zip<reg32>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_crc32<hold<zip<reg32>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF0>, mrm_v<hold<T...>, Y...>>;
};

//  crc32 ANY [RM] r  [66F2] F1 

template<typename ...T, typename ...Y>
struct asm_crc32<hold<zip<reg32>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66, 0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF1>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_crc32<hold<zip<reg32>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66, 0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF1>, mrm_v<hold<T...>, Y...>>;
};

//  crc32 ANY [RM] r  [F2] F1 

template<typename ...T, typename ...Y>
struct asm_crc32<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF1>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_crc32<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF1>, mrm_v<hold<T...>, Y...>>;
};

//  crc32 X64 [RM] r  [F2] F0 

template<typename ...T, typename ...Y>
struct asm_crc32<hold<zip<reg64>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_crc32<hold<zip<reg64>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF0>, mrm_v<hold<T...>, Y...>>;
};

//  crc32 X64 [RM] r  [F2] F1 

template<typename ...T, typename ...Y>
struct asm_crc32<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF1>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_crc32<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF1>, mrm_v<hold<T...>, Y...>>;
};

//  cvtdq2pd ANY [RM] r  [F3] E6 
template<class T, class Enable = bool> struct asm_cvtdq2pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','d','q','2','p','d', str...>, hold<T...>> {
    using value = typename asm_cvtdq2pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvtdq2pd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtdq2pd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE6>, mrm_v<hold<T...>, Y...>>;
};

//  cvtdq2ps ANY [RM] r  [] 5B 
template<class T, class Enable = bool> struct asm_cvtdq2ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','d','q','2','p','s', str...>, hold<T...>> {
    using value = typename asm_cvtdq2ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvtdq2ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtdq2ps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5B>, mrm_v<hold<T...>, Y...>>;
};

//  cvtpd2dq ANY [RM] r  [F2] E6 
template<class T, class Enable = bool> struct asm_cvtpd2dq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','p','d','2','d','q', str...>, hold<T...>> {
    using value = typename asm_cvtpd2dq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvtpd2dq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtpd2dq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE6>, mrm_v<hold<T...>, Y...>>;
};

//  cvtpd2pi ANY [RM] r  [66] 2D 
template<class T, class Enable = bool> struct asm_cvtpd2pi {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','p','d','2','p','i', str...>, hold<T...>> {
    using value = typename asm_cvtpd2pi<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvtpd2pi<hold<zip<mmx>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtpd2pi<hold<zip<mmx>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2D>, mrm_v<hold<T...>, Y...>>;
};

//  cvtpd2ps ANY [RM] r  [66] 5A 
template<class T, class Enable = bool> struct asm_cvtpd2ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','p','d','2','p','s', str...>, hold<T...>> {
    using value = typename asm_cvtpd2ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvtpd2ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtpd2ps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5A>, mrm_v<hold<T...>, Y...>>;
};

//  cvtpi2pd ANY [RM] r  [66] 2A 
template<class T, class Enable = bool> struct asm_cvtpi2pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','p','i','2','p','d', str...>, hold<T...>> {
    using value = typename asm_cvtpi2pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvtpi2pd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtpi2pd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2A>, mrm_v<hold<T...>, Y...>>;
};

//  cvtpi2ps ANY [RM] r  [] 2A 
template<class T, class Enable = bool> struct asm_cvtpi2ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','p','i','2','p','s', str...>, hold<T...>> {
    using value = typename asm_cvtpi2ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvtpi2ps<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtpi2ps<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2A>, mrm_v<hold<T...>, Y...>>;
};

//  cvtps2dq ANY [RM] r  [66] 5B 
template<class T, class Enable = bool> struct asm_cvtps2dq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','p','s','2','d','q', str...>, hold<T...>> {
    using value = typename asm_cvtps2dq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvtps2dq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtps2dq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5B>, mrm_v<hold<T...>, Y...>>;
};

//  cvtps2pd ANY [RM] r  [] 5A 
template<class T, class Enable = bool> struct asm_cvtps2pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','p','s','2','p','d', str...>, hold<T...>> {
    using value = typename asm_cvtps2pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvtps2pd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtps2pd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5A>, mrm_v<hold<T...>, Y...>>;
};

//  cvtps2pi ANY [RM] r  [] 2D 
template<class T, class Enable = bool> struct asm_cvtps2pi {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','p','s','2','p','i', str...>, hold<T...>> {
    using value = typename asm_cvtps2pi<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvtps2pi<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtps2pi<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2D>, mrm_v<hold<T...>, Y...>>;
};

//  cvtsd2si ANY [RM] r  [F2] 2D 
template<class T, class Enable = bool> struct asm_cvtsd2si {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','s','d','2','s','i', str...>, hold<T...>> {
    using value = typename asm_cvtsd2si<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvtsd2si<hold<zip<reg32>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtsd2si<hold<zip<reg32>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2D>, mrm_v<hold<T...>, Y...>>;
};

//  cvtsd2si X64 [RM] r  [F2] 2D 

template<typename ...T, typename ...Y>
struct asm_cvtsd2si<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtsd2si<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2D>, mrm_v<hold<T...>, Y...>>;
};

//  cvtsd2ss ANY [RM] r  [F2] 5A 
template<class T, class Enable = bool> struct asm_cvtsd2ss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','s','d','2','s','s', str...>, hold<T...>> {
    using value = typename asm_cvtsd2ss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvtsd2ss<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtsd2ss<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5A>, mrm_v<hold<T...>, Y...>>;
};

//  cvtsi2sd ANY [RM] r  [F2] 2A 
template<class T, class Enable = bool> struct asm_cvtsi2sd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','s','i','2','s','d', str...>, hold<T...>> {
    using value = typename asm_cvtsi2sd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvtsi2sd<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtsi2sd<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2A>, mrm_v<hold<T...>, Y...>>;
};

//  cvtsi2sd X64 [RM] r  [F2] 2A 

template<typename ...T, typename ...Y>
struct asm_cvtsi2sd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtsi2sd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2A>, mrm_v<hold<T...>, Y...>>;
};

//  cvtsi2ss ANY [RM] r  [F3] 2A 
template<class T, class Enable = bool> struct asm_cvtsi2ss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','s','i','2','s','s', str...>, hold<T...>> {
    using value = typename asm_cvtsi2ss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvtsi2ss<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtsi2ss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2A>, mrm_v<hold<T...>, Y...>>;
};

//  cvtsi2ss X64 [RM] r  [F3] 2A 

template<typename ...T, typename ...Y>
struct asm_cvtsi2ss<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtsi2ss<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2A>, mrm_v<hold<T...>, Y...>>;
};

//  cvtss2sd ANY [RM] r  [F3] 5A 
template<class T, class Enable = bool> struct asm_cvtss2sd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','s','s','2','s','d', str...>, hold<T...>> {
    using value = typename asm_cvtss2sd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvtss2sd<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtss2sd<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5A>, mrm_v<hold<T...>, Y...>>;
};

//  cvtss2si ANY [RM] r  [F3] 2D 
template<class T, class Enable = bool> struct asm_cvtss2si {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','s','s','2','s','i', str...>, hold<T...>> {
    using value = typename asm_cvtss2si<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvtss2si<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtss2si<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2D>, mrm_v<hold<T...>, Y...>>;
};

//  cvtss2si X64 [RM] r  [F3] 2D 

template<typename ...T, typename ...Y>
struct asm_cvtss2si<hold<zip<reg64>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvtss2si<hold<zip<reg64>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2D>, mrm_v<hold<T...>, Y...>>;
};

//  cvttpd2dq ANY [RM] r  [66] E6 
template<class T, class Enable = bool> struct asm_cvttpd2dq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','t','p','d','2','d','q', str...>, hold<T...>> {
    using value = typename asm_cvttpd2dq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvttpd2dq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvttpd2dq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE6>, mrm_v<hold<T...>, Y...>>;
};

//  cvttpd2pi ANY [RM] r  [66] 2C 
template<class T, class Enable = bool> struct asm_cvttpd2pi {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','t','p','d','2','p','i', str...>, hold<T...>> {
    using value = typename asm_cvttpd2pi<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvttpd2pi<hold<zip<mmx>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvttpd2pi<hold<zip<mmx>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2C>, mrm_v<hold<T...>, Y...>>;
};

//  cvttps2dq ANY [RM] r  [F3] 5B 
template<class T, class Enable = bool> struct asm_cvttps2dq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','t','p','s','2','d','q', str...>, hold<T...>> {
    using value = typename asm_cvttps2dq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvttps2dq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvttps2dq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5B>, mrm_v<hold<T...>, Y...>>;
};

//  cvttps2pi ANY [RM] r  [] 2C 
template<class T, class Enable = bool> struct asm_cvttps2pi {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','t','p','s','2','p','i', str...>, hold<T...>> {
    using value = typename asm_cvttps2pi<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvttps2pi<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvttps2pi<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2C>, mrm_v<hold<T...>, Y...>>;
};

//  cvttsd2si ANY [RM] r  [F2] 2C 
template<class T, class Enable = bool> struct asm_cvttsd2si {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','t','s','d','2','s','i', str...>, hold<T...>> {
    using value = typename asm_cvttsd2si<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvttsd2si<hold<zip<reg32>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvttsd2si<hold<zip<reg32>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2C>, mrm_v<hold<T...>, Y...>>;
};

//  cvttsd2si X64 [RM] r  [F2] 2C 

template<typename ...T, typename ...Y>
struct asm_cvttsd2si<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvttsd2si<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2C>, mrm_v<hold<T...>, Y...>>;
};

//  cvttss2si ANY [RM] r  [F3] 2C 
template<class T, class Enable = bool> struct asm_cvttss2si {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','t','s','s','2','s','i', str...>, hold<T...>> {
    using value = typename asm_cvttss2si<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_cvttss2si<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvttss2si<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2C>, mrm_v<hold<T...>, Y...>>;
};

//  cvttss2si X64 [RM] r  [F3] 2C 

template<typename ...T, typename ...Y>
struct asm_cvttss2si<hold<zip<reg64>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_cvttss2si<hold<zip<reg64>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2C>, mrm_v<hold<T...>, Y...>>;
};

//  cwd ANY [NONE]   [66] 99 
template<class T, class Enable = bool> struct asm_cwd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','w','d', str...>, hold<T...>> {
    using value = typename asm_cwd<hold<T...>>::value;
};
template <>
struct asm_cwd<hold<>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x99>>; };
//  cwde ANY [NONE]   [] 98 
template<class T, class Enable = bool> struct asm_cwde {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','w','d','e', str...>, hold<T...>> {
    using value = typename asm_cwde<hold<T...>>::value;
};
template <>
struct asm_cwde<hold<>, bool> { using value = expseq_v<byte_seq<0x98>>; };
//  daa X86 [NONE]   [] 27 
template<class T, class Enable = bool> struct asm_daa {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','a','a', str...>, hold<T...>> {
    using value = typename asm_daa<hold<T...>>::value;
};
template <>
struct asm_daa<hold<>, bool> { using value = expseq_v<byte_seq<0x27>>; };
//  das X86 [NONE]   [] 2F 
template<class T, class Enable = bool> struct asm_das {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','a','s', str...>, hold<T...>> {
    using value = typename asm_das<hold<T...>>::value;
};
template <>
struct asm_das<hold<>, bool> { using value = expseq_v<byte_seq<0x2F>>; };
//  dec X86 [O]   [66] 48 
template<class T, class Enable = bool> struct asm_dec {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','e','c', str...>, hold<T...>> {
    using value = typename asm_dec<hold<T...>>::value;
};
//  dec X86 [O]   [] 48 

//  dec ANY [M] 1  [] FE 

template<typename ...T>
struct asm_dec<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFE>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_dec<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFE>, mrm_v<hold<reg<1>>, T...>>;
};

//  dec ANY [M] 1  [66] FF 

template<typename ...T>
struct asm_dec<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_dec<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<1>>, T...>>;
};

//  dec ANY [M] 1  [] FF 

template<typename ...T>
struct asm_dec<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_dec<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<1>>, T...>>;
};

//  dec X64 [M] 1  [] FF 

template<typename ...T>
struct asm_dec<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_dec<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<1>>, T...>>;
};

//  div ANY [M] 6  [] F6 
template<class T, class Enable = bool> struct asm_div {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','i','v', str...>, hold<T...>> {
    using value = typename asm_div<hold<T...>>::value;
};
template<typename ...Y>
struct asm_div<hold<zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<reg<6>>>::value>;
};

template<typename ...Y>
struct asm_div<hold<ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, mrm_v<hold<reg<6>>, Y...>>;
};

//  div ANY [M] 6  [66] F7 

template<typename ...Z>
struct asm_div<hold<zip<reg16>::with<Z...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<6>>>::value>;
};

template<typename ...Z>
struct asm_div<hold<ptr<reg16, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<6>>, Z...>>;
};

//  div ANY [M] 6  [] F7 

template<typename ...Z>
struct asm_div<hold<zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<6>>>::value>;
};

template<typename ...Z>
struct asm_div<hold<ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<6>>, Z...>>;
};

//  div X64 [M] 6  [] F7 

template<typename ...Z>
struct asm_div<hold<zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<6>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<6>>>::value>;
};

template<typename ...Z>
struct asm_div<hold<ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename REX<1, is_ext_v<hold<reg<6>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<6>>, Z...>>;
};

//  divpd ANY [RM] r  [66] 5E 
template<class T, class Enable = bool> struct asm_divpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','i','v','p','d', str...>, hold<T...>> {
    using value = typename asm_divpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_divpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_divpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5E>, mrm_v<hold<T...>, Y...>>;
};

//  divps ANY [RM] r  [] 5E 
template<class T, class Enable = bool> struct asm_divps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','i','v','p','s', str...>, hold<T...>> {
    using value = typename asm_divps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_divps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_divps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5E>, mrm_v<hold<T...>, Y...>>;
};

//  divsd ANY [RM] r  [F2] 5E 
template<class T, class Enable = bool> struct asm_divsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','i','v','s','d', str...>, hold<T...>> {
    using value = typename asm_divsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_divsd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_divsd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5E>, mrm_v<hold<T...>, Y...>>;
};

//  divss ANY [RM] r  [F3] 5E 
template<class T, class Enable = bool> struct asm_divss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','i','v','s','s', str...>, hold<T...>> {
    using value = typename asm_divss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_divss<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_divss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5E>, mrm_v<hold<T...>, Y...>>;
};

//  dppd ANY [RMI] r  [66] 41 
template<class T, class Enable = bool> struct asm_dppd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','p','p','d', str...>, hold<T...>> {
    using value = typename asm_dppd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_dppd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x41>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_dppd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x41>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  dpps ANY [RMI] r  [66] 40 
template<class T, class Enable = bool> struct asm_dpps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','p','p','s', str...>, hold<T...>> {
    using value = typename asm_dpps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_dpps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x40>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_dpps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x40>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  emms ANY [NONE]   [] 77 
template<class T, class Enable = bool> struct asm_emms {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'e','m','m','s', str...>, hold<T...>> {
    using value = typename asm_emms<hold<T...>>::value;
};
template <> struct asm_emms<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x77>>; };
//  endbr32 ANY [NONE] 7 3 [F3] FB 
template<class T, class Enable = bool> struct asm_endbr32 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'e','n','d','b','r','3','2', str...>, hold<T...>> {
    using value = typename asm_endbr32<hold<T...>>::value;
};
template <> struct asm_endbr32<hold<>, bool> { using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, byte_seq<0xFB>>; };
//  endbr64 ANY [NONE] 7 2 [F3] FA 
template<class T, class Enable = bool> struct asm_endbr64 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'e','n','d','b','r','6','4', str...>, hold<T...>> {
    using value = typename asm_endbr64<hold<T...>>::value;
};
template <> struct asm_endbr64<hold<>, bool> { using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, byte_seq<0xFA>>; };
//  enqcmd X86 [RM] r  [F2] F8 
template<class T, class Enable = bool> struct asm_enqcmd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'e','n','q','c','m','d', str...>, hold<T...>> {
    using value = typename asm_enqcmd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_enqcmd<hold<zip<reg32>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF8>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_enqcmd<hold<zip<reg32>::with<T...>, ptr<reg512, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF8>, mrm_v<hold<T...>, Y...>>;
};

//  enqcmd X64 [RM] r  [F2] F8 

template<typename ...T, typename ...Y>
struct asm_enqcmd<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF8>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_enqcmd<hold<zip<reg64>::with<T...>, ptr<reg512, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF8>, mrm_v<hold<T...>, Y...>>;
};

//  enqcmds X86 [RM] r  [F3] F8 
template<class T, class Enable = bool> struct asm_enqcmds {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'e','n','q','c','m','d','s', str...>, hold<T...>> {
    using value = typename asm_enqcmds<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_enqcmds<hold<zip<reg32>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF8>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_enqcmds<hold<zip<reg32>::with<T...>, ptr<reg512, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF8>, mrm_v<hold<T...>, Y...>>;
};

//  enqcmds X64 [RM] r  [F3] F8 

template<typename ...T, typename ...Y>
struct asm_enqcmds<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF8>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_enqcmds<hold<zip<reg64>::with<T...>, ptr<reg512, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF8>, mrm_v<hold<T...>, Y...>>;
};

//  enter ANY [II]   [] C8 
template<class T, class Enable = bool> struct asm_enter {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'e','n','t','e','r', str...>, hold<T...>> {
    using value = typename asm_enter<hold<T...>>::value;
};
template <uint16_t T, uint8_t Y> 
struct asm_enter<hold<disp16<T>, disp8<Y>>, bool> {
  using value = expseq_v<byte_seq<0xC8>, typename disp16<T>::value, typename disp8<Y>::value>;
};
//  extractps ANY [MRI] r  [66] 17 
template<class T, class Enable = bool> struct asm_extractps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'e','x','t','r','a','c','t','p','s', str...>, hold<T...>> {
    using value = typename asm_extractps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_extractps<hold<ptr<reg32, T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x17>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  extrq ANY [RII] 0  [66] 78 
template<class T, class Enable = bool> struct asm_extrq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'e','x','t','r','q', str...>, hold<T...>> {
    using value = typename asm_extrq<hold<T...>>::value;
};
//  extrq ANY [RM] r  [66] 79 

template<typename ...T, typename ...Y>
struct asm_extrq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x79>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  f2xm1 ANY [NONE]   [] F0 
template<class T, class Enable = bool> struct asm_f2xm1 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','2','x','m','1', str...>, hold<T...>> {
    using value = typename asm_f2xm1<hold<T...>>::value;
};
template <> struct asm_f2xm1<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xF0>>; };
//  fabs ANY [NONE]   [] E1 
template<class T, class Enable = bool> struct asm_fabs {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','a','b','s', str...>, hold<T...>> {
    using value = typename asm_fabs<hold<T...>>::value;
};
template <> struct asm_fabs<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xE1>>; };
//  fadd ANY [M] 0  [] D8 
template<class T, class Enable = bool> struct asm_fadd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','a','d','d', str...>, hold<T...>> {
    using value = typename asm_fadd<hold<T...>>::value;
};
template<typename ...T>
struct asm_fadd<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_fadd<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD8>, mrm_v<hold<reg<0>>, T...>>;
};

//  fadd ANY [M] 0  [] DC 

template<typename ...T>
struct asm_fadd<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_fadd<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDC>, mrm_v<hold<reg<0>>, T...>>;
};

//  fadd ANY [O]   [] C0 

template<typename ...Y>
struct asm_fadd<hold<st<0>, zip<reg80>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xD8>, byte_seq<0xC0 + reg<reg_n<Y...>::value>::value>>;
};
//  fadd ANY [O]   [] C0 

template<typename ...T>
struct asm_fadd<hold<zip<reg80>::with<T...>, st<0>>, bool> {
  using value = expseq_v<byte_seq<0xDC>, byte_seq<0xC0 + reg<reg_n<T...>::value>::value>>;
};
//  faddp ANY [NONE]   [] C1 
template<class T, class Enable = bool> struct asm_faddp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','a','d','d','p', str...>, hold<T...>> {
    using value = typename asm_faddp<hold<T...>>::value;
};
template <> struct asm_faddp<hold<>, bool> { using value = expseq_v<byte_seq<0xDE>, byte_seq<0xC1>>; };
//  faddp ANY [O]   [] C0 

template<typename ...T>
struct asm_faddp<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDE>, byte_seq<0xC0 + reg<reg_n<T...>::value>::value>>;
};
//  fbld ANY [M] 4  [] DF 
template<class T, class Enable = bool> struct asm_fbld {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','b','l','d', str...>, hold<T...>> {
    using value = typename asm_fbld<hold<T...>>::value;
};
template<typename ...T>
struct asm_fbld<hold<zip<reg128>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_fbld<hold<ptr<reg128, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDF>, mrm_v<hold<reg<4>>, T...>>;
};

//  fbstp ANY [M] 6  [] DF 
template<class T, class Enable = bool> struct asm_fbstp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','b','s','t','p', str...>, hold<T...>> {
    using value = typename asm_fbstp<hold<T...>>::value;
};
template<typename ...T>
struct asm_fbstp<hold<zip<reg128>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

template<typename ...T>
struct asm_fbstp<hold<ptr<reg128, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDF>, mrm_v<hold<reg<6>>, T...>>;
};

//  fchs ANY [NONE]   [] E0 
template<class T, class Enable = bool> struct asm_fchs {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','h','s', str...>, hold<T...>> {
    using value = typename asm_fchs<hold<T...>>::value;
};
template <> struct asm_fchs<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xE0>>; };
//  fclex ANY [NONE]   [9B] E2 
template<class T, class Enable = bool> struct asm_fclex {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','l','e','x', str...>, hold<T...>> {
    using value = typename asm_fclex<hold<T...>>::value;
};
template <> struct asm_fclex<hold<>, bool> { using value = expseq_v<byte_seq<0x9B>, byte_seq<0xDB>, byte_seq<0xE2>>; };
//  fcmovb ANY [O]   [] C0 
template<class T, class Enable = bool> struct asm_fcmovb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','m','o','v','b', str...>, hold<T...>> {
    using value = typename asm_fcmovb<hold<T...>>::value;
};
template<typename ...T>
struct asm_fcmovb<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDA>, byte_seq<0xC0 + reg<reg_n<T...>::value>::value>>;
};
//  fcmovbe ANY [O]   [] D0 
template<class T, class Enable = bool> struct asm_fcmovbe {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','m','o','v','b','e', str...>, hold<T...>> {
    using value = typename asm_fcmovbe<hold<T...>>::value;
};
template<typename ...T>
struct asm_fcmovbe<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDA>, byte_seq<0xD0 + reg<reg_n<T...>::value>::value>>;
};
//  fcmove ANY [O]   [] C8 
template<class T, class Enable = bool> struct asm_fcmove {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','m','o','v','e', str...>, hold<T...>> {
    using value = typename asm_fcmove<hold<T...>>::value;
};
template<typename ...T>
struct asm_fcmove<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDA>, byte_seq<0xC8 + reg<reg_n<T...>::value>::value>>;
};
//  fcmovnb ANY [O]   [] C0 
template<class T, class Enable = bool> struct asm_fcmovnb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','m','o','v','n','b', str...>, hold<T...>> {
    using value = typename asm_fcmovnb<hold<T...>>::value;
};
template<typename ...T>
struct asm_fcmovnb<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDB>, byte_seq<0xC0 + reg<reg_n<T...>::value>::value>>;
};
//  fcmovnbe ANY [O]   [] D0 
template<class T, class Enable = bool> struct asm_fcmovnbe {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','m','o','v','n','b','e', str...>, hold<T...>> {
    using value = typename asm_fcmovnbe<hold<T...>>::value;
};
template<typename ...T>
struct asm_fcmovnbe<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDB>, byte_seq<0xD0 + reg<reg_n<T...>::value>::value>>;
};
//  fcmovne ANY [O]   [] C8 
template<class T, class Enable = bool> struct asm_fcmovne {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','m','o','v','n','e', str...>, hold<T...>> {
    using value = typename asm_fcmovne<hold<T...>>::value;
};
template<typename ...T>
struct asm_fcmovne<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDB>, byte_seq<0xC8 + reg<reg_n<T...>::value>::value>>;
};
//  fcmovnu ANY [O]   [] D8 
template<class T, class Enable = bool> struct asm_fcmovnu {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','m','o','v','n','u', str...>, hold<T...>> {
    using value = typename asm_fcmovnu<hold<T...>>::value;
};
template<typename ...T>
struct asm_fcmovnu<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDB>, byte_seq<0xD8 + reg<reg_n<T...>::value>::value>>;
};
//  fcmovu ANY [O]   [] D8 
template<class T, class Enable = bool> struct asm_fcmovu {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','m','o','v','u', str...>, hold<T...>> {
    using value = typename asm_fcmovu<hold<T...>>::value;
};
template<typename ...T>
struct asm_fcmovu<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDA>, byte_seq<0xD8 + reg<reg_n<T...>::value>::value>>;
};
//  fcom ANY [NONE]   [] D1 
template<class T, class Enable = bool> struct asm_fcom {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','o','m', str...>, hold<T...>> {
    using value = typename asm_fcom<hold<T...>>::value;
};
template <> struct asm_fcom<hold<>, bool> { using value = expseq_v<byte_seq<0xD8>, byte_seq<0xD1>>; };
//  fcom ANY [M] 2  [] D8 

template<typename ...T>
struct asm_fcom<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_fcom<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD8>, mrm_v<hold<reg<2>>, T...>>;
};

//  fcom ANY [M] 2  [] DC 

template<typename ...T>
struct asm_fcom<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_fcom<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDC>, mrm_v<hold<reg<2>>, T...>>;
};

//  fcom ANY [O]   [] D0 

template<typename ...T>
struct asm_fcom<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xD8>, byte_seq<0xD0 + reg<reg_n<T...>::value>::value>>;
};
//  fcomi ANY [O]   [] F0 
template<class T, class Enable = bool> struct asm_fcomi {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','o','m','i', str...>, hold<T...>> {
    using value = typename asm_fcomi<hold<T...>>::value;
};
template<typename ...T>
struct asm_fcomi<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDB>, byte_seq<0xF0 + reg<reg_n<T...>::value>::value>>;
};
//  fcomip ANY [O]   [] F0 
template<class T, class Enable = bool> struct asm_fcomip {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','o','m','i','p', str...>, hold<T...>> {
    using value = typename asm_fcomip<hold<T...>>::value;
};
template<typename ...T>
struct asm_fcomip<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDF>, byte_seq<0xF0 + reg<reg_n<T...>::value>::value>>;
};
//  fcomp ANY [NONE]   [] D9 
template<class T, class Enable = bool> struct asm_fcomp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','o','m','p', str...>, hold<T...>> {
    using value = typename asm_fcomp<hold<T...>>::value;
};
template <> struct asm_fcomp<hold<>, bool> { using value = expseq_v<byte_seq<0xD8>, byte_seq<0xD9>>; };
//  fcomp ANY [M] 3  [] D8 

template<typename ...T>
struct asm_fcomp<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_fcomp<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD8>, mrm_v<hold<reg<3>>, T...>>;
};

//  fcomp ANY [M] 3  [] DC 

template<typename ...T>
struct asm_fcomp<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_fcomp<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDC>, mrm_v<hold<reg<3>>, T...>>;
};

//  fcomp ANY [O]   [] D8 

template<typename ...T>
struct asm_fcomp<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xD8>, byte_seq<0xD8 + reg<reg_n<T...>::value>::value>>;
};
//  fcompp ANY [NONE]   [] D9 
template<class T, class Enable = bool> struct asm_fcompp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','o','m','p','p', str...>, hold<T...>> {
    using value = typename asm_fcompp<hold<T...>>::value;
};
template <> struct asm_fcompp<hold<>, bool> { using value = expseq_v<byte_seq<0xDE>, byte_seq<0xD9>>; };
//  fcos ANY [NONE]   [] FF 
template<class T, class Enable = bool> struct asm_fcos {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','o','s', str...>, hold<T...>> {
    using value = typename asm_fcos<hold<T...>>::value;
};
template <> struct asm_fcos<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xFF>>; };
//  fdecstp ANY [NONE]   [] F6 
template<class T, class Enable = bool> struct asm_fdecstp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','d','e','c','s','t','p', str...>, hold<T...>> {
    using value = typename asm_fdecstp<hold<T...>>::value;
};
template <> struct asm_fdecstp<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xF6>>; };
//  fdiv ANY [M] 6  [] D8 
template<class T, class Enable = bool> struct asm_fdiv {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','d','i','v', str...>, hold<T...>> {
    using value = typename asm_fdiv<hold<T...>>::value;
};
template<typename ...T>
struct asm_fdiv<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

template<typename ...T>
struct asm_fdiv<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD8>, mrm_v<hold<reg<6>>, T...>>;
};

//  fdiv ANY [M] 6  [] DC 

template<typename ...T>
struct asm_fdiv<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

template<typename ...T>
struct asm_fdiv<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDC>, mrm_v<hold<reg<6>>, T...>>;
};

//  fdiv ANY [O]   [] F0 

template<typename ...Y>
struct asm_fdiv<hold<st<0>, zip<reg80>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xD8>, byte_seq<0xF0 + reg<reg_n<Y...>::value>::value>>;
};
//  fdiv ANY [O]   [] F8 

template<typename ...T>
struct asm_fdiv<hold<zip<reg80>::with<T...>, st<0>>, bool> {
  using value = expseq_v<byte_seq<0xDC>, byte_seq<0xF8 + reg<reg_n<T...>::value>::value>>;
};
//  fdivp ANY [NONE]   [] F9 
template<class T, class Enable = bool> struct asm_fdivp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','d','i','v','p', str...>, hold<T...>> {
    using value = typename asm_fdivp<hold<T...>>::value;
};
template <> struct asm_fdivp<hold<>, bool> { using value = expseq_v<byte_seq<0xDE>, byte_seq<0xF9>>; };
//  fdivp ANY [O]   [] F8 

template<typename ...T>
struct asm_fdivp<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDE>, byte_seq<0xF8 + reg<reg_n<T...>::value>::value>>;
};
//  fdivr ANY [M] 7  [] D8 
template<class T, class Enable = bool> struct asm_fdivr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','d','i','v','r', str...>, hold<T...>> {
    using value = typename asm_fdivr<hold<T...>>::value;
};
template<typename ...T>
struct asm_fdivr<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_fdivr<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD8>, mrm_v<hold<reg<7>>, T...>>;
};

//  fdivr ANY [M] 7  [] DC 

template<typename ...T>
struct asm_fdivr<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_fdivr<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDC>, mrm_v<hold<reg<7>>, T...>>;
};

//  fdivr ANY [O]   [] F8 

template<typename ...Y>
struct asm_fdivr<hold<st<0>, zip<reg80>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xD8>, byte_seq<0xF8 + reg<reg_n<Y...>::value>::value>>;
};
//  fdivr ANY [O]   [] F0 

template<typename ...T>
struct asm_fdivr<hold<zip<reg80>::with<T...>, st<0>>, bool> {
  using value = expseq_v<byte_seq<0xDC>, byte_seq<0xF0 + reg<reg_n<T...>::value>::value>>;
};
//  fdivrp ANY [NONE]   [] F1 
template<class T, class Enable = bool> struct asm_fdivrp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','d','i','v','r','p', str...>, hold<T...>> {
    using value = typename asm_fdivrp<hold<T...>>::value;
};
template <> struct asm_fdivrp<hold<>, bool> { using value = expseq_v<byte_seq<0xDE>, byte_seq<0xF1>>; };
//  fdivrp ANY [O]   [] F0 

template<typename ...T>
struct asm_fdivrp<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDE>, byte_seq<0xF0 + reg<reg_n<T...>::value>::value>>;
};
//  femms ANY [NONE]   [] 0E 
template<class T, class Enable = bool> struct asm_femms {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','e','m','m','s', str...>, hold<T...>> {
    using value = typename asm_femms<hold<T...>>::value;
};
template <> struct asm_femms<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x0E>>; };
//  ffree ANY [O]   [] C0 
template<class T, class Enable = bool> struct asm_ffree {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','f','r','e','e', str...>, hold<T...>> {
    using value = typename asm_ffree<hold<T...>>::value;
};
template<typename ...T>
struct asm_ffree<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDD>, byte_seq<0xC0 + reg<reg_n<T...>::value>::value>>;
};
//  fiadd ANY [M] 0  [] DE 
template<class T, class Enable = bool> struct asm_fiadd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','a','d','d', str...>, hold<T...>> {
    using value = typename asm_fiadd<hold<T...>>::value;
};
template<typename ...T>
struct asm_fiadd<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_fiadd<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDE>, mrm_v<hold<reg<0>>, T...>>;
};

//  fiadd ANY [M] 0  [] DA 

template<typename ...T>
struct asm_fiadd<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_fiadd<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDA>, mrm_v<hold<reg<0>>, T...>>;
};

//  ficom ANY [M] 2  [] DE 
template<class T, class Enable = bool> struct asm_ficom {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','c','o','m', str...>, hold<T...>> {
    using value = typename asm_ficom<hold<T...>>::value;
};
template<typename ...T>
struct asm_ficom<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_ficom<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDE>, mrm_v<hold<reg<2>>, T...>>;
};

//  ficom ANY [M] 2  [] DA 

template<typename ...T>
struct asm_ficom<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_ficom<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDA>, mrm_v<hold<reg<2>>, T...>>;
};

//  ficomp ANY [M] 3  [] DE 
template<class T, class Enable = bool> struct asm_ficomp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','c','o','m','p', str...>, hold<T...>> {
    using value = typename asm_ficomp<hold<T...>>::value;
};
template<typename ...T>
struct asm_ficomp<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_ficomp<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDE>, mrm_v<hold<reg<3>>, T...>>;
};

//  ficomp ANY [M] 3  [] DA 

template<typename ...T>
struct asm_ficomp<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_ficomp<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDA>, mrm_v<hold<reg<3>>, T...>>;
};

//  fidiv ANY [M] 6  [] DE 
template<class T, class Enable = bool> struct asm_fidiv {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','d','i','v', str...>, hold<T...>> {
    using value = typename asm_fidiv<hold<T...>>::value;
};
template<typename ...T>
struct asm_fidiv<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

template<typename ...T>
struct asm_fidiv<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDE>, mrm_v<hold<reg<6>>, T...>>;
};

//  fidiv ANY [M] 6  [] DA 

template<typename ...T>
struct asm_fidiv<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

template<typename ...T>
struct asm_fidiv<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDA>, mrm_v<hold<reg<6>>, T...>>;
};

//  fidivr ANY [M] 7  [] DE 
template<class T, class Enable = bool> struct asm_fidivr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','d','i','v','r', str...>, hold<T...>> {
    using value = typename asm_fidivr<hold<T...>>::value;
};
template<typename ...T>
struct asm_fidivr<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_fidivr<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDE>, mrm_v<hold<reg<7>>, T...>>;
};

//  fidivr ANY [M] 7  [] DA 

template<typename ...T>
struct asm_fidivr<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_fidivr<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDA>, mrm_v<hold<reg<7>>, T...>>;
};

//  fild ANY [M] 0  [] DF 
template<class T, class Enable = bool> struct asm_fild {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','l','d', str...>, hold<T...>> {
    using value = typename asm_fild<hold<T...>>::value;
};
template<typename ...T>
struct asm_fild<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_fild<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDF>, mrm_v<hold<reg<0>>, T...>>;
};

//  fild ANY [M] 0  [] DB 

template<typename ...T>
struct asm_fild<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDB>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_fild<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDB>, mrm_v<hold<reg<0>>, T...>>;
};

//  fild ANY [M] 5  [] DF 

template<typename ...T>
struct asm_fild<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_fild<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDF>, mrm_v<hold<reg<5>>, T...>>;
};

//  fimul ANY [M] 1  [] DE 
template<class T, class Enable = bool> struct asm_fimul {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','m','u','l', str...>, hold<T...>> {
    using value = typename asm_fimul<hold<T...>>::value;
};
template<typename ...T>
struct asm_fimul<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_fimul<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDE>, mrm_v<hold<reg<1>>, T...>>;
};

//  fimul ANY [M] 1  [] DA 

template<typename ...T>
struct asm_fimul<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_fimul<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDA>, mrm_v<hold<reg<1>>, T...>>;
};

//  fincstp ANY [NONE]   [] F7 
template<class T, class Enable = bool> struct asm_fincstp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','n','c','s','t','p', str...>, hold<T...>> {
    using value = typename asm_fincstp<hold<T...>>::value;
};
template <> struct asm_fincstp<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xF7>>; };
//  finit ANY [NONE]   [9B] E3 
template<class T, class Enable = bool> struct asm_finit {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','n','i','t', str...>, hold<T...>> {
    using value = typename asm_finit<hold<T...>>::value;
};
template <> struct asm_finit<hold<>, bool> { using value = expseq_v<byte_seq<0x9B>, byte_seq<0xDB>, byte_seq<0xE3>>; };
//  fist ANY [M] 2  [] DF 
template<class T, class Enable = bool> struct asm_fist {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','s','t', str...>, hold<T...>> {
    using value = typename asm_fist<hold<T...>>::value;
};
template<typename ...T>
struct asm_fist<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_fist<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDF>, mrm_v<hold<reg<2>>, T...>>;
};

//  fist ANY [M] 2  [] DB 

template<typename ...T>
struct asm_fist<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDB>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_fist<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDB>, mrm_v<hold<reg<2>>, T...>>;
};

//  fistp ANY [M] 3  [] DF 
template<class T, class Enable = bool> struct asm_fistp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','s','t','p', str...>, hold<T...>> {
    using value = typename asm_fistp<hold<T...>>::value;
};
template<typename ...T>
struct asm_fistp<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_fistp<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDF>, mrm_v<hold<reg<3>>, T...>>;
};

//  fistp ANY [M] 3  [] DB 

template<typename ...T>
struct asm_fistp<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDB>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_fistp<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDB>, mrm_v<hold<reg<3>>, T...>>;
};

//  fistp ANY [M] 7  [] DF 

template<typename ...T>
struct asm_fistp<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_fistp<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDF>, mrm_v<hold<reg<7>>, T...>>;
};

//  fisttp ANY [M] 1  [] DF 
template<class T, class Enable = bool> struct asm_fisttp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','s','t','t','p', str...>, hold<T...>> {
    using value = typename asm_fisttp<hold<T...>>::value;
};
template<typename ...T>
struct asm_fisttp<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_fisttp<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDF>, mrm_v<hold<reg<1>>, T...>>;
};

//  fisttp ANY [M] 1  [] DB 

template<typename ...T>
struct asm_fisttp<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDB>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_fisttp<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDB>, mrm_v<hold<reg<1>>, T...>>;
};

//  fisttp ANY [M] 1  [] DD 

template<typename ...T>
struct asm_fisttp<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDD>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_fisttp<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDD>, mrm_v<hold<reg<1>>, T...>>;
};

//  fisub ANY [M] 4  [] DE 
template<class T, class Enable = bool> struct asm_fisub {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','s','u','b', str...>, hold<T...>> {
    using value = typename asm_fisub<hold<T...>>::value;
};
template<typename ...T>
struct asm_fisub<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_fisub<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDE>, mrm_v<hold<reg<4>>, T...>>;
};

//  fisub ANY [M] 4  [] DA 

template<typename ...T>
struct asm_fisub<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_fisub<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDA>, mrm_v<hold<reg<4>>, T...>>;
};

//  fisubr ANY [M] 5  [] DE 
template<class T, class Enable = bool> struct asm_fisubr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','s','u','b','r', str...>, hold<T...>> {
    using value = typename asm_fisubr<hold<T...>>::value;
};
template<typename ...T>
struct asm_fisubr<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_fisubr<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDE>, mrm_v<hold<reg<5>>, T...>>;
};

//  fisubr ANY [M] 5  [] DA 

template<typename ...T>
struct asm_fisubr<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_fisubr<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDA>, mrm_v<hold<reg<5>>, T...>>;
};

//  fld ANY [M] 0  [] D9 
template<class T, class Enable = bool> struct asm_fld {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d', str...>, hold<T...>> {
    using value = typename asm_fld<hold<T...>>::value;
};
template<typename ...T>
struct asm_fld<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD9>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_fld<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD9>, mrm_v<hold<reg<0>>, T...>>;
};

//  fld ANY [M] 0  [] DD 

template<typename ...T>
struct asm_fld<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDD>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_fld<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDD>, mrm_v<hold<reg<0>>, T...>>;
};

//  fld ANY [M] 5  [] DB 

template<typename ...T>
struct asm_fld<hold<zip<reg128>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDB>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_fld<hold<ptr<reg128, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDB>, mrm_v<hold<reg<5>>, T...>>;
};

//  fld ANY [O]   [] C0 

template<typename ...T>
struct asm_fld<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xD9>, byte_seq<0xC0 + reg<reg_n<T...>::value>::value>>;
};
//  fld1 ANY [NONE]   [] E8 
template<class T, class Enable = bool> struct asm_fld1 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d','1', str...>, hold<T...>> {
    using value = typename asm_fld1<hold<T...>>::value;
};
template <> struct asm_fld1<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xE8>>; };
//  fldcw ANY [M] 5  [] D9 
template<class T, class Enable = bool> struct asm_fldcw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d','c','w', str...>, hold<T...>> {
    using value = typename asm_fldcw<hold<T...>>::value;
};
template<typename ...T>
struct asm_fldcw<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD9>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_fldcw<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD9>, mrm_v<hold<reg<5>>, T...>>;
};

//  fldenv ANY [M] 4  [] D9 
template<class T, class Enable = bool> struct asm_fldenv {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d','e','n','v', str...>, hold<T...>> {
    using value = typename asm_fldenv<hold<T...>>::value;
};
template<typename ...T>
struct asm_fldenv<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD9>, mrm_v<hold<reg<4>>, T...>>;
};

//  fldl2e ANY [NONE]   [] EA 
template<class T, class Enable = bool> struct asm_fldl2e {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d','l','2','e', str...>, hold<T...>> {
    using value = typename asm_fldl2e<hold<T...>>::value;
};
template <> struct asm_fldl2e<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xEA>>; };
//  fldl2t ANY [NONE]   [] E9 
template<class T, class Enable = bool> struct asm_fldl2t {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d','l','2','t', str...>, hold<T...>> {
    using value = typename asm_fldl2t<hold<T...>>::value;
};
template <> struct asm_fldl2t<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xE9>>; };
//  fldlg2 ANY [NONE]   [] EC 
template<class T, class Enable = bool> struct asm_fldlg2 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d','l','g','2', str...>, hold<T...>> {
    using value = typename asm_fldlg2<hold<T...>>::value;
};
template <> struct asm_fldlg2<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xEC>>; };
//  fldln2 ANY [NONE]   [] ED 
template<class T, class Enable = bool> struct asm_fldln2 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d','l','n','2', str...>, hold<T...>> {
    using value = typename asm_fldln2<hold<T...>>::value;
};
template <> struct asm_fldln2<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xED>>; };
//  fldpi ANY [NONE]   [] EB 
template<class T, class Enable = bool> struct asm_fldpi {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d','p','i', str...>, hold<T...>> {
    using value = typename asm_fldpi<hold<T...>>::value;
};
template <> struct asm_fldpi<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xEB>>; };
//  fldz ANY [NONE]   [] EE 
template<class T, class Enable = bool> struct asm_fldz {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d','z', str...>, hold<T...>> {
    using value = typename asm_fldz<hold<T...>>::value;
};
template <> struct asm_fldz<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xEE>>; };
//  fmul ANY [M] 1  [] D8 
template<class T, class Enable = bool> struct asm_fmul {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','m','u','l', str...>, hold<T...>> {
    using value = typename asm_fmul<hold<T...>>::value;
};
template<typename ...T>
struct asm_fmul<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_fmul<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD8>, mrm_v<hold<reg<1>>, T...>>;
};

//  fmul ANY [M] 1  [] DC 

template<typename ...T>
struct asm_fmul<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_fmul<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDC>, mrm_v<hold<reg<1>>, T...>>;
};

//  fmul ANY [O]   [] C8 

template<typename ...Y>
struct asm_fmul<hold<st<0>, zip<reg80>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xD8>, byte_seq<0xC8 + reg<reg_n<Y...>::value>::value>>;
};
//  fmul ANY [O]   [] C8 

template<typename ...T>
struct asm_fmul<hold<zip<reg80>::with<T...>, st<0>>, bool> {
  using value = expseq_v<byte_seq<0xDC>, byte_seq<0xC8 + reg<reg_n<T...>::value>::value>>;
};
//  fmulp ANY [NONE]   [] C9 
template<class T, class Enable = bool> struct asm_fmulp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','m','u','l','p', str...>, hold<T...>> {
    using value = typename asm_fmulp<hold<T...>>::value;
};
template <> struct asm_fmulp<hold<>, bool> { using value = expseq_v<byte_seq<0xDE>, byte_seq<0xC9>>; };
//  fmulp ANY [O]   [] C8 

template<typename ...T>
struct asm_fmulp<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDE>, byte_seq<0xC8 + reg<reg_n<T...>::value>::value>>;
};
//  fnclex ANY [NONE]   [] E2 
template<class T, class Enable = bool> struct asm_fnclex {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','n','c','l','e','x', str...>, hold<T...>> {
    using value = typename asm_fnclex<hold<T...>>::value;
};
template <> struct asm_fnclex<hold<>, bool> { using value = expseq_v<byte_seq<0xDB>, byte_seq<0xE2>>; };
//  fninit ANY [NONE]   [] E3 
template<class T, class Enable = bool> struct asm_fninit {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','n','i','n','i','t', str...>, hold<T...>> {
    using value = typename asm_fninit<hold<T...>>::value;
};
template <> struct asm_fninit<hold<>, bool> { using value = expseq_v<byte_seq<0xDB>, byte_seq<0xE3>>; };
//  fnop ANY [NONE]   [] D0 
template<class T, class Enable = bool> struct asm_fnop {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','n','o','p', str...>, hold<T...>> {
    using value = typename asm_fnop<hold<T...>>::value;
};
template <> struct asm_fnop<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xD0>>; };
//  fnsave ANY [M] 6  [] DD 
template<class T, class Enable = bool> struct asm_fnsave {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','n','s','a','v','e', str...>, hold<T...>> {
    using value = typename asm_fnsave<hold<T...>>::value;
};
template<typename ...T>
struct asm_fnsave<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDD>, mrm_v<hold<reg<6>>, T...>>;
};

//  fnstcw ANY [M] 7  [] D9 
template<class T, class Enable = bool> struct asm_fnstcw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','n','s','t','c','w', str...>, hold<T...>> {
    using value = typename asm_fnstcw<hold<T...>>::value;
};
template<typename ...T>
struct asm_fnstcw<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD9>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_fnstcw<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD9>, mrm_v<hold<reg<7>>, T...>>;
};

//  fnstenv ANY [M] 6  [] D9 
template<class T, class Enable = bool> struct asm_fnstenv {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','n','s','t','e','n','v', str...>, hold<T...>> {
    using value = typename asm_fnstenv<hold<T...>>::value;
};
template<typename ...T>
struct asm_fnstenv<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD9>, mrm_v<hold<reg<6>>, T...>>;
};

//  fnstsw ANY [NONE]   [] E0 
template<class T, class Enable = bool> struct asm_fnstsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','n','s','t','s','w', str...>, hold<T...>> {
    using value = typename asm_fnstsw<hold<T...>>::value;
};
template <>
struct asm_fnstsw<hold<ax>, bool> { using value = expseq_v<byte_seq<0xDF>, byte_seq<0xE0>>; };
//  fnstsw ANY [M] 7  [] DD 

template<typename ...T>
struct asm_fnstsw<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDD>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_fnstsw<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDD>, mrm_v<hold<reg<7>>, T...>>;
};

//  fpatan ANY [NONE]   [F3] D9 
template<class T, class Enable = bool> struct asm_fpatan {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','p','a','t','a','n', str...>, hold<T...>> {
    using value = typename asm_fpatan<hold<T...>>::value;
};
template <> struct asm_fpatan<hold<>, bool> { using value = expseq_v<byte_seq<0xF3>, byte_seq<0xD9>>; };
//  fprem ANY [NONE]   [] F8 
template<class T, class Enable = bool> struct asm_fprem {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','p','r','e','m', str...>, hold<T...>> {
    using value = typename asm_fprem<hold<T...>>::value;
};
template <> struct asm_fprem<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xF8>>; };
//  fprem1 ANY [NONE]   [] F5 
template<class T, class Enable = bool> struct asm_fprem1 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','p','r','e','m','1', str...>, hold<T...>> {
    using value = typename asm_fprem1<hold<T...>>::value;
};
template <> struct asm_fprem1<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xF5>>; };
//  fptan ANY [NONE]   [F2] D9 
template<class T, class Enable = bool> struct asm_fptan {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','p','t','a','n', str...>, hold<T...>> {
    using value = typename asm_fptan<hold<T...>>::value;
};
template <> struct asm_fptan<hold<>, bool> { using value = expseq_v<byte_seq<0xF2>, byte_seq<0xD9>>; };
//  frndint ANY [NONE]   [] FC 
template<class T, class Enable = bool> struct asm_frndint {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','r','n','d','i','n','t', str...>, hold<T...>> {
    using value = typename asm_frndint<hold<T...>>::value;
};
template <> struct asm_frndint<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xFC>>; };
//  frstor ANY [M] 4  [] DD 
template<class T, class Enable = bool> struct asm_frstor {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','r','s','t','o','r', str...>, hold<T...>> {
    using value = typename asm_frstor<hold<T...>>::value;
};
template<typename ...T>
struct asm_frstor<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDD>, mrm_v<hold<reg<4>>, T...>>;
};

//  fsave ANY [M] 6  [9B] DD 
template<class T, class Enable = bool> struct asm_fsave {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','a','v','e', str...>, hold<T...>> {
    using value = typename asm_fsave<hold<T...>>::value;
};
template<typename ...T>
struct asm_fsave<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x9B>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDD>, mrm_v<hold<reg<6>>, T...>>;
};

//  fscale ANY [NONE]   [] FD 
template<class T, class Enable = bool> struct asm_fscale {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','c','a','l','e', str...>, hold<T...>> {
    using value = typename asm_fscale<hold<T...>>::value;
};
template <> struct asm_fscale<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xFD>>; };
//  fsin ANY [NONE]   [] FE 
template<class T, class Enable = bool> struct asm_fsin {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','i','n', str...>, hold<T...>> {
    using value = typename asm_fsin<hold<T...>>::value;
};
template <> struct asm_fsin<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xFE>>; };
//  fsincos ANY [NONE]   [] FB 
template<class T, class Enable = bool> struct asm_fsincos {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','i','n','c','o','s', str...>, hold<T...>> {
    using value = typename asm_fsincos<hold<T...>>::value;
};
template <> struct asm_fsincos<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xFB>>; };
//  fsqrt ANY [NONE]   [] FE 
template<class T, class Enable = bool> struct asm_fsqrt {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','q','r','t', str...>, hold<T...>> {
    using value = typename asm_fsqrt<hold<T...>>::value;
};
template <> struct asm_fsqrt<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xFE>>; };
//  fst ANY [M] 2  [] D9 
template<class T, class Enable = bool> struct asm_fst {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','t', str...>, hold<T...>> {
    using value = typename asm_fst<hold<T...>>::value;
};
template<typename ...T>
struct asm_fst<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD9>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_fst<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD9>, mrm_v<hold<reg<2>>, T...>>;
};

//  fst ANY [M] 2  [] DD 

template<typename ...T>
struct asm_fst<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDD>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_fst<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDD>, mrm_v<hold<reg<2>>, T...>>;
};

//  fst ANY [O]   [] D0 

template<typename ...T>
struct asm_fst<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDD>, byte_seq<0xD0 + reg<reg_n<T...>::value>::value>>;
};
//  fstcw ANY [M] 7  [9B] D9 
template<class T, class Enable = bool> struct asm_fstcw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','t','c','w', str...>, hold<T...>> {
    using value = typename asm_fstcw<hold<T...>>::value;
};
template<typename ...T>
struct asm_fstcw<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x9B>, typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD9>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_fstcw<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x9B>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD9>, mrm_v<hold<reg<7>>, T...>>;
};

//  fstenv ANY [M] 6  [9B] D9 
template<class T, class Enable = bool> struct asm_fstenv {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','t','e','n','v', str...>, hold<T...>> {
    using value = typename asm_fstenv<hold<T...>>::value;
};
template<typename ...T>
struct asm_fstenv<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x9B>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD9>, mrm_v<hold<reg<6>>, T...>>;
};

//  fstp ANY [M] 3  [] D9 
template<class T, class Enable = bool> struct asm_fstp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','t','p', str...>, hold<T...>> {
    using value = typename asm_fstp<hold<T...>>::value;
};
template<typename ...T>
struct asm_fstp<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD9>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_fstp<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD9>, mrm_v<hold<reg<3>>, T...>>;
};

//  fstp ANY [M] 3  [] DD 

template<typename ...T>
struct asm_fstp<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDD>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_fstp<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDD>, mrm_v<hold<reg<3>>, T...>>;
};

//  fstp ANY [M] 7  [] DB 

template<typename ...T>
struct asm_fstp<hold<zip<reg128>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDB>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_fstp<hold<ptr<reg128, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDB>, mrm_v<hold<reg<7>>, T...>>;
};

//  fstp ANY [O]   [] D8 

template<typename ...T>
struct asm_fstp<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDD>, byte_seq<0xD8 + reg<reg_n<T...>::value>::value>>;
};
//  fstsw ANY [NONE]   [9B] E0 
template<class T, class Enable = bool> struct asm_fstsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','t','s','w', str...>, hold<T...>> {
    using value = typename asm_fstsw<hold<T...>>::value;
};
template <>
struct asm_fstsw<hold<ax>, bool> { using value = expseq_v<byte_seq<0x9B>, byte_seq<0xDF>, byte_seq<0xE0>>; };
//  fstsw ANY [M] 7  [9B] DD 

template<typename ...T>
struct asm_fstsw<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x9B>, typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDD>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_fstsw<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x9B>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDD>, mrm_v<hold<reg<7>>, T...>>;
};

//  fsub ANY [M] 4  [] D8 
template<class T, class Enable = bool> struct asm_fsub {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','u','b', str...>, hold<T...>> {
    using value = typename asm_fsub<hold<T...>>::value;
};
template<typename ...T>
struct asm_fsub<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_fsub<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD8>, mrm_v<hold<reg<4>>, T...>>;
};

//  fsub ANY [M] 4  [] DC 

template<typename ...T>
struct asm_fsub<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_fsub<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDC>, mrm_v<hold<reg<4>>, T...>>;
};

//  fsub ANY [O]   [] E0 

template<typename ...Y>
struct asm_fsub<hold<st<0>, zip<reg80>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xD8>, byte_seq<0xE0 + reg<reg_n<Y...>::value>::value>>;
};
//  fsub ANY [O]   [] E8 

template<typename ...T>
struct asm_fsub<hold<zip<reg80>::with<T...>, st<0>>, bool> {
  using value = expseq_v<byte_seq<0xDC>, byte_seq<0xE8 + reg<reg_n<T...>::value>::value>>;
};
//  fsubp ANY [NONE]   [] E9 
template<class T, class Enable = bool> struct asm_fsubp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','u','b','p', str...>, hold<T...>> {
    using value = typename asm_fsubp<hold<T...>>::value;
};
template <> struct asm_fsubp<hold<>, bool> { using value = expseq_v<byte_seq<0xDE>, byte_seq<0xE9>>; };
//  fsubp ANY [O]   [] E8 

template<typename ...T>
struct asm_fsubp<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDE>, byte_seq<0xE8 + reg<reg_n<T...>::value>::value>>;
};
//  fsubr ANY [M] 5  [] D8 
template<class T, class Enable = bool> struct asm_fsubr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','u','b','r', str...>, hold<T...>> {
    using value = typename asm_fsubr<hold<T...>>::value;
};
template<typename ...T>
struct asm_fsubr<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_fsubr<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD8>, mrm_v<hold<reg<5>>, T...>>;
};

//  fsubr ANY [M] 5  [] DC 

template<typename ...T>
struct asm_fsubr<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_fsubr<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDC>, mrm_v<hold<reg<5>>, T...>>;
};

//  fsubr ANY [O]   [] E8 

template<typename ...Y>
struct asm_fsubr<hold<st<0>, zip<reg80>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xD8>, byte_seq<0xE8 + reg<reg_n<Y...>::value>::value>>;
};
//  fsubr ANY [O]   [] E0 

template<typename ...T>
struct asm_fsubr<hold<zip<reg80>::with<T...>, st<0>>, bool> {
  using value = expseq_v<byte_seq<0xDC>, byte_seq<0xE0 + reg<reg_n<T...>::value>::value>>;
};
//  fsubrp ANY [NONE]   [] E1 
template<class T, class Enable = bool> struct asm_fsubrp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','u','b','r','p', str...>, hold<T...>> {
    using value = typename asm_fsubrp<hold<T...>>::value;
};
template <> struct asm_fsubrp<hold<>, bool> { using value = expseq_v<byte_seq<0xDE>, byte_seq<0xE1>>; };
//  fsubrp ANY [O]   [] E0 

template<typename ...T>
struct asm_fsubrp<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDE>, byte_seq<0xE0 + reg<reg_n<T...>::value>::value>>;
};
//  ftst ANY [NONE]   [] E4 
template<class T, class Enable = bool> struct asm_ftst {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','t','s','t', str...>, hold<T...>> {
    using value = typename asm_ftst<hold<T...>>::value;
};
template <> struct asm_ftst<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xE4>>; };
//  fucom ANY [NONE]   [] E1 
template<class T, class Enable = bool> struct asm_fucom {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','u','c','o','m', str...>, hold<T...>> {
    using value = typename asm_fucom<hold<T...>>::value;
};
template <> struct asm_fucom<hold<>, bool> { using value = expseq_v<byte_seq<0xDD>, byte_seq<0xE1>>; };
//  fucom ANY [O]   [] E0 

template<typename ...T>
struct asm_fucom<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDD>, byte_seq<0xE0 + reg<reg_n<T...>::value>::value>>;
};
//  fucomi ANY [O]   [] E8 
template<class T, class Enable = bool> struct asm_fucomi {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','u','c','o','m','i', str...>, hold<T...>> {
    using value = typename asm_fucomi<hold<T...>>::value;
};
template<typename ...T>
struct asm_fucomi<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDB>, byte_seq<0xE8 + reg<reg_n<T...>::value>::value>>;
};
//  fucomip ANY [O]   [] E8 
template<class T, class Enable = bool> struct asm_fucomip {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','u','c','o','m','i','p', str...>, hold<T...>> {
    using value = typename asm_fucomip<hold<T...>>::value;
};
template<typename ...T>
struct asm_fucomip<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDF>, byte_seq<0xE8 + reg<reg_n<T...>::value>::value>>;
};
//  fucomp ANY [NONE]   [] E9 
template<class T, class Enable = bool> struct asm_fucomp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','u','c','o','m','p', str...>, hold<T...>> {
    using value = typename asm_fucomp<hold<T...>>::value;
};
template <> struct asm_fucomp<hold<>, bool> { using value = expseq_v<byte_seq<0xDD>, byte_seq<0xE9>>; };
//  fucomp ANY [O]   [] E8 

template<typename ...T>
struct asm_fucomp<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xDD>, byte_seq<0xE8 + reg<reg_n<T...>::value>::value>>;
};
//  fucompp ANY [NONE]   [] E9 
template<class T, class Enable = bool> struct asm_fucompp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','u','c','o','m','p','p', str...>, hold<T...>> {
    using value = typename asm_fucompp<hold<T...>>::value;
};
template <> struct asm_fucompp<hold<>, bool> { using value = expseq_v<byte_seq<0xDA>, byte_seq<0xE9>>; };
//  fwait ANY [NONE]   [] 9B 
template<class T, class Enable = bool> struct asm_fwait {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','w','a','i','t', str...>, hold<T...>> {
    using value = typename asm_fwait<hold<T...>>::value;
};
template <> struct asm_fwait<hold<>, bool> { using value = expseq_v<byte_seq<0x9B>>; };
//  fxam ANY [NONE]   [] E5 
template<class T, class Enable = bool> struct asm_fxam {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','x','a','m', str...>, hold<T...>> {
    using value = typename asm_fxam<hold<T...>>::value;
};
template <> struct asm_fxam<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xE5>>; };
//  fxch ANY [NONE]   [] C9 
template<class T, class Enable = bool> struct asm_fxch {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','x','c','h', str...>, hold<T...>> {
    using value = typename asm_fxch<hold<T...>>::value;
};
template <> struct asm_fxch<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xC9>>; };
//  fxch ANY [O]   [] C8 

template<typename ...T>
struct asm_fxch<hold<zip<reg80>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xD9>, byte_seq<0xC8 + reg<reg_n<T...>::value>::value>>;
};
//  fxrstor ANY [NONE] 1  [] AE 
template<class T, class Enable = bool> struct asm_fxrstor {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','x','r','s','t','o','r', str...>, hold<T...>> {
    using value = typename asm_fxrstor<hold<T...>>::value;
};
template <typename... T>
struct asm_fxrstor<hold<ptr<reg64, T...>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<1>>>>; };
//  fxrstor64 X64 [NONE] 1  [] AE 
template<class T, class Enable = bool> struct asm_fxrstor64 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','x','r','s','t','o','r','6','4', str...>, hold<T...>> {
    using value = typename asm_fxrstor64<hold<T...>>::value;
};
template <typename... T>
struct asm_fxrstor64<hold<ptr<reg64, T...>>, bool> { using value = expseq_v<byte_seq<0x0F>, typename REX<1, 0, 0, 0>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<1>>>>; };
//  fxsave ANY [NONE] 0  [] AE 
template<class T, class Enable = bool> struct asm_fxsave {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','x','s','a','v','e', str...>, hold<T...>> {
    using value = typename asm_fxsave<hold<T...>>::value;
};
template <typename... T>
struct asm_fxsave<hold<ptr<reg64, T...>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<0>>>>; };
//  fxsave64 X64 [NONE] 0  [] AE 
template<class T, class Enable = bool> struct asm_fxsave64 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','x','s','a','v','e','6','4', str...>, hold<T...>> {
    using value = typename asm_fxsave64<hold<T...>>::value;
};
template <typename... T>
struct asm_fxsave64<hold<ptr<reg64, T...>>, bool> { using value = expseq_v<byte_seq<0x0F>, typename REX<1, 0, 0, 0>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<0>>>>; };
//  fxtract ANY [NONE]   [] F4 
template<class T, class Enable = bool> struct asm_fxtract {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','x','t','r','a','c','t', str...>, hold<T...>> {
    using value = typename asm_fxtract<hold<T...>>::value;
};
template <> struct asm_fxtract<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xF4>>; };
//  fyl2x ANY [NONE]   [] F1 
template<class T, class Enable = bool> struct asm_fyl2x {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','y','l','2','x', str...>, hold<T...>> {
    using value = typename asm_fyl2x<hold<T...>>::value;
};
template <> struct asm_fyl2x<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xF1>>; };
//  fyl2xp1 ANY [NONE]   [] F9 
template<class T, class Enable = bool> struct asm_fyl2xp1 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','y','l','2','x','p','1', str...>, hold<T...>> {
    using value = typename asm_fyl2xp1<hold<T...>>::value;
};
template <> struct asm_fyl2xp1<hold<>, bool> { using value = expseq_v<byte_seq<0xD9>, byte_seq<0xF9>>; };
//  getsec ANY [NONE]   [] 37 
template<class T, class Enable = bool> struct asm_getsec {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'g','e','t','s','e','c', str...>, hold<T...>> {
    using value = typename asm_getsec<hold<T...>>::value;
};
template <> struct asm_getsec<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x37>>; };
//  gf2p8affineinvqb ANY [RMI] r  [66] CF 
template<class T, class Enable = bool> struct asm_gf2p8affineinvqb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'g','f','2','p','8','a','f','f','i','n','e','i','n','v','q','b', str...>, hold<T...>> {
    using value = typename asm_gf2p8affineinvqb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_gf2p8affineinvqb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xCF>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_gf2p8affineinvqb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xCF>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  gf2p8affineqb ANY [RMI] r  [66] CE 
template<class T, class Enable = bool> struct asm_gf2p8affineqb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'g','f','2','p','8','a','f','f','i','n','e','q','b', str...>, hold<T...>> {
    using value = typename asm_gf2p8affineqb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_gf2p8affineqb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xCE>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_gf2p8affineqb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xCE>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  gf2p8mulb ANY [RM] r  [66] CF 
template<class T, class Enable = bool> struct asm_gf2p8mulb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'g','f','2','p','8','m','u','l','b', str...>, hold<T...>> {
    using value = typename asm_gf2p8mulb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_gf2p8mulb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xCF>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_gf2p8mulb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xCF>, mrm_v<hold<T...>, Y...>>;
};

//  haddpd ANY [RM] r  [66] 7C 
template<class T, class Enable = bool> struct asm_haddpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'h','a','d','d','p','d', str...>, hold<T...>> {
    using value = typename asm_haddpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_haddpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x7C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_haddpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x7C>, mrm_v<hold<T...>, Y...>>;
};

//  haddps ANY [RM] r  [F2] 7C 
template<class T, class Enable = bool> struct asm_haddps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'h','a','d','d','p','s', str...>, hold<T...>> {
    using value = typename asm_haddps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_haddps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x7C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_haddps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x7C>, mrm_v<hold<T...>, Y...>>;
};

//  hlt ANY [NONE]   [] F4 
template<class T, class Enable = bool> struct asm_hlt {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'h','l','t', str...>, hold<T...>> {
    using value = typename asm_hlt<hold<T...>>::value;
};
template <> struct asm_hlt<hold<>, bool> { using value = expseq_v<byte_seq<0xF4>>; };
//  hreset ANY [I] 0  [F3] F0 
template<class T, class Enable = bool> struct asm_hreset {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'h','r','e','s','e','t', str...>, hold<T...>> {
    using value = typename asm_hreset<hold<T...>>::value;
};
template <class T> 
struct asm_hreset<hold<T, eax>, typename u8_8<T>::type> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x3A>, byte_seq<0xF0>, typename u8_8<T>::value>;
};
//  hsubpd ANY [RM] r  [66] 7D 
template<class T, class Enable = bool> struct asm_hsubpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'h','s','u','b','p','d', str...>, hold<T...>> {
    using value = typename asm_hsubpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_hsubpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x7D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_hsubpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x7D>, mrm_v<hold<T...>, Y...>>;
};

//  hsubps ANY [RM] r  [F2] 7D 
template<class T, class Enable = bool> struct asm_hsubps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'h','s','u','b','p','s', str...>, hold<T...>> {
    using value = typename asm_hsubps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_hsubps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x7D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_hsubps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x7D>, mrm_v<hold<T...>, Y...>>;
};

//  idiv ANY [M] 7  [] F6 
template<class T, class Enable = bool> struct asm_idiv {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','d','i','v', str...>, hold<T...>> {
    using value = typename asm_idiv<hold<T...>>::value;
};
template<typename ...Y>
struct asm_idiv<hold<zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<reg<7>>>::value>;
};

template<typename ...Y>
struct asm_idiv<hold<ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, mrm_v<hold<reg<7>>, Y...>>;
};

//  idiv ANY [M] 7  [66] F7 

template<typename ...Z>
struct asm_idiv<hold<zip<reg16>::with<Z...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<7>>>::value>;
};

template<typename ...Z>
struct asm_idiv<hold<ptr<reg16, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<7>>, Z...>>;
};

//  idiv ANY [M] 7  [] F7 

template<typename ...Z>
struct asm_idiv<hold<zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<7>>>::value>;
};

template<typename ...Z>
struct asm_idiv<hold<ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<7>>, Z...>>;
};

//  idiv X64 [M] 7  [] F7 

template<typename ...Z>
struct asm_idiv<hold<zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<7>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<7>>>::value>;
};

template<typename ...Z>
struct asm_idiv<hold<ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename REX<1, is_ext_v<hold<reg<7>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<7>>, Z...>>;
};

//  imul ANY [M] 5  [] F6 
template<class T, class Enable = bool> struct asm_imul {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','m','u','l', str...>, hold<T...>> {
    using value = typename asm_imul<hold<T...>>::value;
};
template<typename ...Y>
struct asm_imul<hold<zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<reg<5>>>::value>;
};

template<typename ...Y>
struct asm_imul<hold<ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, mrm_v<hold<reg<5>>, Y...>>;
};

//  imul ANY [M] 5  [66] F7 

template<typename ...Z>
struct asm_imul<hold<zip<reg16>::with<Z...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<5>>>::value>;
};

template<typename ...Z>
struct asm_imul<hold<ptr<reg16, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<5>>, Z...>>;
};

//  imul ANY [M] 5  [] F7 

template<typename ...Z>
struct asm_imul<hold<zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<5>>>::value>;
};

template<typename ...Z>
struct asm_imul<hold<ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<5>>, Z...>>;
};

//  imul X64 [M] 5  [] F7 

template<typename ...Z>
struct asm_imul<hold<zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<5>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<5>>>::value>;
};

template<typename ...Z>
struct asm_imul<hold<ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<5>>, Z...>>;
};

//  imul ANY [RM] r  [66] AF 

template<typename ...T, typename ...Y>
struct asm_imul<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xAF>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_imul<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xAF>, mrm_v<hold<T...>, Y...>>;
};

//  imul ANY [RM] r  [] AF 

template<typename ...T, typename ...Y>
struct asm_imul<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xAF>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_imul<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xAF>, mrm_v<hold<T...>, Y...>>;
};

//  imul X64 [RM] r  [] AF 

template<typename ...T, typename ...Y>
struct asm_imul<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xAF>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_imul<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xAF>, mrm_v<hold<T...>, Y...>>;
};

//  imul ANY [RMI] r  [66] 6B 

template<typename ...T, typename ...Y, class Z>
struct asm_imul<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>, Z>, typename i8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6B>, typename modrm<hold<Y...>, hold<T...>>::value, typename i8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_imul<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>, Z>, typename i8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6B>, mrm_v<hold<T...>, Y...>, typename i8_8<Z>::value>;
};

//  imul ANY [RMI] r  [] 6B 

template<typename ...T, typename ...Y, class Z>
struct asm_imul<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, Z>, typename i8_8<Z>::type> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6B>, typename modrm<hold<Y...>, hold<T...>>::value, typename i8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_imul<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>, Z>, typename i8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6B>, mrm_v<hold<T...>, Y...>, typename i8_8<Z>::value>;
};

//  imul X64 [RMI] r  [] 6B 

template<typename ...T, typename ...Y, class Z>
struct asm_imul<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, Z>, typename i8_8<Z>::type> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6B>, typename modrm<hold<Y...>, hold<T...>>::value, typename i8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_imul<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>, Z>, typename i8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6B>, mrm_v<hold<T...>, Y...>, typename i8_8<Z>::value>;
};

//  imul ANY [RMI] r  [66] 69 

template<typename ...T, typename ...Y, class Z>
struct asm_imul<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>, Z>, typename u16_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x69>, typename modrm<hold<Y...>, hold<T...>>::value, typename u16_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_imul<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>, Z>, typename u16_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x69>, mrm_v<hold<T...>, Y...>, typename u16_8<Z>::value>;
};

//  imul ANY [RMI] r  [] 69 

template<typename ...T, typename ...Y, class Z>
struct asm_imul<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, Z>, typename u32_8<Z>::type> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x69>, typename modrm<hold<Y...>, hold<T...>>::value, typename u32_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_imul<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>, Z>, typename u32_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x69>, mrm_v<hold<T...>, Y...>, typename u32_8<Z>::value>;
};

//  imul X64 [RMI] r  [] 69 

template<typename ...T, typename ...Y, class Z>
struct asm_imul<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, Z>, typename i32_8<Z>::type> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x69>, typename modrm<hold<Y...>, hold<T...>>::value, typename i32_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_imul<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>, Z>, typename i32_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x69>, mrm_v<hold<T...>, Y...>, typename i32_8<Z>::value>;
};

//  in ANY [I]   [] E4 
template<class T, class Enable = bool> struct asm_in {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n', str...>, hold<T...>> {
    using value = typename asm_in<hold<T...>>::value;
};
template <class Y> 
struct asm_in<hold<al, Y>, typename u8_8<Y>::type>{
  using value = expseq_v<byte_seq<0xE4>, typename u8_8<Y>::value>;
};
//  in ANY [I]   [66] E5 

template <class Y> 
struct asm_in<hold<ax, Y>, typename u8_8<Y>::type>{
  using value = expseq_v<byte_seq<0x66>, byte_seq<0xE5>, typename u8_8<Y>::value>;
};
//  in ANY [I]   [] E5 

template <class Y> 
struct asm_in<hold<eax, Y>, typename u8_8<Y>::type>{
  using value = expseq_v<byte_seq<0xE5>, typename u8_8<Y>::value>;
};
//  inc X86 [O]   [66] 40 
template<class T, class Enable = bool> struct asm_inc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','c', str...>, hold<T...>> {
    using value = typename asm_inc<hold<T...>>::value;
};
//  inc X86 [O]   [] 40 

//  inc ANY [M] 0  [] FE 

template<typename ...T>
struct asm_inc<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFE>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_inc<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFE>, mrm_v<hold<reg<0>>, T...>>;
};

//  inc ANY [M] 0  [66] FF 

template<typename ...T>
struct asm_inc<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_inc<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<0>>, T...>>;
};

//  inc ANY [M] 0  [] FF 

template<typename ...T>
struct asm_inc<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_inc<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<0>>, T...>>;
};

//  inc X64 [M] 0  [] FF 

template<typename ...T>
struct asm_inc<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_inc<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<0>>, T...>>;
};

//  incsspd ANY [M] 5  [F3] AE 
template<class T, class Enable = bool> struct asm_incsspd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','c','s','s','p','d', str...>, hold<T...>> {
    using value = typename asm_incsspd<hold<T...>>::value;
};
template<typename ...T>
struct asm_incsspd<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

//  incsspq X64 [M] 5  [F3] AE 
template<class T, class Enable = bool> struct asm_incsspq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','c','s','s','p','q', str...>, hold<T...>> {
    using value = typename asm_incsspq<hold<T...>>::value;
};
template<typename ...T>
struct asm_incsspq<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

//  insb ANY [NONE]   [] 6C 
template<class T, class Enable = bool> struct asm_insb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','s','b', str...>, hold<T...>> {
    using value = typename asm_insb<hold<T...>>::value;
};
template <>
struct asm_insb<hold<zdi, dx>, bool> { using value = expseq_v<byte_seq<0x6C>>; };
//  insd ANY [NONE]   [] 6D 
template<class T, class Enable = bool> struct asm_insd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','s','d', str...>, hold<T...>> {
    using value = typename asm_insd<hold<T...>>::value;
};
template <>
struct asm_insd<hold<zdi, dx>, bool> { using value = expseq_v<byte_seq<0x6D>>; };
//  insertps ANY [RMI] r  [66] 21 
template<class T, class Enable = bool> struct asm_insertps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','s','e','r','t','p','s', str...>, hold<T...>> {
    using value = typename asm_insertps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_insertps<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x21>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_insertps<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x21>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  insertq ANY [RM] r  [F2] 79 
template<class T, class Enable = bool> struct asm_insertq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','s','e','r','t','q', str...>, hold<T...>> {
    using value = typename asm_insertq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_insertq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x79>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  insertq ANY [RMII] r  [F2] 78 

template<typename ...T, typename ...Y, class Z, class O>
struct asm_insertq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z, O>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x78>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value, typename u8_8<O>::value>;
};

//  insw ANY [NONE]   [66] 6D 
template<class T, class Enable = bool> struct asm_insw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','s','w', str...>, hold<T...>> {
    using value = typename asm_insw<hold<T...>>::value;
};
template <>
struct asm_insw<hold<zdi, dx>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x6D>>; };
//  int ANY [I]   [] CD 
template<class T, class Enable = bool> struct asm_int {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','t', str...>, hold<T...>> {
    using value = typename asm_int<hold<T...>>::value;
};
template <class T> 
struct asm_int<hold<T>, typename u8_8<T>::type> {
  using value = expseq_v<byte_seq<0xCD>, typename u8_8<T>::value>;
};
//  int3 ANY [NONE]   [] CC 
template<class T, class Enable = bool> struct asm_int3 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','t','3', str...>, hold<T...>> {
    using value = typename asm_int3<hold<T...>>::value;
};
template <> struct asm_int3<hold<>, bool> { using value = expseq_v<byte_seq<0xCC>>; };
//  into X86 [NONE]   [] CE 
template<class T, class Enable = bool> struct asm_into {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','t','o', str...>, hold<T...>> {
    using value = typename asm_into<hold<T...>>::value;
};
template <> struct asm_into<hold<>, bool> { using value = expseq_v<byte_seq<0xCE>>; };
//  invd ANY [NONE]   [] 08 
template<class T, class Enable = bool> struct asm_invd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','v','d', str...>, hold<T...>> {
    using value = typename asm_invd<hold<T...>>::value;
};
template <> struct asm_invd<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x08>>; };
//  invept X86 [RM] r  [66] 80 
template<class T, class Enable = bool> struct asm_invept {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','v','e','p','t', str...>, hold<T...>> {
    using value = typename asm_invept<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_invept<hold<zip<reg32>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x80>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_invept<hold<zip<reg32>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x80>, mrm_v<hold<T...>, Y...>>;
};

//  invept X64 [RM] r  [66] 80 

template<typename ...T, typename ...Y>
struct asm_invept<hold<zip<reg64>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x80>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_invept<hold<zip<reg64>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x80>, mrm_v<hold<T...>, Y...>>;
};

//  invlpg ANY [M] 7  [] 01 
template<class T, class Enable = bool> struct asm_invlpg {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','v','l','p','g', str...>, hold<T...>> {
    using value = typename asm_invlpg<hold<T...>>::value;
};
template<typename ...T>
struct asm_invlpg<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, mrm_v<hold<reg<7>>, T...>>;
};

//  invlpga X86 [NONE]   [] DF 
template<class T, class Enable = bool> struct asm_invlpga {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','v','l','p','g','a', str...>, hold<T...>> {
    using value = typename asm_invlpga<hold<T...>>::value;
};
template <>
struct asm_invlpga<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xDF>>; };
//  invpcid X86 [RM] r  [66] 82 
template<class T, class Enable = bool> struct asm_invpcid {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','v','p','c','i','d', str...>, hold<T...>> {
    using value = typename asm_invpcid<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_invpcid<hold<zip<reg32>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x82>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_invpcid<hold<zip<reg32>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x82>, mrm_v<hold<T...>, Y...>>;
};

//  invpcid X64 [RM] r  [66] 82 

template<typename ...T, typename ...Y>
struct asm_invpcid<hold<zip<reg64>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x82>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_invpcid<hold<zip<reg64>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x82>, mrm_v<hold<T...>, Y...>>;
};

//  invvpid X86 [RM] r  [66] 81 
template<class T, class Enable = bool> struct asm_invvpid {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','v','v','p','i','d', str...>, hold<T...>> {
    using value = typename asm_invvpid<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_invvpid<hold<zip<reg32>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x81>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_invvpid<hold<zip<reg32>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x81>, mrm_v<hold<T...>, Y...>>;
};

//  invvpid X64 [RM] r  [66] 81 

template<typename ...T, typename ...Y>
struct asm_invvpid<hold<zip<reg64>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x81>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_invvpid<hold<zip<reg64>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x81>, mrm_v<hold<T...>, Y...>>;
};

//  iret ANY [NONE]   [66] CF 
template<class T, class Enable = bool> struct asm_iret {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','r','e','t', str...>, hold<T...>> {
    using value = typename asm_iret<hold<T...>>::value;
};
template <> struct asm_iret<hold<>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0xCF>>; };
//  iretd ANY [NONE]   [] CF 
template<class T, class Enable = bool> struct asm_iretd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','r','e','t','d', str...>, hold<T...>> {
    using value = typename asm_iretd<hold<T...>>::value;
};
template <> struct asm_iretd<hold<>, bool> { using value = expseq_v<byte_seq<0xCF>>; };
//  iretq X64 [NONE]   [] CF 
template<class T, class Enable = bool> struct asm_iretq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','r','e','t','q', str...>, hold<T...>> {
    using value = typename asm_iretq<hold<T...>>::value;
};
template <> struct asm_iretq<hold<>, bool> { using value = expseq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0xCF>>; };
//  ja ANY [D]   [] 77 
template<class T, class Enable = bool> struct asm_ja {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','a', str...>, hold<T...>> {
    using value = typename asm_ja<hold<T...>>::value;
};
template<uint8_t N>
struct asm_ja<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x77>, typename rel8<N>::value>; };
//  ja X86 [D]   [66] 87 

template<uint16_t N>
struct asm_ja<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x87>, typename rel16<N>::value>; };
//  ja ANY [D]   [] 87 

template<uint32_t N>
struct asm_ja<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x87>, typename rel32<N>::value>; };
//  jae ANY [D]   [] 73 
template<class T, class Enable = bool> struct asm_jae {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','a','e', str...>, hold<T...>> {
    using value = typename asm_jae<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jae<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x73>, typename rel8<N>::value>; };
//  jae X86 [D]   [66] 83 

template<uint16_t N>
struct asm_jae<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x83>, typename rel16<N>::value>; };
//  jae ANY [D]   [] 83 

template<uint32_t N>
struct asm_jae<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x83>, typename rel32<N>::value>; };
//  jb ANY [D]   [] 72 
template<class T, class Enable = bool> struct asm_jb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','b', str...>, hold<T...>> {
    using value = typename asm_jb<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jb<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x72>, typename rel8<N>::value>; };
//  jb X86 [D]   [66] 82 

template<uint16_t N>
struct asm_jb<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x82>, typename rel16<N>::value>; };
//  jb ANY [D]   [] 82 

template<uint32_t N>
struct asm_jb<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x82>, typename rel32<N>::value>; };
//  jbe ANY [D]   [] 76 
template<class T, class Enable = bool> struct asm_jbe {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','b','e', str...>, hold<T...>> {
    using value = typename asm_jbe<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jbe<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x76>, typename rel8<N>::value>; };
//  jbe X86 [D]   [66] 86 

template<uint16_t N>
struct asm_jbe<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x86>, typename rel16<N>::value>; };
//  jbe ANY [D]   [] 86 

template<uint32_t N>
struct asm_jbe<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x86>, typename rel32<N>::value>; };
//  jc ANY [D]   [] 72 
template<class T, class Enable = bool> struct asm_jc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','c', str...>, hold<T...>> {
    using value = typename asm_jc<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jc<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x72>, typename rel8<N>::value>; };
//  jc X86 [D]   [66] 82 

template<uint16_t N>
struct asm_jc<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x82>, typename rel16<N>::value>; };
//  jc ANY [D]   [] 82 

template<uint32_t N>
struct asm_jc<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x82>, typename rel32<N>::value>; };
//  je ANY [D]   [] 74 
template<class T, class Enable = bool> struct asm_je {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','e', str...>, hold<T...>> {
    using value = typename asm_je<hold<T...>>::value;
};
template<uint8_t N>
struct asm_je<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x74>, typename rel8<N>::value>; };
//  je X86 [D]   [66] 84 

template<uint16_t N>
struct asm_je<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x84>, typename rel16<N>::value>; };
//  je ANY [D]   [] 84 

template<uint32_t N>
struct asm_je<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x84>, typename rel32<N>::value>; };
//  jecxz X86 [D]   [] E3 
template<class T, class Enable = bool> struct asm_jecxz {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','e','c','x','z', str...>, hold<T...>> {
    using value = typename asm_jecxz<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jecxz<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x67>, byte_seq<0xE3>, typename rel8<N>::value>; };
//  jg ANY [D]   [] 7F 
template<class T, class Enable = bool> struct asm_jg {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','g', str...>, hold<T...>> {
    using value = typename asm_jg<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jg<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x7F>, typename rel8<N>::value>; };
//  jg X86 [D]   [66] 8F 

template<uint16_t N>
struct asm_jg<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x8F>, typename rel16<N>::value>; };
//  jg ANY [D]   [] 8F 

template<uint32_t N>
struct asm_jg<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x8F>, typename rel32<N>::value>; };
//  jge ANY [D]   [] 7D 
template<class T, class Enable = bool> struct asm_jge {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','g','e', str...>, hold<T...>> {
    using value = typename asm_jge<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jge<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x7D>, typename rel8<N>::value>; };
//  jge X86 [D]   [66] 8D 

template<uint16_t N>
struct asm_jge<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x8D>, typename rel16<N>::value>; };
//  jge ANY [D]   [] 8D 

template<uint32_t N>
struct asm_jge<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x8D>, typename rel32<N>::value>; };
//  jl ANY [D]   [] 7C 
template<class T, class Enable = bool> struct asm_jl {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','l', str...>, hold<T...>> {
    using value = typename asm_jl<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jl<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x7C>, typename rel8<N>::value>; };
//  jl X86 [D]   [66] 8C 

template<uint16_t N>
struct asm_jl<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x8C>, typename rel16<N>::value>; };
//  jl ANY [D]   [] 8C 

template<uint32_t N>
struct asm_jl<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x8C>, typename rel32<N>::value>; };
//  jle ANY [D]   [] 7E 
template<class T, class Enable = bool> struct asm_jle {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','l','e', str...>, hold<T...>> {
    using value = typename asm_jle<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jle<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x7E>, typename rel8<N>::value>; };
//  jle X86 [D]   [66] 8E 

template<uint16_t N>
struct asm_jle<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x8E>, typename rel16<N>::value>; };
//  jle ANY [D]   [] 8E 

template<uint32_t N>
struct asm_jle<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x8E>, typename rel32<N>::value>; };
//  jmp ANY [D]   [] EB 
template<class T, class Enable = bool> struct asm_jmp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','m','p', str...>, hold<T...>> {
    using value = typename asm_jmp<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jmp<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0xEB>, typename rel8<N>::value>; };
//  jmp X86 [D]   [66] E9 

template<uint16_t N>
struct asm_jmp<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0xE9>, typename rel16<N>::value>; };
//  jmp ANY [D]   [] E9 

template<uint32_t N>
struct asm_jmp<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0xE9>, typename rel32<N>::value>; };
//  jmp X86 [D] 4  [] FF 

template<typename ...T>
struct asm_jmp<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_jmp<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<4>>, T...>>;
};

//  jmp X64 [D] 4  [] FF 

template<typename ...T>
struct asm_jmp<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_jmp<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<4>>, T...>>;
};

//  jna ANY [D]   [] 76 
template<class T, class Enable = bool> struct asm_jna {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','a', str...>, hold<T...>> {
    using value = typename asm_jna<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jna<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x76>, typename rel8<N>::value>; };
//  jna X86 [D]   [66] 86 

template<uint16_t N>
struct asm_jna<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x86>, typename rel16<N>::value>; };
//  jna ANY [D]   [] 86 

template<uint32_t N>
struct asm_jna<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x86>, typename rel32<N>::value>; };
//  jnae ANY [D]   [] 72 
template<class T, class Enable = bool> struct asm_jnae {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','a','e', str...>, hold<T...>> {
    using value = typename asm_jnae<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jnae<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x72>, typename rel8<N>::value>; };
//  jnae X86 [D]   [66] 82 

template<uint16_t N>
struct asm_jnae<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x82>, typename rel16<N>::value>; };
//  jnae ANY [D]   [] 82 

template<uint32_t N>
struct asm_jnae<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x82>, typename rel32<N>::value>; };
//  jnb ANY [D]   [] 73 
template<class T, class Enable = bool> struct asm_jnb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','b', str...>, hold<T...>> {
    using value = typename asm_jnb<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jnb<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x73>, typename rel8<N>::value>; };
//  jnb X86 [D]   [66] 83 

template<uint16_t N>
struct asm_jnb<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x83>, typename rel16<N>::value>; };
//  jnb ANY [D]   [] 83 

template<uint32_t N>
struct asm_jnb<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x83>, typename rel32<N>::value>; };
//  jnbe ANY [D]   [] 77 
template<class T, class Enable = bool> struct asm_jnbe {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','b','e', str...>, hold<T...>> {
    using value = typename asm_jnbe<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jnbe<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x77>, typename rel8<N>::value>; };
//  jnbe X86 [D]   [66] 87 

template<uint16_t N>
struct asm_jnbe<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x87>, typename rel16<N>::value>; };
//  jnbe ANY [D]   [] 87 

template<uint32_t N>
struct asm_jnbe<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x87>, typename rel32<N>::value>; };
//  jnc ANY [D]   [] 73 
template<class T, class Enable = bool> struct asm_jnc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','c', str...>, hold<T...>> {
    using value = typename asm_jnc<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jnc<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x73>, typename rel8<N>::value>; };
//  jnc X86 [D]   [66] 83 

template<uint16_t N>
struct asm_jnc<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x83>, typename rel16<N>::value>; };
//  jnc ANY [D]   [] 83 

template<uint32_t N>
struct asm_jnc<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x83>, typename rel32<N>::value>; };
//  jne ANY [D]   [] 75 
template<class T, class Enable = bool> struct asm_jne {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','e', str...>, hold<T...>> {
    using value = typename asm_jne<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jne<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x75>, typename rel8<N>::value>; };
//  jne X86 [D]   [66] 85 

template<uint16_t N>
struct asm_jne<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x85>, typename rel16<N>::value>; };
//  jne ANY [D]   [] 85 

template<uint32_t N>
struct asm_jne<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x85>, typename rel32<N>::value>; };
//  jng ANY [D]   [] 7E 
template<class T, class Enable = bool> struct asm_jng {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','g', str...>, hold<T...>> {
    using value = typename asm_jng<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jng<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x7E>, typename rel8<N>::value>; };
//  jng X86 [D]   [66] 8E 

template<uint16_t N>
struct asm_jng<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x8E>, typename rel16<N>::value>; };
//  jng ANY [D]   [] 8E 

template<uint32_t N>
struct asm_jng<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x8E>, typename rel32<N>::value>; };
//  jnge ANY [D]   [] 7C 
template<class T, class Enable = bool> struct asm_jnge {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','g','e', str...>, hold<T...>> {
    using value = typename asm_jnge<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jnge<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x7C>, typename rel8<N>::value>; };
//  jnge X86 [D]   [66] 8C 

template<uint16_t N>
struct asm_jnge<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x8C>, typename rel16<N>::value>; };
//  jnge ANY [D]   [] 8C 

template<uint32_t N>
struct asm_jnge<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x8C>, typename rel32<N>::value>; };
//  jnl ANY [D]   [] 7D 
template<class T, class Enable = bool> struct asm_jnl {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','l', str...>, hold<T...>> {
    using value = typename asm_jnl<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jnl<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x7D>, typename rel8<N>::value>; };
//  jnl X86 [D]   [66] 8D 

template<uint16_t N>
struct asm_jnl<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x8D>, typename rel16<N>::value>; };
//  jnl ANY [D]   [] 8D 

template<uint32_t N>
struct asm_jnl<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x8D>, typename rel32<N>::value>; };
//  jnle ANY [D]   [] 7F 
template<class T, class Enable = bool> struct asm_jnle {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','l','e', str...>, hold<T...>> {
    using value = typename asm_jnle<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jnle<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x7F>, typename rel8<N>::value>; };
//  jnle X86 [D]   [66] 8F 

template<uint16_t N>
struct asm_jnle<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x8F>, typename rel16<N>::value>; };
//  jnle ANY [D]   [] 8F 

template<uint32_t N>
struct asm_jnle<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x8F>, typename rel32<N>::value>; };
//  jno ANY [D]   [] 71 
template<class T, class Enable = bool> struct asm_jno {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','o', str...>, hold<T...>> {
    using value = typename asm_jno<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jno<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x71>, typename rel8<N>::value>; };
//  jno X86 [D]   [66] 81 

template<uint16_t N>
struct asm_jno<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x81>, typename rel16<N>::value>; };
//  jno ANY [D]   [] 81 

template<uint32_t N>
struct asm_jno<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x81>, typename rel32<N>::value>; };
//  jnp ANY [D]   [] 7B 
template<class T, class Enable = bool> struct asm_jnp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','p', str...>, hold<T...>> {
    using value = typename asm_jnp<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jnp<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x7B>, typename rel8<N>::value>; };
//  jnp X86 [D]   [66] 8B 

template<uint16_t N>
struct asm_jnp<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x8B>, typename rel16<N>::value>; };
//  jnp ANY [D]   [] 8B 

template<uint32_t N>
struct asm_jnp<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x8B>, typename rel32<N>::value>; };
//  jns ANY [D]   [] 79 
template<class T, class Enable = bool> struct asm_jns {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','s', str...>, hold<T...>> {
    using value = typename asm_jns<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jns<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x79>, typename rel8<N>::value>; };
//  jns X86 [D]   [66] 89 

template<uint16_t N>
struct asm_jns<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x89>, typename rel16<N>::value>; };
//  jns ANY [D]   [] 89 

template<uint32_t N>
struct asm_jns<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x89>, typename rel32<N>::value>; };
//  jnz ANY [D]   [] 75 
template<class T, class Enable = bool> struct asm_jnz {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','z', str...>, hold<T...>> {
    using value = typename asm_jnz<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jnz<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x75>, typename rel8<N>::value>; };
//  jnz X86 [D]   [66] 85 

template<uint16_t N>
struct asm_jnz<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x85>, typename rel16<N>::value>; };
//  jnz ANY [D]   [] 85 

template<uint32_t N>
struct asm_jnz<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x85>, typename rel32<N>::value>; };
//  jo ANY [D]   [] 70 
template<class T, class Enable = bool> struct asm_jo {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','o', str...>, hold<T...>> {
    using value = typename asm_jo<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jo<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x70>, typename rel8<N>::value>; };
//  jo X86 [D]   [66] 80 

template<uint16_t N>
struct asm_jo<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x80>, typename rel16<N>::value>; };
//  jo ANY [D]   [] 80 

template<uint32_t N>
struct asm_jo<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x80>, typename rel32<N>::value>; };
//  jp ANY [D]   [] 7A 
template<class T, class Enable = bool> struct asm_jp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','p', str...>, hold<T...>> {
    using value = typename asm_jp<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jp<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x7A>, typename rel8<N>::value>; };
//  jp X86 [D]   [66] 8A 

template<uint16_t N>
struct asm_jp<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x8A>, typename rel16<N>::value>; };
//  jp ANY [D]   [] 8A 

template<uint32_t N>
struct asm_jp<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x8A>, typename rel32<N>::value>; };
//  jpe ANY [D]   [] 7A 
template<class T, class Enable = bool> struct asm_jpe {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','p','e', str...>, hold<T...>> {
    using value = typename asm_jpe<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jpe<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x7A>, typename rel8<N>::value>; };
//  jpe X86 [D]   [66] 8A 

template<uint16_t N>
struct asm_jpe<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x8A>, typename rel16<N>::value>; };
//  jpe ANY [D]   [] 8A 

template<uint32_t N>
struct asm_jpe<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x8A>, typename rel32<N>::value>; };
//  jpo ANY [D]   [] 7B 
template<class T, class Enable = bool> struct asm_jpo {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','p','o', str...>, hold<T...>> {
    using value = typename asm_jpo<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jpo<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x7B>, typename rel8<N>::value>; };
//  jpo X86 [D]   [66] 8B 

template<uint16_t N>
struct asm_jpo<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x8B>, typename rel16<N>::value>; };
//  jpo ANY [D]   [] 8B 

template<uint32_t N>
struct asm_jpo<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x8B>, typename rel32<N>::value>; };
//  js ANY [D]   [] 78 
template<class T, class Enable = bool> struct asm_js {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','s', str...>, hold<T...>> {
    using value = typename asm_js<hold<T...>>::value;
};
template<uint8_t N>
struct asm_js<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x78>, typename rel8<N>::value>; };
//  js X86 [D]   [66] 88 

template<uint16_t N>
struct asm_js<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x88>, typename rel16<N>::value>; };
//  js ANY [D]   [] 88 

template<uint32_t N>
struct asm_js<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x88>, typename rel32<N>::value>; };
//  jz ANY [D]   [] 74 
template<class T, class Enable = bool> struct asm_jz {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','z', str...>, hold<T...>> {
    using value = typename asm_jz<hold<T...>>::value;
};
template<uint8_t N>
struct asm_jz<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x74>, typename rel8<N>::value>; };
//  jz X86 [D]   [66] 84 

template<uint16_t N>
struct asm_jz<hold<rel16<N>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, byte_seq<0x84>, typename rel16<N>::value>; };
//  jz ANY [D]   [] 84 

template<uint32_t N>
struct asm_jz<hold<rel32<N>>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x84>, typename rel32<N>::value>; };
//  lahf ANY [NONE]   [] 9F 
template<class T, class Enable = bool> struct asm_lahf {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','a','h','f', str...>, hold<T...>> {
    using value = typename asm_lahf<hold<T...>>::value;
};
template <>
struct asm_lahf<hold<>, bool> { using value = expseq_v<byte_seq<0x9F>>; };
//  lar ANY [RM] r  [66] 02 
template<class T, class Enable = bool> struct asm_lar {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','a','r', str...>, hold<T...>> {
    using value = typename asm_lar<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_lar<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x02>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lar<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x02>, mrm_v<hold<T...>, Y...>>;
};

//  lar ANY [RM] r  [] 02 

template<typename ...T, typename ...Y>
struct asm_lar<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x02>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lar<hold<zip<reg32>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x02>, mrm_v<hold<T...>, Y...>>;
};

//  lcall X86 [II]   [66] 9A 
template<class T, class Enable = bool> struct asm_lcall {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','c','a','l','l', str...>, hold<T...>> {
    using value = typename asm_lcall<hold<T...>>::value;
};
template <uint16_t T, uint16_t Y> 
struct asm_lcall<hold<disp16<T>, disp16<Y>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x9A>, typename disp16<T>::value, typename disp16<Y>::value>;
};
//  lcall X86 [II]   [] 9A 

template <uint16_t T, uint32_t Y> 
struct asm_lcall<hold<disp16<T>, disp32<Y>>, bool> {
  using value = expseq_v<byte_seq<0x9A>, typename disp16<T>::value, typename disp32<Y>::value>;
};
//  lcall ANY [M] 3  [66] FF 

template<typename ...T>
struct asm_lcall<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_lcall<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<3>>, T...>>;
};

//  lcall ANY [M] 3  [] FF 

template<typename ...T>
struct asm_lcall<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_lcall<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<3>>, T...>>;
};

//  lcall X64 [M] 3  [] FF 

template<typename ...T>
struct asm_lcall<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_lcall<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<3>>, T...>>;
};

//  lddqu ANY [RM] r  [F2] F0 
template<class T, class Enable = bool> struct asm_lddqu {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','d','d','q','u', str...>, hold<T...>> {
    using value = typename asm_lddqu<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_lddqu<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lddqu<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF0>, mrm_v<hold<T...>, Y...>>;
};

//  ldmxcsr ANY [M] 2  [] AE 
template<class T, class Enable = bool> struct asm_ldmxcsr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','d','m','x','c','s','r', str...>, hold<T...>> {
    using value = typename asm_ldmxcsr<hold<T...>>::value;
};
template<typename ...T>
struct asm_ldmxcsr<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_ldmxcsr<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, mrm_v<hold<reg<2>>, T...>>;
};

//  lds X86 [RM] r  [66] C5 
template<class T, class Enable = bool> struct asm_lds {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','d','s', str...>, hold<T...>> {
    using value = typename asm_lds<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_lds<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC5>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lds<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC5>, mrm_v<hold<T...>, Y...>>;
};

//  lds X86 [RM] r  [] C5 

template<typename ...T, typename ...Y>
struct asm_lds<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC5>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lds<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC5>, mrm_v<hold<T...>, Y...>>;
};

//  ldtilecfg X64 [M] 0  [] 49 
template<class T, class Enable = bool> struct asm_ldtilecfg {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','d','t','i','l','e','c','f','g', str...>, hold<T...>> {
    using value = typename asm_ldtilecfg<hold<T...>>::value;
};
template<typename ...T>
struct asm_ldtilecfg<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<0>>>>, disp8<is_ext_v<hold<T...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x49>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_ldtilecfg<hold<ptr<reg512, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<reg<0>>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x49>, mrm_v<hold<reg<0>>, T...>>;
};

//  lea ANY [RM] r  [] 8D 
template<class T, class Enable = bool> struct asm_lea {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','e','a', str...>, hold<T...>> {
    using value = typename asm_lea<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_lea<hold<zip<reg16>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x67>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lea<hold<zip<reg16>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<byte_seq<0x67>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8D>, mrm_v<hold<T...>, Y...>>;
};

//  lea ANY [RM] r  [] 8D 

template<typename ...T, typename ...Y>
struct asm_lea<hold<zip<reg32>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lea<hold<zip<reg32>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8D>, mrm_v<hold<T...>, Y...>>;
};

//  lea X64 [RM] r  [] 8D 

template<typename ...T, typename ...Y>
struct asm_lea<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lea<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8D>, mrm_v<hold<T...>, Y...>>;
};

//  leave ANY [NONE]   [] C9 
template<class T, class Enable = bool> struct asm_leave {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','e','a','v','e', str...>, hold<T...>> {
    using value = typename asm_leave<hold<T...>>::value;
};
template <> struct asm_leave<hold<>, bool> { using value = expseq_v<byte_seq<0xC9>>; };
//  les X86 [RM] r  [66] C4 
template<class T, class Enable = bool> struct asm_les {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','e','s', str...>, hold<T...>> {
    using value = typename asm_les<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_les<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC4>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_les<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC4>, mrm_v<hold<T...>, Y...>>;
};

//  les X86 [RM] r  [] C4 

template<typename ...T, typename ...Y>
struct asm_les<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC4>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_les<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC4>, mrm_v<hold<T...>, Y...>>;
};

//  lfence ANY [NONE] 5 0 [] E8 
template<class T, class Enable = bool> struct asm_lfence {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','f','e','n','c','e', str...>, hold<T...>> {
    using value = typename asm_lfence<hold<T...>>::value;
};
template <> struct asm_lfence<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0xE8>>; };
//  lfs ANY [RM] r  [66] B4 
template<class T, class Enable = bool> struct asm_lfs {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','f','s', str...>, hold<T...>> {
    using value = typename asm_lfs<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_lfs<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB4>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lfs<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB4>, mrm_v<hold<T...>, Y...>>;
};

//  lfs ANY [RM] r  [] B4 

template<typename ...T, typename ...Y>
struct asm_lfs<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB4>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lfs<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB4>, mrm_v<hold<T...>, Y...>>;
};

//  lfs X64 [RM] r  [] B4 

template<typename ...T, typename ...Y>
struct asm_lfs<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB4>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lfs<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB4>, mrm_v<hold<T...>, Y...>>;
};

//  lgdt ANY [M] 2  [] 01 
template<class T, class Enable = bool> struct asm_lgdt {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','g','d','t', str...>, hold<T...>> {
    using value = typename asm_lgdt<hold<T...>>::value;
};
template<typename ...T>
struct asm_lgdt<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, mrm_v<hold<reg<2>>, T...>>;
};

//  lgs ANY [RM] r  [66] B5 
template<class T, class Enable = bool> struct asm_lgs {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','g','s', str...>, hold<T...>> {
    using value = typename asm_lgs<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_lgs<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB5>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lgs<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB5>, mrm_v<hold<T...>, Y...>>;
};

//  lgs ANY [RM] r  [] B5 

template<typename ...T, typename ...Y>
struct asm_lgs<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB5>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lgs<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB5>, mrm_v<hold<T...>, Y...>>;
};

//  lgs X64 [RM] r  [] B5 

template<typename ...T, typename ...Y>
struct asm_lgs<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB5>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lgs<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB5>, mrm_v<hold<T...>, Y...>>;
};

//  lidt ANY [M] 3  [] 01 
template<class T, class Enable = bool> struct asm_lidt {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','i','d','t', str...>, hold<T...>> {
    using value = typename asm_lidt<hold<T...>>::value;
};
template<typename ...T>
struct asm_lidt<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, mrm_v<hold<reg<3>>, T...>>;
};

//  ljmp X86 [II]   [66] EA 
template<class T, class Enable = bool> struct asm_ljmp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','j','m','p', str...>, hold<T...>> {
    using value = typename asm_ljmp<hold<T...>>::value;
};
template <uint16_t T, uint16_t Y> 
struct asm_ljmp<hold<disp16<T>, disp16<Y>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0xEA>, typename disp16<T>::value, typename disp16<Y>::value>;
};
//  ljmp X86 [II]   [] EA 

template <uint16_t T, uint32_t Y> 
struct asm_ljmp<hold<disp16<T>, disp32<Y>>, bool> {
  using value = expseq_v<byte_seq<0xEA>, typename disp16<T>::value, typename disp32<Y>::value>;
};
//  ljmp ANY [M] 5  [66] FF 

template<typename ...T>
struct asm_ljmp<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_ljmp<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<5>>, T...>>;
};

//  ljmp ANY [M] 5  [] FF 

template<typename ...T>
struct asm_ljmp<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_ljmp<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<5>>, T...>>;
};

//  ljmp X64 [M] 5  [] FF 

template<typename ...T>
struct asm_ljmp<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_ljmp<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<5>>, T...>>;
};

//  lldt ANY [M] 2  [] 00 
template<class T, class Enable = bool> struct asm_lldt {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','l','d','t', str...>, hold<T...>> {
    using value = typename asm_lldt<hold<T...>>::value;
};
template<typename ...T>
struct asm_lldt<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_lldt<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x00>, mrm_v<hold<reg<2>>, T...>>;
};

//  llwpcb ANY [M] 0  [] 12 
template<class T, class Enable = bool> struct asm_llwpcb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','l','w','p','c','b', str...>, hold<T...>> {
    using value = typename asm_llwpcb<hold<T...>>::value;
};
template<typename ...T>
struct asm_llwpcb<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<reg<0>>>>, disp8<is_ext_v<hold<T...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

//  llwpcb X64 [M] 0  [] 12 

template<typename ...T>
struct asm_llwpcb<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<reg<0>>>>, disp8<is_ext_v<hold<T...>>>, disp8<0>, disp8<9>, disp8<1>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

//  lmsw ANY [M] 6  [] 01 
template<class T, class Enable = bool> struct asm_lmsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','m','s','w', str...>, hold<T...>> {
    using value = typename asm_lmsw<hold<T...>>::value;
};
template<typename ...T>
struct asm_lmsw<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x01>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

template<typename ...T>
struct asm_lmsw<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, mrm_v<hold<reg<6>>, T...>>;
};

//  lodsb ANY [NONE]   [] AC 
template<class T, class Enable = bool> struct asm_lodsb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','o','d','s','b', str...>, hold<T...>> {
    using value = typename asm_lodsb<hold<T...>>::value;
};
template <>
struct asm_lodsb<hold<>, bool> { using value = expseq_v<byte_seq<0xAC>>; };
//  lodsd ANY [NONE]   [] AD 
template<class T, class Enable = bool> struct asm_lodsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','o','d','s','d', str...>, hold<T...>> {
    using value = typename asm_lodsd<hold<T...>>::value;
};
template <>
struct asm_lodsd<hold<>, bool> { using value = expseq_v<byte_seq<0xAD>>; };
//  lodsq X64 [NONE]   [] AD 
template<class T, class Enable = bool> struct asm_lodsq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','o','d','s','q', str...>, hold<T...>> {
    using value = typename asm_lodsq<hold<T...>>::value;
};
template <>
struct asm_lodsq<hold<>, bool> { using value = expseq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0xAD>>; };
//  lodsw ANY [NONE]   [66] AD 
template<class T, class Enable = bool> struct asm_lodsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','o','d','s','w', str...>, hold<T...>> {
    using value = typename asm_lodsw<hold<T...>>::value;
};
template <>
struct asm_lodsw<hold<>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0xAD>>; };
//  loop X86 [D]   [] E2 
template<class T, class Enable = bool> struct asm_loop {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','o','o','p', str...>, hold<T...>> {
    using value = typename asm_loop<hold<T...>>::value;
};
template<uint8_t N>
struct asm_loop<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x67>, byte_seq<0xE2>, typename rel8<N>::value>; };
//  loope X86 [D]   [] E1 
template<class T, class Enable = bool> struct asm_loope {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','o','o','p','e', str...>, hold<T...>> {
    using value = typename asm_loope<hold<T...>>::value;
};
template<uint8_t N>
struct asm_loope<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x67>, byte_seq<0xE1>, typename rel8<N>::value>; };
//  loopne X86 [D]   [] E0 
template<class T, class Enable = bool> struct asm_loopne {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','o','o','p','n','e', str...>, hold<T...>> {
    using value = typename asm_loopne<hold<T...>>::value;
};
template<uint8_t N>
struct asm_loopne<hold<rel8<N>>, bool> { using value = expseq_v<byte_seq<0x67>, byte_seq<0xE0>, typename rel8<N>::value>; };
//  lsl ANY [RM] r  [66] 03 
template<class T, class Enable = bool> struct asm_lsl {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','s','l', str...>, hold<T...>> {
    using value = typename asm_lsl<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_lsl<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x03>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lsl<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x03>, mrm_v<hold<T...>, Y...>>;
};

//  lsl ANY [RM] r  [] 03 

template<typename ...T, typename ...Y>
struct asm_lsl<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x03>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lsl<hold<zip<reg32>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x03>, mrm_v<hold<T...>, Y...>>;
};

//  lsl X64 [RM] r  [] 03 

template<typename ...T, typename ...Y>
struct asm_lsl<hold<zip<reg64>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x03>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lsl<hold<zip<reg64>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x03>, mrm_v<hold<T...>, Y...>>;
};

//  lss ANY [RM] r  [66] B2 
template<class T, class Enable = bool> struct asm_lss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','s','s', str...>, hold<T...>> {
    using value = typename asm_lss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_lss<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB2>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lss<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB2>, mrm_v<hold<T...>, Y...>>;
};

//  lss ANY [RM] r  [] B2 

template<typename ...T, typename ...Y>
struct asm_lss<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB2>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lss<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB2>, mrm_v<hold<T...>, Y...>>;
};

//  lss X64 [RM] r  [] B2 

template<typename ...T, typename ...Y>
struct asm_lss<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB2>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lss<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB2>, mrm_v<hold<T...>, Y...>>;
};

//  ltr ANY [M] 3  [] 00 
template<class T, class Enable = bool> struct asm_ltr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','t','r', str...>, hold<T...>> {
    using value = typename asm_ltr<hold<T...>>::value;
};
template<typename ...T>
struct asm_ltr<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_ltr<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x00>, mrm_v<hold<reg<3>>, T...>>;
};

//  lwpins ANY [VMI] 0  [] 12 
template<class T, class Enable = bool> struct asm_lwpins {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','w','p','i','n','s', str...>, hold<T...>> {
    using value = typename asm_lwpins<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_lwpins<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, Z>, typename u32_8<Z>::value> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<reg<0>>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<0>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<reg<0>>>::value, typename u32_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_lwpins<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>, Z>, typename u32_8<Z>::value> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<reg<0>>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<0>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, mrm_v<hold<reg<0>>, Y...>, typename u32_8<Z>::value>;
};

//  lwpins X64 [VMI] 0  [] 12 

template<typename ...T, typename ...Y, class Z>
struct asm_lwpins<hold<zip<reg64>::with<T...>, zip<reg32>::with<Y...>, Z>, typename u32_8<Z>::value> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<reg<0>>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<0>, disp8<1>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<reg<0>>>::value, typename u32_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_lwpins<hold<zip<reg64>::with<T...>, ptr<reg32, Y...>, Z>, typename u32_8<Z>::value> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<reg<0>>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<0>, disp8<1>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, mrm_v<hold<reg<0>>, Y...>, typename u32_8<Z>::value>;
};

//  lwpval ANY [VMI] 1  [] 12 
template<class T, class Enable = bool> struct asm_lwpval {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','w','p','v','a','l', str...>, hold<T...>> {
    using value = typename asm_lwpval<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_lwpval<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, Z>, typename u32_8<Z>::value> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<reg<1>>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<0>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<reg<1>>>::value, typename u32_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_lwpval<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>, Z>, typename u32_8<Z>::value> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<reg<1>>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<0>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, mrm_v<hold<reg<1>>, Y...>, typename u32_8<Z>::value>;
};

//  lwpval X64 [VMI] 1  [] 12 

template<typename ...T, typename ...Y, class Z>
struct asm_lwpval<hold<zip<reg64>::with<T...>, zip<reg32>::with<Y...>, Z>, typename u32_8<Z>::value> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<reg<1>>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<0>, disp8<1>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<reg<1>>>::value, typename u32_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_lwpval<hold<zip<reg64>::with<T...>, ptr<reg32, Y...>, Z>, typename u32_8<Z>::value> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<reg<1>>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<0>, disp8<1>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, mrm_v<hold<reg<1>>, Y...>, typename u32_8<Z>::value>;
};

//  lzcnt ANY [RM] r  [66F3] BD 
template<class T, class Enable = bool> struct asm_lzcnt {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','z','c','n','t', str...>, hold<T...>> {
    using value = typename asm_lzcnt<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_lzcnt<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66, 0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBD>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lzcnt<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66, 0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBD>, mrm_v<hold<T...>, Y...>>;
};

//  lzcnt ANY [RM] r  [F3] BD 

template<typename ...T, typename ...Y>
struct asm_lzcnt<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBD>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lzcnt<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBD>, mrm_v<hold<T...>, Y...>>;
};

//  lzcnt X64 [RM] r  [F3] BD 

template<typename ...T, typename ...Y>
struct asm_lzcnt<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBD>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_lzcnt<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBD>, mrm_v<hold<T...>, Y...>>;
};

//  maskmovdqu ANY [RM] r  [66] F7 
template<class T, class Enable = bool> struct asm_maskmovdqu {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','a','s','k','m','o','v','d','q','u', str...>, hold<T...>> {
    using value = typename asm_maskmovdqu<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_maskmovdqu<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  maskmovq ANY [RM] r  [] F7 
template<class T, class Enable = bool> struct asm_maskmovq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','a','s','k','m','o','v','q', str...>, hold<T...>> {
    using value = typename asm_maskmovq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_maskmovq<hold<zip<mmx>::with<T...>, zip<mmx>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  maxpd ANY [RM] r  [66] 5F 
template<class T, class Enable = bool> struct asm_maxpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','a','x','p','d', str...>, hold<T...>> {
    using value = typename asm_maxpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_maxpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_maxpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5F>, mrm_v<hold<T...>, Y...>>;
};

//  maxps ANY [RM] r  [] 5F 
template<class T, class Enable = bool> struct asm_maxps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','a','x','p','s', str...>, hold<T...>> {
    using value = typename asm_maxps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_maxps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_maxps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5F>, mrm_v<hold<T...>, Y...>>;
};

//  maxsd ANY [RM] r  [F2] 5F 
template<class T, class Enable = bool> struct asm_maxsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','a','x','s','d', str...>, hold<T...>> {
    using value = typename asm_maxsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_maxsd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_maxsd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5F>, mrm_v<hold<T...>, Y...>>;
};

//  maxss ANY [RM] r  [F3] 5F 
template<class T, class Enable = bool> struct asm_maxss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','a','x','s','s', str...>, hold<T...>> {
    using value = typename asm_maxss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_maxss<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_maxss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5F>, mrm_v<hold<T...>, Y...>>;
};

//  mcommit ANY [NONE]   [F3] FA 
template<class T, class Enable = bool> struct asm_mcommit {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','c','o','m','m','i','t', str...>, hold<T...>> {
    using value = typename asm_mcommit<hold<T...>>::value;
};
template <> struct asm_mcommit<hold<>, bool> { using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x01>, byte_seq<0xFA>>; };
//  mfence ANY [NONE] 6 0 [] F0 
template<class T, class Enable = bool> struct asm_mfence {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','f','e','n','c','e', str...>, hold<T...>> {
    using value = typename asm_mfence<hold<T...>>::value;
};
template <> struct asm_mfence<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0xF0>>; };
//  minpd ANY [RM] r  [66] 5D 
template<class T, class Enable = bool> struct asm_minpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','i','n','p','d', str...>, hold<T...>> {
    using value = typename asm_minpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_minpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_minpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5D>, mrm_v<hold<T...>, Y...>>;
};

//  minps ANY [RM] r  [] 5D 
template<class T, class Enable = bool> struct asm_minps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','i','n','p','s', str...>, hold<T...>> {
    using value = typename asm_minps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_minps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_minps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5D>, mrm_v<hold<T...>, Y...>>;
};

//  minsd ANY [RM] r  [F2] 5D 
template<class T, class Enable = bool> struct asm_minsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','i','n','s','d', str...>, hold<T...>> {
    using value = typename asm_minsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_minsd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_minsd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5D>, mrm_v<hold<T...>, Y...>>;
};

//  minss ANY [RM] r  [F3] 5D 
template<class T, class Enable = bool> struct asm_minss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','i','n','s','s', str...>, hold<T...>> {
    using value = typename asm_minss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_minss<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_minss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5D>, mrm_v<hold<T...>, Y...>>;
};

//  monitor ANY [NONE]   [] C8 
template<class T, class Enable = bool> struct asm_monitor {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','n','i','t','o','r', str...>, hold<T...>> {
    using value = typename asm_monitor<hold<T...>>::value;
};
template <>
struct asm_monitor<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xC8>>; };
//  monitorx ANY [NONE]   [] FA 
template<class T, class Enable = bool> struct asm_monitorx {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','n','i','t','o','r','x', str...>, hold<T...>> {
    using value = typename asm_monitorx<hold<T...>>::value;
};
template <>
struct asm_monitorx<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xFA>>; };
//  mov ANY [MR] r  [] 88 
template<class T, class Enable = bool> struct asm_mov {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v', str...>, hold<T...>> {
    using value = typename asm_mov<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_mov<hold<ptr<reg8, T...>, zip<reg8>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x88>, mrm_v<hold<Y...>, T...>>;
};

//  mov ANY [MR] r  [66] 89 

template<typename ...T, typename ...Y>
struct asm_mov<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x89>, mrm_v<hold<Y...>, T...>>;
};

//  mov ANY [MR] r  [] 89 

template<typename ...T, typename ...Y>
struct asm_mov<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x89>, mrm_v<hold<Y...>, T...>>;
};

//  mov X64 [MR] r  [] 89 

template<typename ...T, typename ...Y>
struct asm_mov<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x89>, mrm_v<hold<Y...>, T...>>;
};

//  mov ANY [MI] 0  [] C6 

template<typename ...T, class Y>
struct asm_mov<hold<ptr<reg8, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC6>, mrm_v<hold<reg<0>>, T...>, typename u8_8<Y>::value>;
};

//  mov ANY [MI] 0  [66] C7 

template<typename ...T, class Y>
struct asm_mov<hold<ptr<reg16, T...>, Y>, typename u16_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, mrm_v<hold<reg<0>>, T...>, typename u16_8<Y>::value>;
};

//  mov ANY [MI] 0  [] C7 

template<typename ...T, class Y>
struct asm_mov<hold<ptr<reg32, T...>, Y>, typename u32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, mrm_v<hold<reg<0>>, T...>, typename u32_8<Y>::value>;
};

//  mov X64 [MI] 0  [] C7 

template<typename ...T, class Y>
struct asm_mov<hold<ptr<reg64, T...>, Y>, typename i32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, mrm_v<hold<reg<0>>, T...>, typename i32_8<Y>::value>;
};

//  mov ANY [I]   [] B0 

template <typename ...T, class Y> 
struct asm_mov<hold<zip<reg8>::with<T...>, Y>, typename u8_8<Y>::type>{
  using value = expseq_v<byte_seq<0xB0>, typename u8_8<Y>::value>;
};
//  mov ANY [I]   [66] B8 

template <typename ...T, class Y> 
struct asm_mov<hold<zip<reg16>::with<T...>, Y>, typename u16_8<Y>::type>{
  using value = expseq_v<byte_seq<0x66>, byte_seq<0xB8>, typename u16_8<Y>::value>;
};
//  mov ANY [I]   [] B8 

template <typename ...T, class Y> 
struct asm_mov<hold<zip<reg32>::with<T...>, Y>, typename u32_8<Y>::type>{
  using value = expseq_v<byte_seq<0xB8>, typename u32_8<Y>::value>;
};
//  mov X64 [I]   [] B8 

template <typename ...T, class Y> 
struct asm_mov<hold<zip<reg64>::with<T...>, Y>, typename u64_8<Y>::type>{
  using value = expseq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0xB8>, typename u64_8<Y>::value>;
};
//  mov ANY [RM] r  [] 8A 

template<typename ...T, typename ...Y>
struct asm_mov<hold<zip<reg8>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_mov<hold<zip<reg8>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8A>, mrm_v<hold<T...>, Y...>>;
};

//  mov ANY [RM] r  [66] 8B 

template<typename ...T, typename ...Y>
struct asm_mov<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_mov<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8B>, mrm_v<hold<T...>, Y...>>;
};

//  mov ANY [RM] r  [] 8B 

template<typename ...T, typename ...Y>
struct asm_mov<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_mov<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8B>, mrm_v<hold<T...>, Y...>>;
};

//  mov X64 [RM] r  [] 8B 

template<typename ...T, typename ...Y>
struct asm_mov<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_mov<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8B>, mrm_v<hold<T...>, Y...>>;
};

//  mov ANY [RM] r  [66] 8E 

template<typename ...T, typename ...Y>
struct asm_mov<hold<zip<sreg>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_mov<hold<zip<sreg>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8E>, mrm_v<hold<T...>, Y...>>;
};

//  mov ANY [RM] r  [] 8E 

template<typename ...T, typename ...Y>
struct asm_mov<hold<zip<sreg>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};


//  mov X64 [RM] r  [] 8E 

template<typename ...T, typename ...Y>
struct asm_mov<hold<zip<sreg>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  movapd ANY [RM] r  [66] 28 
template<class T, class Enable = bool> struct asm_movapd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','a','p','d', str...>, hold<T...>> {
    using value = typename asm_movapd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movapd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x28>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movapd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x28>, mrm_v<hold<T...>, Y...>>;
};

//  movapd ANY [MR] r  [66] 29 

template<typename ...T, typename ...Y>
struct asm_movapd<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x29>, mrm_v<hold<Y...>, T...>>;
};

//  movaps ANY [RM] r  [] 28 
template<class T, class Enable = bool> struct asm_movaps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','a','p','s', str...>, hold<T...>> {
    using value = typename asm_movaps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movaps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x28>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movaps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x28>, mrm_v<hold<T...>, Y...>>;
};

//  movaps ANY [MR] r  [] 29 

template<typename ...T, typename ...Y>
struct asm_movaps<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x29>, mrm_v<hold<Y...>, T...>>;
};

//  movbe ANY [RM] r  [66] F0 
template<class T, class Enable = bool> struct asm_movbe {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','b','e', str...>, hold<T...>> {
    using value = typename asm_movbe<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movbe<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movbe<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF0>, mrm_v<hold<T...>, Y...>>;
};

//  movbe ANY [RM] r  [] F0 

template<typename ...T, typename ...Y>
struct asm_movbe<hold<zip<reg32>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movbe<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF0>, mrm_v<hold<T...>, Y...>>;
};

//  movbe X64 [RM] r  [] F0 

template<typename ...T, typename ...Y>
struct asm_movbe<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movbe<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF0>, mrm_v<hold<T...>, Y...>>;
};

//  movbe ANY [MR] r  [66] F1 

template<typename ...T, typename ...Y>
struct asm_movbe<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF1>, mrm_v<hold<Y...>, T...>>;
};

//  movbe ANY [MR] r  [] F1 

template<typename ...T, typename ...Y>
struct asm_movbe<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF1>, mrm_v<hold<Y...>, T...>>;
};

//  movbe X64 [MR] r  [] F1 

template<typename ...T, typename ...Y>
struct asm_movbe<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF1>, mrm_v<hold<Y...>, T...>>;
};

//  movd ANY [RM] r  [] 6E 
template<class T, class Enable = bool> struct asm_movd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','d', str...>, hold<T...>> {
    using value = typename asm_movd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movd<hold<zip<mmx>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movd<hold<zip<mmx>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6E>, mrm_v<hold<T...>, Y...>>;
};

//  movd ANY [MR] r  [] 7E 

template<typename ...T, typename ...Y>
struct asm_movd<hold<ptr<reg32, T...>, zip<mmx>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x7E>, mrm_v<hold<Y...>, T...>>;
};

//  movd ANY [MR] r  [66] 7E 

template<typename ...T, typename ...Y>
struct asm_movd<hold<ptr<reg32, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x7E>, mrm_v<hold<Y...>, T...>>;
};

//  movd ANY [RM] r  [66] 6E 

template<typename ...T, typename ...Y>
struct asm_movd<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movd<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6E>, mrm_v<hold<T...>, Y...>>;
};

//  movddup ANY [RM] r  [F2] 12 
template<class T, class Enable = bool> struct asm_movddup {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','d','d','u','p', str...>, hold<T...>> {
    using value = typename asm_movddup<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movddup<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movddup<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x12>, mrm_v<hold<T...>, Y...>>;
};

//  movdir64b ANY [RM] r  [66] F8 
template<class T, class Enable = bool> struct asm_movdir64b {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','d','i','r','6','4','b', str...>, hold<T...>> {
    using value = typename asm_movdir64b<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movdir64b<hold<zip<reg32>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF8>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movdir64b<hold<zip<reg32>::with<T...>, ptr<reg512, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF8>, mrm_v<hold<T...>, Y...>>;
};

//  movdir64b X64 [RM] r  [66] F8 

template<typename ...T, typename ...Y>
struct asm_movdir64b<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF8>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movdir64b<hold<zip<reg64>::with<T...>, ptr<reg512, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF8>, mrm_v<hold<T...>, Y...>>;
};

//  movdiri ANY [MR] r  [] F9 
template<class T, class Enable = bool> struct asm_movdiri {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','d','i','r','i', str...>, hold<T...>> {
    using value = typename asm_movdiri<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movdiri<hold<zip<reg64>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF9>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movdiri<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF9>, mrm_v<hold<Y...>, T...>>;
};

//  movdiri X64 [MR] r  [] F9 

template<typename ...T, typename ...Y>
struct asm_movdiri<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF9>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movdiri<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF9>, mrm_v<hold<Y...>, T...>>;
};

//  movdq2q ANY [RM] r  [F2] D6 
template<class T, class Enable = bool> struct asm_movdq2q {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','d','q','2','q', str...>, hold<T...>> {
    using value = typename asm_movdq2q<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movdq2q<hold<zip<mmx>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  movdqa ANY [RM] r  [66] 6F 
template<class T, class Enable = bool> struct asm_movdqa {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','d','q','a', str...>, hold<T...>> {
    using value = typename asm_movdqa<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movdqa<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movdqa<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6F>, mrm_v<hold<T...>, Y...>>;
};

//  movdqa ANY [MR] r  [66] 7F 

template<typename ...T, typename ...Y>
struct asm_movdqa<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x7F>, mrm_v<hold<Y...>, T...>>;
};

//  movdqu ANY [RM] r  [F3] 6F 
template<class T, class Enable = bool> struct asm_movdqu {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','d','q','u', str...>, hold<T...>> {
    using value = typename asm_movdqu<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movdqu<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movdqu<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6F>, mrm_v<hold<T...>, Y...>>;
};

//  movdqu ANY [MR] r  [F3] 7F 

template<typename ...T, typename ...Y>
struct asm_movdqu<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x7F>, mrm_v<hold<Y...>, T...>>;
};

//  movhlps ANY [RM] r  [] 12 
template<class T, class Enable = bool> struct asm_movhlps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','h','l','p','s', str...>, hold<T...>> {
    using value = typename asm_movhlps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movhlps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  movhpd ANY [MR] r  [66] 17 
template<class T, class Enable = bool> struct asm_movhpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','h','p','d', str...>, hold<T...>> {
    using value = typename asm_movhpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movhpd<hold<ptr<reg64, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x17>, mrm_v<hold<Y...>, T...>>;
};

//  movhpd ANY [RM] r  [66] 16 

template<typename ...T, typename ...Y>
struct asm_movhpd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x16>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movhpd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x16>, mrm_v<hold<T...>, Y...>>;
};

//  movhps ANY [MR] r  [] 17 
template<class T, class Enable = bool> struct asm_movhps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','h','p','s', str...>, hold<T...>> {
    using value = typename asm_movhps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movhps<hold<ptr<reg64, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x17>, mrm_v<hold<Y...>, T...>>;
};

//  movhps ANY [RM] r  [] 16 

template<typename ...T, typename ...Y>
struct asm_movhps<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x16>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movhps<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x16>, mrm_v<hold<T...>, Y...>>;
};

//  movlhps ANY [RM] r  [] 16 
template<class T, class Enable = bool> struct asm_movlhps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','l','h','p','s', str...>, hold<T...>> {
    using value = typename asm_movlhps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movlhps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x16>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  movlpd ANY [MR] r  [66] 13 
template<class T, class Enable = bool> struct asm_movlpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','l','p','d', str...>, hold<T...>> {
    using value = typename asm_movlpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movlpd<hold<ptr<reg64, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x13>, mrm_v<hold<Y...>, T...>>;
};

//  movlpd ANY [RM] r  [66] 12 

template<typename ...T, typename ...Y>
struct asm_movlpd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movlpd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x12>, mrm_v<hold<T...>, Y...>>;
};

//  movlps ANY [MR] r  [] 13 
template<class T, class Enable = bool> struct asm_movlps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','l','p','s', str...>, hold<T...>> {
    using value = typename asm_movlps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movlps<hold<ptr<reg64, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x13>, mrm_v<hold<Y...>, T...>>;
};

//  movlps ANY [RM] r  [] 12 

template<typename ...T, typename ...Y>
struct asm_movlps<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movlps<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x12>, mrm_v<hold<T...>, Y...>>;
};

//  movmskpd ANY [RM] r  [66] 50 
template<class T, class Enable = bool> struct asm_movmskpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','m','s','k','p','d', str...>, hold<T...>> {
    using value = typename asm_movmskpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movmskpd<hold<zip<reg32>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x50>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  movmskps ANY [RM] r  [] 50 
template<class T, class Enable = bool> struct asm_movmskps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','m','s','k','p','s', str...>, hold<T...>> {
    using value = typename asm_movmskps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movmskps<hold<zip<reg32>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x50>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  movntdq ANY [MR] r  [66] E7 
template<class T, class Enable = bool> struct asm_movntdq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','n','t','d','q', str...>, hold<T...>> {
    using value = typename asm_movntdq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movntdq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xE7>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movntdq<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xE7>, mrm_v<hold<Y...>, T...>>;
};

//  movntdqa ANY [RM] r  [66] 2A 
template<class T, class Enable = bool> struct asm_movntdqa {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','n','t','d','q','a', str...>, hold<T...>> {
    using value = typename asm_movntdqa<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movntdqa<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movntdqa<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2A>, mrm_v<hold<T...>, Y...>>;
};

//  movnti ANY [MR] r  [] C3 
template<class T, class Enable = bool> struct asm_movnti {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','n','t','i', str...>, hold<T...>> {
    using value = typename asm_movnti<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movnti<hold<zip<reg64>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC3>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movnti<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC3>, mrm_v<hold<Y...>, T...>>;
};

//  movnti X64 [MR] r  [] C3 

template<typename ...T, typename ...Y>
struct asm_movnti<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC3>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movnti<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC3>, mrm_v<hold<Y...>, T...>>;
};

//  movntpd ANY [MR] r  [66] 2B 
template<class T, class Enable = bool> struct asm_movntpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','n','t','p','d', str...>, hold<T...>> {
    using value = typename asm_movntpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movntpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x2B>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movntpd<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x2B>, mrm_v<hold<Y...>, T...>>;
};

//  movntps ANY [MR] r  [] 2B 
template<class T, class Enable = bool> struct asm_movntps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','n','t','p','s', str...>, hold<T...>> {
    using value = typename asm_movntps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movntps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x2B>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movntps<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x2B>, mrm_v<hold<Y...>, T...>>;
};

//  movntq ANY [MR] r  [] E7 
template<class T, class Enable = bool> struct asm_movntq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','n','t','q', str...>, hold<T...>> {
    using value = typename asm_movntq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movntq<hold<zip<reg64>::with<T...>, zip<mmx>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xE7>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movntq<hold<ptr<reg64, T...>, zip<mmx>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xE7>, mrm_v<hold<Y...>, T...>>;
};

//  movntsd ANY [RM] r  [F2] 2B 
template<class T, class Enable = bool> struct asm_movntsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','n','t','s','d', str...>, hold<T...>> {
    using value = typename asm_movntsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movntsd<hold<zip<reg64>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  movntss ANY [RM] r  [F3] 2B 
template<class T, class Enable = bool> struct asm_movntss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','n','t','s','s', str...>, hold<T...>> {
    using value = typename asm_movntss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movntss<hold<zip<reg64>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  movq ANY [RM] r  [] 6F 
template<class T, class Enable = bool> struct asm_movq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','q', str...>, hold<T...>> {
    using value = typename asm_movq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movq<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movq<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6F>, mrm_v<hold<T...>, Y...>>;
};

//  movq X64 [RM] r  [] 6E 

//  movq ANY [MR] r  [] 7F 

template<typename ...T, typename ...Y>
struct asm_movq<hold<ptr<reg64, T...>, zip<mmx>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x7F>, mrm_v<hold<Y...>, T...>>;
};

//  movq X64 [MR] r  [] 7E 

//  movq X64 [MR] r  [66] 7E 

//  movq X64 [RM] r  [66] 6E 

//  movq ANY [RM] r  [F3] 7E 

template<typename ...T, typename ...Y>
struct asm_movq<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x7E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movq<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x7E>, mrm_v<hold<T...>, Y...>>;
};

//  movq ANY [MR] r  [66] D6 

template<typename ...T, typename ...Y>
struct asm_movq<hold<ptr<reg64, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD6>, mrm_v<hold<Y...>, T...>>;
};

//  movq2dq ANY [RM] r  [F3] D6 
template<class T, class Enable = bool> struct asm_movq2dq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','q','2','d','q', str...>, hold<T...>> {
    using value = typename asm_movq2dq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movq2dq<hold<zip<reg128>::with<T...>, zip<mmx>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  movsb ANY [NONE]   [] A4 
template<class T, class Enable = bool> struct asm_movsb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','s','b', str...>, hold<T...>> {
    using value = typename asm_movsb<hold<T...>>::value;
};
template <>
struct asm_movsb<hold<>, bool> { using value = expseq_v<byte_seq<0xA4>>; };
//  movsd ANY [NONE]   [] A5 
template<class T, class Enable = bool> struct asm_movsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','s','d', str...>, hold<T...>> {
    using value = typename asm_movsd<hold<T...>>::value;
};
template <>
struct asm_movsd<hold<>, bool> { using value = expseq_v<byte_seq<0xA5>>; };
//  movsd ANY [RM] r  [F2] 10 

template<typename ...T, typename ...Y>
struct asm_movsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  movsd ANY [RM] r  [F2] 10 

template<typename ...T, typename ...Y>
struct asm_movsd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movsd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x10>, mrm_v<hold<T...>, Y...>>;
};

//  movsd ANY [MR] r  [F2] 11 

template<typename ...T, typename ...Y>
struct asm_movsd<hold<ptr<reg64, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x11>, mrm_v<hold<Y...>, T...>>;
};

//  movshdup ANY [RM] r  [F3] 16 
template<class T, class Enable = bool> struct asm_movshdup {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','s','h','d','u','p', str...>, hold<T...>> {
    using value = typename asm_movshdup<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movshdup<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x16>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movshdup<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x16>, mrm_v<hold<T...>, Y...>>;
};

//  movsldup ANY [RM] r  [F3] 12 
template<class T, class Enable = bool> struct asm_movsldup {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','s','l','d','u','p', str...>, hold<T...>> {
    using value = typename asm_movsldup<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movsldup<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movsldup<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x12>, mrm_v<hold<T...>, Y...>>;
};

//  movsq X64 [NONE]   [] A5 
template<class T, class Enable = bool> struct asm_movsq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','s','q', str...>, hold<T...>> {
    using value = typename asm_movsq<hold<T...>>::value;
};
template <>
struct asm_movsq<hold<>, bool> { using value = expseq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0xA5>>; };
//  movss ANY [RM] r  [F3] 10 
template<class T, class Enable = bool> struct asm_movss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','s','s', str...>, hold<T...>> {
    using value = typename asm_movss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  movss ANY [RM] r  [F3] 10 

template<typename ...T, typename ...Y>
struct asm_movss<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x10>, mrm_v<hold<T...>, Y...>>;
};

//  movss ANY [MR] r  [F3] 11 

template<typename ...T, typename ...Y>
struct asm_movss<hold<ptr<reg32, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x11>, mrm_v<hold<Y...>, T...>>;
};

//  movsw ANY [NONE]   [66] A5 
template<class T, class Enable = bool> struct asm_movsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','s','w', str...>, hold<T...>> {
    using value = typename asm_movsw<hold<T...>>::value;
};
template <>
struct asm_movsw<hold<>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0xA5>>; };
//  movsx ANY [RM] r  [66] BE 
template<class T, class Enable = bool> struct asm_movsx {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','s','x', str...>, hold<T...>> {
    using value = typename asm_movsx<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movsx<hold<zip<reg16>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBE>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movsx<hold<zip<reg16>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBE>, mrm_v<hold<T...>, Y...>>;
};

//  movsx ANY [RM] r  [] BE 

template<typename ...T, typename ...Y>
struct asm_movsx<hold<zip<reg32>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBE>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movsx<hold<zip<reg32>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBE>, mrm_v<hold<T...>, Y...>>;
};

//  movsx X64 [RM] r  [] BE 

template<typename ...T, typename ...Y>
struct asm_movsx<hold<zip<reg64>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBE>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movsx<hold<zip<reg64>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBE>, mrm_v<hold<T...>, Y...>>;
};

//  movsx ANY [RM] r  [] BF 

template<typename ...T, typename ...Y>
struct asm_movsx<hold<zip<reg32>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBF>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movsx<hold<zip<reg32>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBF>, mrm_v<hold<T...>, Y...>>;
};

//  movsx X64 [RM] r  [] BF 

template<typename ...T, typename ...Y>
struct asm_movsx<hold<zip<reg64>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBF>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movsx<hold<zip<reg64>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBF>, mrm_v<hold<T...>, Y...>>;
};

//  movsxd X64 [RM] r  [66] 63 
template<class T, class Enable = bool> struct asm_movsxd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','s','x','d', str...>, hold<T...>> {
    using value = typename asm_movsxd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movsxd<hold<zip<reg16>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x63>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movsxd<hold<zip<reg16>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x63>, mrm_v<hold<T...>, Y...>>;
};

//  movsxd X64 [RM] r  [] 63 

template<typename ...T, typename ...Y>
struct asm_movsxd<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x63>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movsxd<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x63>, mrm_v<hold<T...>, Y...>>;
};

//  movsxd X64 [RM] r  [] 63 

template<typename ...T, typename ...Y>
struct asm_movsxd<hold<zip<reg64>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x63>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movsxd<hold<zip<reg64>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x63>, mrm_v<hold<T...>, Y...>>;
};

//  movupd ANY [RM] r  [66] 10 
template<class T, class Enable = bool> struct asm_movupd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','u','p','d', str...>, hold<T...>> {
    using value = typename asm_movupd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movupd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movupd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x10>, mrm_v<hold<T...>, Y...>>;
};

//  movupd ANY [MR] r  [66] 11 

template<typename ...T, typename ...Y>
struct asm_movupd<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x11>, mrm_v<hold<Y...>, T...>>;
};

//  movups ANY [RM] r  [] 10 
template<class T, class Enable = bool> struct asm_movups {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','u','p','s', str...>, hold<T...>> {
    using value = typename asm_movups<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movups<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movups<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x10>, mrm_v<hold<T...>, Y...>>;
};

//  movups ANY [MR] r  [] 11 

template<typename ...T, typename ...Y>
struct asm_movups<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x11>, mrm_v<hold<Y...>, T...>>;
};

//  movzx ANY [RM] r  [66] B6 
template<class T, class Enable = bool> struct asm_movzx {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','z','x', str...>, hold<T...>> {
    using value = typename asm_movzx<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_movzx<hold<zip<reg16>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movzx<hold<zip<reg16>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB6>, mrm_v<hold<T...>, Y...>>;
};

//  movzx ANY [RM] r  [] B6 

template<typename ...T, typename ...Y>
struct asm_movzx<hold<zip<reg32>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movzx<hold<zip<reg32>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB6>, mrm_v<hold<T...>, Y...>>;
};

//  movzx X64 [RM] r  [] B6 

template<typename ...T, typename ...Y>
struct asm_movzx<hold<zip<reg64>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movzx<hold<zip<reg64>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB6>, mrm_v<hold<T...>, Y...>>;
};

//  movzx ANY [RM] r  [] B7 

template<typename ...T, typename ...Y>
struct asm_movzx<hold<zip<reg32>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB7>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movzx<hold<zip<reg32>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB7>, mrm_v<hold<T...>, Y...>>;
};

//  movzx X64 [RM] r  [] B7 

template<typename ...T, typename ...Y>
struct asm_movzx<hold<zip<reg64>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB7>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_movzx<hold<zip<reg64>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB7>, mrm_v<hold<T...>, Y...>>;
};

//  mpsadbw ANY [RMI] r  [66] 42 
template<class T, class Enable = bool> struct asm_mpsadbw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','p','s','a','d','b','w', str...>, hold<T...>> {
    using value = typename asm_mpsadbw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_mpsadbw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_mpsadbw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  mul ANY [M] 4  [] F6 
template<class T, class Enable = bool> struct asm_mul {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','u','l', str...>, hold<T...>> {
    using value = typename asm_mul<hold<T...>>::value;
};
template<typename ...Y>
struct asm_mul<hold<zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<reg<4>>>::value>;
};

template<typename ...Y>
struct asm_mul<hold<ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, mrm_v<hold<reg<4>>, Y...>>;
};

//  mul ANY [M] 4  [66] F7 

template<typename ...Z>
struct asm_mul<hold<zip<reg16>::with<Z...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<4>>>::value>;
};

template<typename ...Z>
struct asm_mul<hold<ptr<reg16, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<4>>, Z...>>;
};

//  mul ANY [M] 4  [] F7 

template<typename ...Z>
struct asm_mul<hold<zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<4>>>::value>;
};

template<typename ...Z>
struct asm_mul<hold<ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<4>>, Z...>>;
};

//  mul X64 [M] 4  [] F7 

template<typename ...Z>
struct asm_mul<hold<zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<4>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<4>>>::value>;
};

template<typename ...Z>
struct asm_mul<hold<ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<4>>, Z...>>;
};

//  mulpd ANY [RM] r  [66] 59 
template<class T, class Enable = bool> struct asm_mulpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','u','l','p','d', str...>, hold<T...>> {
    using value = typename asm_mulpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_mulpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x59>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_mulpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x59>, mrm_v<hold<T...>, Y...>>;
};

//  mulps ANY [RM] r  [] 59 
template<class T, class Enable = bool> struct asm_mulps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','u','l','p','s', str...>, hold<T...>> {
    using value = typename asm_mulps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_mulps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x59>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_mulps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x59>, mrm_v<hold<T...>, Y...>>;
};

//  mulsd ANY [RM] r  [F2] 59 
template<class T, class Enable = bool> struct asm_mulsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','u','l','s','d', str...>, hold<T...>> {
    using value = typename asm_mulsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_mulsd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x59>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_mulsd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x59>, mrm_v<hold<T...>, Y...>>;
};

//  mulss ANY [RM] r  [F3] 59 
template<class T, class Enable = bool> struct asm_mulss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','u','l','s','s', str...>, hold<T...>> {
    using value = typename asm_mulss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_mulss<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x59>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_mulss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x59>, mrm_v<hold<T...>, Y...>>;
};

//  mulx ANY [RVM] r  [F2] F6 
template<class T, class Enable = bool> struct asm_mulx {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','u','l','x', str...>, hold<T...>> {
    using value = typename asm_mulx<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_mulx<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF6>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_mulx<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF6>, mrm_v<hold<T...>, Z...>>;
};

//  mulx X64 [RVM] r  [F2] F6 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_mulx<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF6>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_mulx<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF6>, mrm_v<hold<T...>, Z...>>;
};

//  mwait ANY [NONE]   [] C9 
template<class T, class Enable = bool> struct asm_mwait {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','w','a','i','t', str...>, hold<T...>> {
    using value = typename asm_mwait<hold<T...>>::value;
};
template <>
struct asm_mwait<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xC9>>; };
//  mwaitx ANY [NONE]   [] FB 
template<class T, class Enable = bool> struct asm_mwaitx {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','w','a','i','t','x', str...>, hold<T...>> {
    using value = typename asm_mwaitx<hold<T...>>::value;
};
template <>
struct asm_mwaitx<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xFB>>; };
//  neg ANY [M] 3  [] F6 
template<class T, class Enable = bool> struct asm_neg {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'n','e','g', str...>, hold<T...>> {
    using value = typename asm_neg<hold<T...>>::value;
};
template<typename ...T>
struct asm_neg<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_neg<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF6>, mrm_v<hold<reg<3>>, T...>>;
};

//  neg ANY [M] 3  [66] F7 

template<typename ...T>
struct asm_neg<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_neg<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<3>>, T...>>;
};

//  neg ANY [M] 3  [] F7 

template<typename ...T>
struct asm_neg<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_neg<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<3>>, T...>>;
};

//  neg X64 [M] 3  [] F7 

template<typename ...T>
struct asm_neg<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_neg<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<3>>, T...>>;
};

//  nop ANY [NONE]   [] 90 
template<class T, class Enable = bool> struct asm_nop {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'n','o','p', str...>, hold<T...>> {
    using value = typename asm_nop<hold<T...>>::value;
};
template <> struct asm_nop<hold<>, bool> { using value = expseq_v<byte_seq<0x90>>; };
//  nop ANY [M] 0  [66] 1F 

template<typename ...T>
struct asm_nop<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x1F>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_nop<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x1F>, mrm_v<hold<reg<0>>, T...>>;
};

//  nop ANY [M] 0  [] 1F 

template<typename ...T>
struct asm_nop<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x1F>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_nop<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x1F>, mrm_v<hold<reg<0>>, T...>>;
};

//  nop ANY [M] 0  [] 1F 

template<typename ...T>
struct asm_nop<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x1F>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_nop<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x1F>, mrm_v<hold<reg<0>>, T...>>;
};

//  nop ANY [MR] r  [66] 1F 

template<typename ...T, typename ...Y>
struct asm_nop<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x1F>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_nop<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x1F>, mrm_v<hold<Y...>, T...>>;
};

//  nop ANY [MR] r  [] 1F 

template<typename ...T, typename ...Y>
struct asm_nop<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x1F>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_nop<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x1F>, mrm_v<hold<Y...>, T...>>;
};

//  nop ANY [MR] r  [] 1F 

template<typename ...T, typename ...Y>
struct asm_nop<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x1F>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_nop<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x1F>, mrm_v<hold<Y...>, T...>>;
};

//  not ANY [M] 2  [] F6 
template<class T, class Enable = bool> struct asm_not {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'n','o','t', str...>, hold<T...>> {
    using value = typename asm_not<hold<T...>>::value;
};
template<typename ...T>
struct asm_not<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_not<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF6>, mrm_v<hold<reg<2>>, T...>>;
};

//  not ANY [M] 2  [66] F7 

template<typename ...T>
struct asm_not<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_not<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<2>>, T...>>;
};

//  not ANY [M] 2  [] F7 

template<typename ...T>
struct asm_not<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_not<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<2>>, T...>>;
};

//  not X64 [M] 2  [] F7 

template<typename ...T>
struct asm_not<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_not<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<2>>, T...>>;
};

//  or ANY [I]   [] 0C 
template<class T, class Enable = bool> struct asm_or {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'o','r', str...>, hold<T...>> {
    using value = typename asm_or<hold<T...>>::value;
};
template <class Y> 
struct asm_or<hold<al, Y>, typename u8_8<Y>::type>{
  using value = expseq_v<byte_seq<0x0C>, typename u8_8<Y>::value>;
};
//  or ANY [I]   [66] 0D 

template <class Y> 
struct asm_or<hold<ax, Y>, typename u16_8<Y>::type>{
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0D>, typename u16_8<Y>::value>;
};
//  or ANY [I]   [] 0D 

template <class Y> 
struct asm_or<hold<eax, Y>, typename u32_8<Y>::type>{
  using value = expseq_v<byte_seq<0x0D>, typename u32_8<Y>::value>;
};
//  or X64 [I]   [] 0D 

template <class Y> 
struct asm_or<hold<rax, Y>, typename i32_8<Y>::type>{
  using value = expseq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x0D>, typename i32_8<Y>::value>;
};
//  or ANY [MI] 1  [] 80 

template<typename ...T, class Y>
struct asm_or<hold<ptr<reg8, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x80>, mrm_v<hold<reg<1>>, T...>, typename u8_8<Y>::value>;
};

//  or ANY [MI] 1  [66] 81 

template<typename ...T, class Y>
struct asm_or<hold<ptr<reg16, T...>, Y>, typename u16_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<1>>, T...>, typename u16_8<Y>::value>;
};

//  or ANY [MI] 1  [] 81 

template<typename ...T, class Y>
struct asm_or<hold<ptr<reg32, T...>, Y>, typename u32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<1>>, T...>, typename u32_8<Y>::value>;
};

//  or X64 [MI] 1  [] 81 

template<typename ...T, class Y>
struct asm_or<hold<ptr<reg64, T...>, Y>, typename i32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<1>>, T...>, typename i32_8<Y>::value>;
};

//  or ANY [MI] 1  [66] 83 

template<typename ...T, class Y>
struct asm_or<hold<ptr<reg16, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<1>>, T...>, typename i8_8<Y>::value>;
};

//  or ANY [MI] 1  [] 83 

template<typename ...T, class Y>
struct asm_or<hold<ptr<reg32, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<1>>, T...>, typename i8_8<Y>::value>;
};

//  or X64 [MI] 1  [] 83 

template<typename ...T, class Y>
struct asm_or<hold<ptr<reg64, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<1>>, T...>, typename i8_8<Y>::value>;
};

//  or ANY [MR] r  [] 08 

template<typename ...T, typename ...Y>
struct asm_or<hold<ptr<reg8, T...>, zip<reg8>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x08>, mrm_v<hold<Y...>, T...>>;
};

//  or ANY [MR] r  [66] 09 

template<typename ...T, typename ...Y>
struct asm_or<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x09>, mrm_v<hold<Y...>, T...>>;
};

//  or ANY [MR] r  [] 09 

template<typename ...T, typename ...Y>
struct asm_or<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x09>, mrm_v<hold<Y...>, T...>>;
};

//  or X64 [MR] r  [] 09 

template<typename ...T, typename ...Y>
struct asm_or<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x09>, mrm_v<hold<Y...>, T...>>;
};

//  or ANY [RM] r  [] 0A 

template<typename ...T, typename ...Y>
struct asm_or<hold<zip<reg8>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_or<hold<zip<reg8>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0A>, mrm_v<hold<T...>, Y...>>;
};

//  or ANY [RM] r  [66] 0B 

template<typename ...T, typename ...Y>
struct asm_or<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_or<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0B>, mrm_v<hold<T...>, Y...>>;
};

//  or ANY [RM] r  [] 0B 

template<typename ...T, typename ...Y>
struct asm_or<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_or<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0B>, mrm_v<hold<T...>, Y...>>;
};

//  or X64 [RM] r  [] 0B 

template<typename ...T, typename ...Y>
struct asm_or<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_or<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0B>, mrm_v<hold<T...>, Y...>>;
};

//  orpd ANY [RM] r  [66] 56 
template<class T, class Enable = bool> struct asm_orpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'o','r','p','d', str...>, hold<T...>> {
    using value = typename asm_orpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_orpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x56>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_orpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x56>, mrm_v<hold<T...>, Y...>>;
};

//  orps ANY [RM] r  [] 56 
template<class T, class Enable = bool> struct asm_orps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'o','r','p','s', str...>, hold<T...>> {
    using value = typename asm_orps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_orps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x56>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_orps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x56>, mrm_v<hold<T...>, Y...>>;
};

//  out ANY [I]   [] E6 
template<class T, class Enable = bool> struct asm_out {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'o','u','t', str...>, hold<T...>> {
    using value = typename asm_out<hold<T...>>::value;
};
template <class T> 
struct asm_out<hold<T, al>, typename u8_8<T>::type> {
  using value = expseq_v<byte_seq<0xE6>, typename u8_8<T>::value>;
};
//  out ANY [I]   [66] E7 

template <class T> 
struct asm_out<hold<T, ax>, typename u8_8<T>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0xE7>, typename u8_8<T>::value>;
};
//  out ANY [I]   [] E7 

template <class T> 
struct asm_out<hold<T, eax>, typename u8_8<T>::type> {
  using value = expseq_v<byte_seq<0xE7>, typename u8_8<T>::value>;
};
//  outsb ANY [NONE]   [] 6E 
template<class T, class Enable = bool> struct asm_outsb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'o','u','t','s','b', str...>, hold<T...>> {
    using value = typename asm_outsb<hold<T...>>::value;
};
template <>
struct asm_outsb<hold<dx, zsi>, bool> { using value = expseq_v<byte_seq<0x6E>>; };
//  outsd ANY [NONE]   [] 6F 
template<class T, class Enable = bool> struct asm_outsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'o','u','t','s','d', str...>, hold<T...>> {
    using value = typename asm_outsd<hold<T...>>::value;
};
template <>
struct asm_outsd<hold<dx, zsi>, bool> { using value = expseq_v<byte_seq<0x6F>>; };
//  outsw ANY [NONE]   [66] 6F 
template<class T, class Enable = bool> struct asm_outsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'o','u','t','s','w', str...>, hold<T...>> {
    using value = typename asm_outsw<hold<T...>>::value;
};
template <>
struct asm_outsw<hold<dx, zsi>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x6F>>; };
//  pabsb ANY [RM] r  [] 1C 
template<class T, class Enable = bool> struct asm_pabsb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','b','s','b', str...>, hold<T...>> {
    using value = typename asm_pabsb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pabsb<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pabsb<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1C>, mrm_v<hold<T...>, Y...>>;
};

//  pabsb ANY [RM] r  [66] 1C 

template<typename ...T, typename ...Y>
struct asm_pabsb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pabsb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1C>, mrm_v<hold<T...>, Y...>>;
};

//  pabsd ANY [RM] r  [] 1E 
template<class T, class Enable = bool> struct asm_pabsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','b','s','d', str...>, hold<T...>> {
    using value = typename asm_pabsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pabsd<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pabsd<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1E>, mrm_v<hold<T...>, Y...>>;
};

//  pabsd ANY [RM] r  [66] 1E 

template<typename ...T, typename ...Y>
struct asm_pabsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pabsd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1E>, mrm_v<hold<T...>, Y...>>;
};

//  pabsw ANY [RM] r  [] 1D 
template<class T, class Enable = bool> struct asm_pabsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','b','s','w', str...>, hold<T...>> {
    using value = typename asm_pabsw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pabsw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pabsw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1D>, mrm_v<hold<T...>, Y...>>;
};

//  pabsw ANY [RM] r  [66] 1D 

template<typename ...T, typename ...Y>
struct asm_pabsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pabsw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1D>, mrm_v<hold<T...>, Y...>>;
};

//  packssdw ANY [RM] r  [] 6B 
template<class T, class Enable = bool> struct asm_packssdw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','c','k','s','s','d','w', str...>, hold<T...>> {
    using value = typename asm_packssdw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_packssdw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_packssdw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6B>, mrm_v<hold<T...>, Y...>>;
};

//  packssdw ANY [RM] r  [66] 6B 

template<typename ...T, typename ...Y>
struct asm_packssdw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_packssdw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6B>, mrm_v<hold<T...>, Y...>>;
};

//  packsswb ANY [RM] r  [] 63 
template<class T, class Enable = bool> struct asm_packsswb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','c','k','s','s','w','b', str...>, hold<T...>> {
    using value = typename asm_packsswb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_packsswb<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x63>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_packsswb<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x63>, mrm_v<hold<T...>, Y...>>;
};

//  packsswb ANY [RM] r  [66] 63 

template<typename ...T, typename ...Y>
struct asm_packsswb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x63>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_packsswb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x63>, mrm_v<hold<T...>, Y...>>;
};

//  packusdw ANY [RM] r  [66] 2B 
template<class T, class Enable = bool> struct asm_packusdw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','c','k','u','s','d','w', str...>, hold<T...>> {
    using value = typename asm_packusdw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_packusdw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_packusdw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2B>, mrm_v<hold<T...>, Y...>>;
};

//  packuswb ANY [RM] r  [] 67 
template<class T, class Enable = bool> struct asm_packuswb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','c','k','u','s','w','b', str...>, hold<T...>> {
    using value = typename asm_packuswb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_packuswb<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x67>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_packuswb<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x67>, mrm_v<hold<T...>, Y...>>;
};

//  packuswb ANY [RM] r  [66] 67 

template<typename ...T, typename ...Y>
struct asm_packuswb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x67>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_packuswb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x67>, mrm_v<hold<T...>, Y...>>;
};

//  paddb ANY [RM] r  [] FC 
template<class T, class Enable = bool> struct asm_paddb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','d','d','b', str...>, hold<T...>> {
    using value = typename asm_paddb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_paddb<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFC>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_paddb<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFC>, mrm_v<hold<T...>, Y...>>;
};

//  paddb ANY [RM] r  [66] FC 

template<typename ...T, typename ...Y>
struct asm_paddb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFC>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_paddb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFC>, mrm_v<hold<T...>, Y...>>;
};

//  paddd ANY [RM] r  [] FE 
template<class T, class Enable = bool> struct asm_paddd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','d','d','d', str...>, hold<T...>> {
    using value = typename asm_paddd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_paddd<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFE>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_paddd<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFE>, mrm_v<hold<T...>, Y...>>;
};

//  paddd ANY [RM] r  [66] FE 

template<typename ...T, typename ...Y>
struct asm_paddd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFE>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_paddd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFE>, mrm_v<hold<T...>, Y...>>;
};

//  paddq ANY [RM] r  [] D4 
template<class T, class Enable = bool> struct asm_paddq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','d','d','q', str...>, hold<T...>> {
    using value = typename asm_paddq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_paddq<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD4>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_paddq<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD4>, mrm_v<hold<T...>, Y...>>;
};

//  paddq ANY [RM] r  [66] D4 

template<typename ...T, typename ...Y>
struct asm_paddq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD4>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_paddq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD4>, mrm_v<hold<T...>, Y...>>;
};

//  paddsb ANY [RM] r  [] EC 
template<class T, class Enable = bool> struct asm_paddsb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','d','d','s','b', str...>, hold<T...>> {
    using value = typename asm_paddsb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_paddsb<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEC>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_paddsb<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEC>, mrm_v<hold<T...>, Y...>>;
};

//  paddsb ANY [RM] r  [66] EC 

template<typename ...T, typename ...Y>
struct asm_paddsb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEC>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_paddsb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEC>, mrm_v<hold<T...>, Y...>>;
};

//  paddsw ANY [RM] r  [] ED 
template<class T, class Enable = bool> struct asm_paddsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','d','d','s','w', str...>, hold<T...>> {
    using value = typename asm_paddsw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_paddsw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xED>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_paddsw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xED>, mrm_v<hold<T...>, Y...>>;
};

//  paddsw ANY [RM] r  [66] ED 

template<typename ...T, typename ...Y>
struct asm_paddsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xED>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_paddsw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xED>, mrm_v<hold<T...>, Y...>>;
};

//  paddusb ANY [RM] r  [] DC 
template<class T, class Enable = bool> struct asm_paddusb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','d','d','u','s','b', str...>, hold<T...>> {
    using value = typename asm_paddusb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_paddusb<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_paddusb<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDC>, mrm_v<hold<T...>, Y...>>;
};

//  paddusb ANY [RM] r  [66] DC 

template<typename ...T, typename ...Y>
struct asm_paddusb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_paddusb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDC>, mrm_v<hold<T...>, Y...>>;
};

//  paddusw ANY [RM] r  [] DD 
template<class T, class Enable = bool> struct asm_paddusw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','d','d','u','s','w', str...>, hold<T...>> {
    using value = typename asm_paddusw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_paddusw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDD>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_paddusw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDD>, mrm_v<hold<T...>, Y...>>;
};

//  paddusw ANY [RM] r  [66] DD 

template<typename ...T, typename ...Y>
struct asm_paddusw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDD>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_paddusw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDD>, mrm_v<hold<T...>, Y...>>;
};

//  paddw ANY [RM] r  [] FD 
template<class T, class Enable = bool> struct asm_paddw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','d','d','w', str...>, hold<T...>> {
    using value = typename asm_paddw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_paddw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFD>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_paddw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFD>, mrm_v<hold<T...>, Y...>>;
};

//  paddw ANY [RM] r  [66] FD 

template<typename ...T, typename ...Y>
struct asm_paddw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFD>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_paddw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFD>, mrm_v<hold<T...>, Y...>>;
};

//  palignr ANY [RMI] r  [] 0F 
template<class T, class Enable = bool> struct asm_palignr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','l','i','g','n','r', str...>, hold<T...>> {
    using value = typename asm_palignr<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_palignr<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0F>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_palignr<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0F>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  palignr ANY [RMI] r  [66] 0F 

template<typename ...T, typename ...Y, class Z>
struct asm_palignr<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0F>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_palignr<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0F>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  pand ANY [RM] r  [] DB 
template<class T, class Enable = bool> struct asm_pand {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','n','d', str...>, hold<T...>> {
    using value = typename asm_pand<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pand<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDB>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pand<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDB>, mrm_v<hold<T...>, Y...>>;
};

//  pand ANY [RM] r  [66] DB 

template<typename ...T, typename ...Y>
struct asm_pand<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDB>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pand<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDB>, mrm_v<hold<T...>, Y...>>;
};

//  pandn ANY [RM] r  [] DF 
template<class T, class Enable = bool> struct asm_pandn {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','n','d','n', str...>, hold<T...>> {
    using value = typename asm_pandn<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pandn<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pandn<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDF>, mrm_v<hold<T...>, Y...>>;
};

//  pandn ANY [RM] r  [66] DF 

template<typename ...T, typename ...Y>
struct asm_pandn<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pandn<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDF>, mrm_v<hold<T...>, Y...>>;
};

//  pause ANY [NONE]   [F3] 90 
template<class T, class Enable = bool> struct asm_pause {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','u','s','e', str...>, hold<T...>> {
    using value = typename asm_pause<hold<T...>>::value;
};
template <> struct asm_pause<hold<>, bool> { using value = expseq_v<byte_seq<0xF3>, byte_seq<0x90>>; };
//  pavgb ANY [RM] r  [] E0 
template<class T, class Enable = bool> struct asm_pavgb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','v','g','b', str...>, hold<T...>> {
    using value = typename asm_pavgb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pavgb<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE0>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pavgb<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE0>, mrm_v<hold<T...>, Y...>>;
};

//  pavgb ANY [RM] r  [66] E0 

template<typename ...T, typename ...Y>
struct asm_pavgb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE0>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pavgb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE0>, mrm_v<hold<T...>, Y...>>;
};

//  pavgusb ANY [RM] r  [] BF 
template<class T, class Enable = bool> struct asm_pavgusb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','v','g','u','s','b', str...>, hold<T...>> {
    using value = typename asm_pavgusb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pavgusb<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBF>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pavgusb<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBF>, mrm_v<hold<T...>, Y...>>;
};

//  pavgw ANY [RM] r  [] E3 
template<class T, class Enable = bool> struct asm_pavgw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','v','g','w', str...>, hold<T...>> {
    using value = typename asm_pavgw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pavgw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE3>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pavgw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE3>, mrm_v<hold<T...>, Y...>>;
};

//  pavgw ANY [RM] r  [66] E3 

template<typename ...T, typename ...Y>
struct asm_pavgw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE3>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pavgw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE3>, mrm_v<hold<T...>, Y...>>;
};

//  pblendvb ANY [RM] r  [66] E0 
template<class T, class Enable = bool> struct asm_pblendvb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','b','l','e','n','d','v','b', str...>, hold<T...>> {
    using value = typename asm_pblendvb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pblendvb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE0>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pblendvb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE0>, mrm_v<hold<T...>, Y...>>;
};

//  pblendw ANY [RMI] r  [66] 0E 
template<class T, class Enable = bool> struct asm_pblendw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','b','l','e','n','d','w', str...>, hold<T...>> {
    using value = typename asm_pblendw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_pblendw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0E>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_pblendw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0E>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  pclmulqdq ANY [RMI] r  [66] 44 
template<class T, class Enable = bool> struct asm_pclmulqdq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','l','m','u','l','q','d','q', str...>, hold<T...>> {
    using value = typename asm_pclmulqdq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_pclmulqdq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x44>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_pclmulqdq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x44>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  pcmpeqb ANY [RM] r  [] 74 
template<class T, class Enable = bool> struct asm_pcmpeqb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','e','q','b', str...>, hold<T...>> {
    using value = typename asm_pcmpeqb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pcmpeqb<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x74>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pcmpeqb<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x74>, mrm_v<hold<T...>, Y...>>;
};

//  pcmpeqb ANY [RM] r  [66] 74 

template<typename ...T, typename ...Y>
struct asm_pcmpeqb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x74>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pcmpeqb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x74>, mrm_v<hold<T...>, Y...>>;
};

//  pcmpeqd ANY [RM] r  [] 76 
template<class T, class Enable = bool> struct asm_pcmpeqd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','e','q','d', str...>, hold<T...>> {
    using value = typename asm_pcmpeqd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pcmpeqd<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x76>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pcmpeqd<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x76>, mrm_v<hold<T...>, Y...>>;
};

//  pcmpeqd ANY [RM] r  [66] 76 

template<typename ...T, typename ...Y>
struct asm_pcmpeqd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x76>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pcmpeqd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x76>, mrm_v<hold<T...>, Y...>>;
};

//  pcmpeqq ANY [RM] r  [66] 29 
template<class T, class Enable = bool> struct asm_pcmpeqq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','e','q','q', str...>, hold<T...>> {
    using value = typename asm_pcmpeqq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pcmpeqq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x29>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pcmpeqq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x29>, mrm_v<hold<T...>, Y...>>;
};

//  pcmpeqw ANY [RM] r  [] 75 
template<class T, class Enable = bool> struct asm_pcmpeqw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','e','q','w', str...>, hold<T...>> {
    using value = typename asm_pcmpeqw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pcmpeqw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x75>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pcmpeqw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x75>, mrm_v<hold<T...>, Y...>>;
};

//  pcmpeqw ANY [RM] r  [66] 75 

template<typename ...T, typename ...Y>
struct asm_pcmpeqw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x75>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pcmpeqw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x75>, mrm_v<hold<T...>, Y...>>;
};

//  pcmpestri ANY [RMI] r  [66] 61 
template<class T, class Enable = bool> struct asm_pcmpestri {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','e','s','t','r','i', str...>, hold<T...>> {
    using value = typename asm_pcmpestri<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_pcmpestri<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x61>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_pcmpestri<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x61>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  pcmpestrm ANY [RMI] r  [66] 60 
template<class T, class Enable = bool> struct asm_pcmpestrm {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','e','s','t','r','m', str...>, hold<T...>> {
    using value = typename asm_pcmpestrm<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_pcmpestrm<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x60>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_pcmpestrm<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x60>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  pcmpgtb ANY [RM] r  [] 64 
template<class T, class Enable = bool> struct asm_pcmpgtb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','g','t','b', str...>, hold<T...>> {
    using value = typename asm_pcmpgtb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pcmpgtb<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x64>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pcmpgtb<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x64>, mrm_v<hold<T...>, Y...>>;
};

//  pcmpgtb ANY [RM] r  [66] 64 

template<typename ...T, typename ...Y>
struct asm_pcmpgtb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x64>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pcmpgtb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x64>, mrm_v<hold<T...>, Y...>>;
};

//  pcmpgtd ANY [RM] r  [] 66 
template<class T, class Enable = bool> struct asm_pcmpgtd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','g','t','d', str...>, hold<T...>> {
    using value = typename asm_pcmpgtd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pcmpgtd<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x66>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pcmpgtd<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x66>, mrm_v<hold<T...>, Y...>>;
};

//  pcmpgtd ANY [RM] r  [66] 66 

template<typename ...T, typename ...Y>
struct asm_pcmpgtd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x66>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pcmpgtd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x66>, mrm_v<hold<T...>, Y...>>;
};

//  pcmpgtq ANY [RM] r  [66] 37 
template<class T, class Enable = bool> struct asm_pcmpgtq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','g','t','q', str...>, hold<T...>> {
    using value = typename asm_pcmpgtq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pcmpgtq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x37>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pcmpgtq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x37>, mrm_v<hold<T...>, Y...>>;
};

//  pcmpgtw ANY [RM] r  [] 65 
template<class T, class Enable = bool> struct asm_pcmpgtw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','g','t','w', str...>, hold<T...>> {
    using value = typename asm_pcmpgtw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pcmpgtw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x65>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pcmpgtw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x65>, mrm_v<hold<T...>, Y...>>;
};

//  pcmpgtw ANY [RM] r  [66] 65 

template<typename ...T, typename ...Y>
struct asm_pcmpgtw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x65>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pcmpgtw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x65>, mrm_v<hold<T...>, Y...>>;
};

//  pcmpistri ANY [RMI] r  [66] 63 
template<class T, class Enable = bool> struct asm_pcmpistri {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','i','s','t','r','i', str...>, hold<T...>> {
    using value = typename asm_pcmpistri<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_pcmpistri<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x63>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_pcmpistri<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x63>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  pcmpistrm ANY [RMI] r  [66] 62 
template<class T, class Enable = bool> struct asm_pcmpistrm {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','i','s','t','r','m', str...>, hold<T...>> {
    using value = typename asm_pcmpistrm<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_pcmpistrm<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x62>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_pcmpistrm<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x62>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  pconfig ANY [NONE]   [] C5 
template<class T, class Enable = bool> struct asm_pconfig {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','o','n','f','i','g', str...>, hold<T...>> {
    using value = typename asm_pconfig<hold<T...>>::value;
};
template <> struct asm_pconfig<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xC5>>; };
//  pdep ANY [RVM] r  [F2] F5 
template<class T, class Enable = bool> struct asm_pdep {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','d','e','p', str...>, hold<T...>> {
    using value = typename asm_pdep<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_pdep<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF5>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_pdep<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF5>, mrm_v<hold<T...>, Z...>>;
};

//  pdep X64 [RVM] r  [F2] F5 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_pdep<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF5>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_pdep<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF5>, mrm_v<hold<T...>, Z...>>;
};

//  pext ANY [RVM] r  [F3] F5 
template<class T, class Enable = bool> struct asm_pext {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','e','x','t', str...>, hold<T...>> {
    using value = typename asm_pext<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_pext<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0xF5>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_pext<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0xF5>, mrm_v<hold<T...>, Z...>>;
};

//  pext X64 [RVM] r  [F3] F5 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_pext<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0xF5>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_pext<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0xF5>, mrm_v<hold<T...>, Z...>>;
};

//  pextrb ANY [MRI] r  [66] 14 
template<class T, class Enable = bool> struct asm_pextrb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','e','x','t','r','b', str...>, hold<T...>> {
    using value = typename asm_pextrb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_pextrb<hold<ptr<reg8, T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x14>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  pextrd ANY [MRI] r  [66] 16 
template<class T, class Enable = bool> struct asm_pextrd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','e','x','t','r','d', str...>, hold<T...>> {
    using value = typename asm_pextrd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_pextrd<hold<ptr<reg32, T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x16>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  pextrq X64 [MRI] r  [66] 16 
template<class T, class Enable = bool> struct asm_pextrq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','e','x','t','r','q', str...>, hold<T...>> {
    using value = typename asm_pextrq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_pextrq<hold<ptr<reg64, T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x16>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  pextrw ANY [RMI] r  [] C5 
template<class T, class Enable = bool> struct asm_pextrw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','e','x','t','r','w', str...>, hold<T...>> {
    using value = typename asm_pextrw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_pextrw<hold<zip<reg32>::with<T...>, zip<mmx>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC5>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

//  pextrw ANY [RMI] r  [66] C5 

template<typename ...T, typename ...Y, class Z>
struct asm_pextrw<hold<zip<reg32>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC5>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

//  pextrw ANY [MRI] r  [66] 15 

template<typename ...T, typename ...Y, class Z>
struct asm_pextrw<hold<ptr<reg16, T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x15>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  pf2id ANY [RM] r  [] 1D 
template<class T, class Enable = bool> struct asm_pf2id {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','2','i','d', str...>, hold<T...>> {
    using value = typename asm_pf2id<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pf2id<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pf2id<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1D>, mrm_v<hold<T...>, Y...>>;
};

//  pf2iw ANY [RM] r  [] 1C 
template<class T, class Enable = bool> struct asm_pf2iw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','2','i','w', str...>, hold<T...>> {
    using value = typename asm_pf2iw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pf2iw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pf2iw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1C>, mrm_v<hold<T...>, Y...>>;
};

//  pfacc ANY [RM] r  [] AE 
template<class T, class Enable = bool> struct asm_pfacc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','a','c','c', str...>, hold<T...>> {
    using value = typename asm_pfacc<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfacc<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfacc<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xAE>, mrm_v<hold<T...>, Y...>>;
};

//  pfadd ANY [RM] r  [] 9E 
template<class T, class Enable = bool> struct asm_pfadd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','a','d','d', str...>, hold<T...>> {
    using value = typename asm_pfadd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfadd<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x9E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfadd<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x9E>, mrm_v<hold<T...>, Y...>>;
};

//  pfcmpeq ANY [RM] r  [] B0 
template<class T, class Enable = bool> struct asm_pfcmpeq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','c','m','p','e','q', str...>, hold<T...>> {
    using value = typename asm_pfcmpeq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfcmpeq<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB0>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfcmpeq<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB0>, mrm_v<hold<T...>, Y...>>;
};

//  pfcmpge ANY [RM] r  [] 90 
template<class T, class Enable = bool> struct asm_pfcmpge {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','c','m','p','g','e', str...>, hold<T...>> {
    using value = typename asm_pfcmpge<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfcmpge<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x90>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfcmpge<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x90>, mrm_v<hold<T...>, Y...>>;
};

//  pfcmpgt ANY [RM] r  [] A0 
template<class T, class Enable = bool> struct asm_pfcmpgt {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','c','m','p','g','t', str...>, hold<T...>> {
    using value = typename asm_pfcmpgt<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfcmpgt<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xA0>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfcmpgt<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xA0>, mrm_v<hold<T...>, Y...>>;
};

//  pfmax ANY [RM] r  [] A4 
template<class T, class Enable = bool> struct asm_pfmax {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','m','a','x', str...>, hold<T...>> {
    using value = typename asm_pfmax<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfmax<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xA4>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfmax<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xA4>, mrm_v<hold<T...>, Y...>>;
};

//  pfmin ANY [RM] r  [] 94 
template<class T, class Enable = bool> struct asm_pfmin {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','m','i','n', str...>, hold<T...>> {
    using value = typename asm_pfmin<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfmin<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x94>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfmin<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x94>, mrm_v<hold<T...>, Y...>>;
};

//  pfmul ANY [RM] r  [] B4 
template<class T, class Enable = bool> struct asm_pfmul {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','m','u','l', str...>, hold<T...>> {
    using value = typename asm_pfmul<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfmul<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB4>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfmul<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB4>, mrm_v<hold<T...>, Y...>>;
};

//  pfnacc ANY [RM] r  [] 8A 
template<class T, class Enable = bool> struct asm_pfnacc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','n','a','c','c', str...>, hold<T...>> {
    using value = typename asm_pfnacc<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfnacc<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfnacc<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8A>, mrm_v<hold<T...>, Y...>>;
};

//  pfpnacc ANY [RM] r  [] 8E 
template<class T, class Enable = bool> struct asm_pfpnacc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','p','n','a','c','c', str...>, hold<T...>> {
    using value = typename asm_pfpnacc<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfpnacc<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfpnacc<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8E>, mrm_v<hold<T...>, Y...>>;
};

//  pfrcp ANY [RM] r  [] 96 
template<class T, class Enable = bool> struct asm_pfrcp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','r','c','p', str...>, hold<T...>> {
    using value = typename asm_pfrcp<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfrcp<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x96>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfrcp<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x96>, mrm_v<hold<T...>, Y...>>;
};

//  pfrcpit1 ANY [RM] r  [] A6 
template<class T, class Enable = bool> struct asm_pfrcpit1 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','r','c','p','i','t','1', str...>, hold<T...>> {
    using value = typename asm_pfrcpit1<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfrcpit1<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xA6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfrcpit1<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xA6>, mrm_v<hold<T...>, Y...>>;
};

//  pfrcpit2 ANY [RM] r  [] B6 
template<class T, class Enable = bool> struct asm_pfrcpit2 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','r','c','p','i','t','2', str...>, hold<T...>> {
    using value = typename asm_pfrcpit2<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfrcpit2<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfrcpit2<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB6>, mrm_v<hold<T...>, Y...>>;
};

//  pfrcpv ANY [RM] r  [] 86 
template<class T, class Enable = bool> struct asm_pfrcpv {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','r','c','p','v', str...>, hold<T...>> {
    using value = typename asm_pfrcpv<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfrcpv<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x86>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfrcpv<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x86>, mrm_v<hold<T...>, Y...>>;
};

//  pfrsqit1 ANY [RM] r  [] A7 
template<class T, class Enable = bool> struct asm_pfrsqit1 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','r','s','q','i','t','1', str...>, hold<T...>> {
    using value = typename asm_pfrsqit1<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfrsqit1<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xA7>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfrsqit1<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xA7>, mrm_v<hold<T...>, Y...>>;
};

//  pfrsqrt ANY [RM] r  [] 97 
template<class T, class Enable = bool> struct asm_pfrsqrt {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','r','s','q','r','t', str...>, hold<T...>> {
    using value = typename asm_pfrsqrt<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfrsqrt<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x97>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfrsqrt<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x97>, mrm_v<hold<T...>, Y...>>;
};

//  pfrsqrtv ANY [RM] r  [] 87 
template<class T, class Enable = bool> struct asm_pfrsqrtv {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','r','s','q','r','t','v', str...>, hold<T...>> {
    using value = typename asm_pfrsqrtv<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfrsqrtv<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x87>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfrsqrtv<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x87>, mrm_v<hold<T...>, Y...>>;
};

//  pfsub ANY [RM] r  [] 9A 
template<class T, class Enable = bool> struct asm_pfsub {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','s','u','b', str...>, hold<T...>> {
    using value = typename asm_pfsub<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfsub<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x9A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfsub<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x9A>, mrm_v<hold<T...>, Y...>>;
};

//  pfsubr ANY [RM] r  [] AA 
template<class T, class Enable = bool> struct asm_pfsubr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','s','u','b','r', str...>, hold<T...>> {
    using value = typename asm_pfsubr<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pfsubr<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xAA>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pfsubr<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xAA>, mrm_v<hold<T...>, Y...>>;
};

//  phaddd ANY [RM] r  [] 02 
template<class T, class Enable = bool> struct asm_phaddd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','h','a','d','d','d', str...>, hold<T...>> {
    using value = typename asm_phaddd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_phaddd<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x02>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_phaddd<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x02>, mrm_v<hold<T...>, Y...>>;
};

//  phaddd ANY [RM] r  [66] 02 

template<typename ...T, typename ...Y>
struct asm_phaddd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x02>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_phaddd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x02>, mrm_v<hold<T...>, Y...>>;
};

//  phaddsw ANY [RM] r  [] 03 
template<class T, class Enable = bool> struct asm_phaddsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','h','a','d','d','s','w', str...>, hold<T...>> {
    using value = typename asm_phaddsw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_phaddsw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x03>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_phaddsw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x03>, mrm_v<hold<T...>, Y...>>;
};

//  phaddsw ANY [RM] r  [66] 03 

template<typename ...T, typename ...Y>
struct asm_phaddsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x03>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_phaddsw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x03>, mrm_v<hold<T...>, Y...>>;
};

//  phaddw ANY [RM] r  [] 01 
template<class T, class Enable = bool> struct asm_phaddw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','h','a','d','d','w', str...>, hold<T...>> {
    using value = typename asm_phaddw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_phaddw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x01>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_phaddw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x01>, mrm_v<hold<T...>, Y...>>;
};

//  phaddw ANY [RM] r  [66] 01 

template<typename ...T, typename ...Y>
struct asm_phaddw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x01>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_phaddw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x01>, mrm_v<hold<T...>, Y...>>;
};

//  phminposuw ANY [RM] r  [66] 41 
template<class T, class Enable = bool> struct asm_phminposuw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','h','m','i','n','p','o','s','u','w', str...>, hold<T...>> {
    using value = typename asm_phminposuw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_phminposuw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x41>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_phminposuw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x41>, mrm_v<hold<T...>, Y...>>;
};

//  phsubd ANY [RM] r  [] 06 
template<class T, class Enable = bool> struct asm_phsubd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','h','s','u','b','d', str...>, hold<T...>> {
    using value = typename asm_phsubd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_phsubd<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x06>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_phsubd<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x06>, mrm_v<hold<T...>, Y...>>;
};

//  phsubd ANY [RM] r  [66] 06 

template<typename ...T, typename ...Y>
struct asm_phsubd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x06>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_phsubd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x06>, mrm_v<hold<T...>, Y...>>;
};

//  phsubsw ANY [RM] r  [] 07 
template<class T, class Enable = bool> struct asm_phsubsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','h','s','u','b','s','w', str...>, hold<T...>> {
    using value = typename asm_phsubsw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_phsubsw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x07>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_phsubsw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x07>, mrm_v<hold<T...>, Y...>>;
};

//  phsubsw ANY [RM] r  [66] 07 

template<typename ...T, typename ...Y>
struct asm_phsubsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x07>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_phsubsw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x07>, mrm_v<hold<T...>, Y...>>;
};

//  phsubw ANY [RM] r  [] 05 
template<class T, class Enable = bool> struct asm_phsubw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','h','s','u','b','w', str...>, hold<T...>> {
    using value = typename asm_phsubw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_phsubw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x05>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_phsubw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x05>, mrm_v<hold<T...>, Y...>>;
};

//  phsubw ANY [RM] r  [66] 05 

template<typename ...T, typename ...Y>
struct asm_phsubw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x05>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_phsubw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x05>, mrm_v<hold<T...>, Y...>>;
};

//  pi2fd ANY [RM] r  [] 0D 
template<class T, class Enable = bool> struct asm_pi2fd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','i','2','f','d', str...>, hold<T...>> {
    using value = typename asm_pi2fd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pi2fd<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pi2fd<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0D>, mrm_v<hold<T...>, Y...>>;
};

//  pi2fw ANY [RM] r  [] 0C 
template<class T, class Enable = bool> struct asm_pi2fw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','i','2','f','w', str...>, hold<T...>> {
    using value = typename asm_pi2fw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pi2fw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pi2fw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0C>, mrm_v<hold<T...>, Y...>>;
};

//  pinsrb ANY [RMI] r  [66] 20 
template<class T, class Enable = bool> struct asm_pinsrb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','i','n','s','r','b', str...>, hold<T...>> {
    using value = typename asm_pinsrb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_pinsrb<hold<zip<reg128>::with<T...>, zip<reg8>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x20>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_pinsrb<hold<zip<reg128>::with<T...>, ptr<reg8, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x20>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  pinsrd ANY [RMI] r  [66] 22 
template<class T, class Enable = bool> struct asm_pinsrd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','i','n','s','r','d', str...>, hold<T...>> {
    using value = typename asm_pinsrd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_pinsrd<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x22>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_pinsrd<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x22>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  pinsrq X64 [RMI] r  [66] 22 
template<class T, class Enable = bool> struct asm_pinsrq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','i','n','s','r','q', str...>, hold<T...>> {
    using value = typename asm_pinsrq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_pinsrq<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x22>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_pinsrq<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x22>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  pinsrw ANY [RMI] r  [] C4 
template<class T, class Enable = bool> struct asm_pinsrw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','i','n','s','r','w', str...>, hold<T...>> {
    using value = typename asm_pinsrw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_pinsrw<hold<zip<mmx>::with<T...>, zip<reg16>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC4>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_pinsrw<hold<zip<mmx>::with<T...>, ptr<reg16, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC4>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  pinsrw ANY [RMI] r  [66] C4 

template<typename ...T, typename ...Y, class Z>
struct asm_pinsrw<hold<zip<reg128>::with<T...>, zip<reg16>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC4>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_pinsrw<hold<zip<reg128>::with<T...>, ptr<reg16, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC4>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  pmaddubsw ANY [RM] r  [] 04 
template<class T, class Enable = bool> struct asm_pmaddubsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','a','d','d','u','b','s','w', str...>, hold<T...>> {
    using value = typename asm_pmaddubsw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmaddubsw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x04>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmaddubsw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x04>, mrm_v<hold<T...>, Y...>>;
};

//  pmaddubsw ANY [RM] r  [66] 04 

template<typename ...T, typename ...Y>
struct asm_pmaddubsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x04>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmaddubsw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x04>, mrm_v<hold<T...>, Y...>>;
};

//  pmaddwd ANY [RM] r  [] F5 
template<class T, class Enable = bool> struct asm_pmaddwd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','a','d','d','w','d', str...>, hold<T...>> {
    using value = typename asm_pmaddwd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmaddwd<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF5>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmaddwd<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF5>, mrm_v<hold<T...>, Y...>>;
};

//  pmaddwd ANY [RM] r  [66] F5 

template<typename ...T, typename ...Y>
struct asm_pmaddwd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF5>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmaddwd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF5>, mrm_v<hold<T...>, Y...>>;
};

//  pmaxsb ANY [RM] r  [66] 3C 
template<class T, class Enable = bool> struct asm_pmaxsb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','a','x','s','b', str...>, hold<T...>> {
    using value = typename asm_pmaxsb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmaxsb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmaxsb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3C>, mrm_v<hold<T...>, Y...>>;
};

//  pmaxsd ANY [RM] r  [66] 3D 
template<class T, class Enable = bool> struct asm_pmaxsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','a','x','s','d', str...>, hold<T...>> {
    using value = typename asm_pmaxsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmaxsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmaxsd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3D>, mrm_v<hold<T...>, Y...>>;
};

//  pmaxsw ANY [RM] r  [] EE 
template<class T, class Enable = bool> struct asm_pmaxsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','a','x','s','w', str...>, hold<T...>> {
    using value = typename asm_pmaxsw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmaxsw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEE>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmaxsw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEE>, mrm_v<hold<T...>, Y...>>;
};

//  pmaxsw ANY [RM] r  [66] EE 

template<typename ...T, typename ...Y>
struct asm_pmaxsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEE>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmaxsw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEE>, mrm_v<hold<T...>, Y...>>;
};

//  pmaxub ANY [RM] r  [] DE 
template<class T, class Enable = bool> struct asm_pmaxub {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','a','x','u','b', str...>, hold<T...>> {
    using value = typename asm_pmaxub<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmaxub<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmaxub<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDE>, mrm_v<hold<T...>, Y...>>;
};

//  pmaxub ANY [RM] r  [66] DE 

template<typename ...T, typename ...Y>
struct asm_pmaxub<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmaxub<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDE>, mrm_v<hold<T...>, Y...>>;
};

//  pmaxud ANY [RM] r  [66] 3F 
template<class T, class Enable = bool> struct asm_pmaxud {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','a','x','u','d', str...>, hold<T...>> {
    using value = typename asm_pmaxud<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmaxud<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmaxud<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3F>, mrm_v<hold<T...>, Y...>>;
};

//  pmaxuw ANY [RM] r  [66] 3E 
template<class T, class Enable = bool> struct asm_pmaxuw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','a','x','u','w', str...>, hold<T...>> {
    using value = typename asm_pmaxuw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmaxuw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmaxuw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3E>, mrm_v<hold<T...>, Y...>>;
};

//  pminsb ANY [RM] r  [66] 38 
template<class T, class Enable = bool> struct asm_pminsb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','i','n','s','b', str...>, hold<T...>> {
    using value = typename asm_pminsb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pminsb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x38>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pminsb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x38>, mrm_v<hold<T...>, Y...>>;
};

//  pminsd ANY [RM] r  [66] 39 
template<class T, class Enable = bool> struct asm_pminsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','i','n','s','d', str...>, hold<T...>> {
    using value = typename asm_pminsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pminsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x39>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pminsd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x39>, mrm_v<hold<T...>, Y...>>;
};

//  pminsw ANY [RM] r  [] EA 
template<class T, class Enable = bool> struct asm_pminsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','i','n','s','w', str...>, hold<T...>> {
    using value = typename asm_pminsw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pminsw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEA>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pminsw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEA>, mrm_v<hold<T...>, Y...>>;
};

//  pminsw ANY [RM] r  [66] EA 

template<typename ...T, typename ...Y>
struct asm_pminsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEA>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pminsw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEA>, mrm_v<hold<T...>, Y...>>;
};

//  pminub ANY [RM] r  [] DA 
template<class T, class Enable = bool> struct asm_pminub {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','i','n','u','b', str...>, hold<T...>> {
    using value = typename asm_pminub<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pminub<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pminub<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDA>, mrm_v<hold<T...>, Y...>>;
};

//  pminub ANY [RM] r  [66] DA 

template<typename ...T, typename ...Y>
struct asm_pminub<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pminub<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDA>, mrm_v<hold<T...>, Y...>>;
};

//  pminud ANY [RM] r  [66] 3B 
template<class T, class Enable = bool> struct asm_pminud {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','i','n','u','d', str...>, hold<T...>> {
    using value = typename asm_pminud<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pminud<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pminud<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3B>, mrm_v<hold<T...>, Y...>>;
};

//  pminuw ANY [RM] r  [66] 3A 
template<class T, class Enable = bool> struct asm_pminuw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','i','n','u','w', str...>, hold<T...>> {
    using value = typename asm_pminuw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pminuw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pminuw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3A>, mrm_v<hold<T...>, Y...>>;
};

//  pmovmskb ANY [RM] r  [] D7 
template<class T, class Enable = bool> struct asm_pmovmskb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','m','s','k','b', str...>, hold<T...>> {
    using value = typename asm_pmovmskb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmovmskb<hold<zip<reg32>::with<T...>, zip<mmx>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD7>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  pmovmskb ANY [RM] r  [66] D7 

template<typename ...T, typename ...Y>
struct asm_pmovmskb<hold<zip<reg32>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD7>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  pmovsxbd ANY [RM] r  [66] 21 
template<class T, class Enable = bool> struct asm_pmovsxbd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','s','x','b','d', str...>, hold<T...>> {
    using value = typename asm_pmovsxbd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmovsxbd<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x21>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmovsxbd<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x21>, mrm_v<hold<T...>, Y...>>;
};

//  pmovsxbq ANY [RM] r  [66] 22 
template<class T, class Enable = bool> struct asm_pmovsxbq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','s','x','b','q', str...>, hold<T...>> {
    using value = typename asm_pmovsxbq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmovsxbq<hold<zip<reg128>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x22>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmovsxbq<hold<zip<reg128>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x22>, mrm_v<hold<T...>, Y...>>;
};

//  pmovsxbw ANY [RM] r  [66] 20 
template<class T, class Enable = bool> struct asm_pmovsxbw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','s','x','b','w', str...>, hold<T...>> {
    using value = typename asm_pmovsxbw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmovsxbw<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x20>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmovsxbw<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x20>, mrm_v<hold<T...>, Y...>>;
};

//  pmovsxdq ANY [RM] r  [66] 25 
template<class T, class Enable = bool> struct asm_pmovsxdq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','s','x','d','q', str...>, hold<T...>> {
    using value = typename asm_pmovsxdq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmovsxdq<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x25>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmovsxdq<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x25>, mrm_v<hold<T...>, Y...>>;
};

//  pmovsxwd ANY [RM] r  [66] 23 
template<class T, class Enable = bool> struct asm_pmovsxwd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','s','x','w','d', str...>, hold<T...>> {
    using value = typename asm_pmovsxwd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmovsxwd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x23>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmovsxwd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x23>, mrm_v<hold<T...>, Y...>>;
};

//  pmovsxwq ANY [RM] r  [66] 24 
template<class T, class Enable = bool> struct asm_pmovsxwq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','s','x','w','q', str...>, hold<T...>> {
    using value = typename asm_pmovsxwq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmovsxwq<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x24>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmovsxwq<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x24>, mrm_v<hold<T...>, Y...>>;
};

//  pmovzxbd ANY [RM] r  [66] 31 
template<class T, class Enable = bool> struct asm_pmovzxbd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','z','x','b','d', str...>, hold<T...>> {
    using value = typename asm_pmovzxbd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmovzxbd<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x31>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmovzxbd<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x31>, mrm_v<hold<T...>, Y...>>;
};

//  pmovzxbq ANY [RM] r  [66] 32 
template<class T, class Enable = bool> struct asm_pmovzxbq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','z','x','b','q', str...>, hold<T...>> {
    using value = typename asm_pmovzxbq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmovzxbq<hold<zip<reg128>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x32>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmovzxbq<hold<zip<reg128>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x32>, mrm_v<hold<T...>, Y...>>;
};

//  pmovzxbw ANY [RM] r  [66] 30 
template<class T, class Enable = bool> struct asm_pmovzxbw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','z','x','b','w', str...>, hold<T...>> {
    using value = typename asm_pmovzxbw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmovzxbw<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x30>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmovzxbw<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x30>, mrm_v<hold<T...>, Y...>>;
};

//  pmovzxdq ANY [RM] r  [66] 35 
template<class T, class Enable = bool> struct asm_pmovzxdq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','z','x','d','q', str...>, hold<T...>> {
    using value = typename asm_pmovzxdq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmovzxdq<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x35>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmovzxdq<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x35>, mrm_v<hold<T...>, Y...>>;
};

//  pmovzxwd ANY [RM] r  [66] 33 
template<class T, class Enable = bool> struct asm_pmovzxwd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','z','x','w','d', str...>, hold<T...>> {
    using value = typename asm_pmovzxwd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmovzxwd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x33>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmovzxwd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x33>, mrm_v<hold<T...>, Y...>>;
};

//  pmovzxwq ANY [RM] r  [66] 34 
template<class T, class Enable = bool> struct asm_pmovzxwq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','z','x','w','q', str...>, hold<T...>> {
    using value = typename asm_pmovzxwq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmovzxwq<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x34>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmovzxwq<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x34>, mrm_v<hold<T...>, Y...>>;
};

//  pmuldq ANY [RM] r  [66] 28 
template<class T, class Enable = bool> struct asm_pmuldq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','u','l','d','q', str...>, hold<T...>> {
    using value = typename asm_pmuldq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmuldq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x28>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmuldq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x28>, mrm_v<hold<T...>, Y...>>;
};

//  pmulhrsw ANY [RM] r  [] 0B 
template<class T, class Enable = bool> struct asm_pmulhrsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','u','l','h','r','s','w', str...>, hold<T...>> {
    using value = typename asm_pmulhrsw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmulhrsw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmulhrsw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0B>, mrm_v<hold<T...>, Y...>>;
};

//  pmulhrsw ANY [RM] r  [66] 0B 

template<typename ...T, typename ...Y>
struct asm_pmulhrsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmulhrsw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0B>, mrm_v<hold<T...>, Y...>>;
};

//  pmulhrw ANY [RM] r  [] B7 
template<class T, class Enable = bool> struct asm_pmulhrw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','u','l','h','r','w', str...>, hold<T...>> {
    using value = typename asm_pmulhrw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmulhrw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB7>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmulhrw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB7>, mrm_v<hold<T...>, Y...>>;
};

//  pmulhuw ANY [RM] r  [] E4 
template<class T, class Enable = bool> struct asm_pmulhuw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','u','l','h','u','w', str...>, hold<T...>> {
    using value = typename asm_pmulhuw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmulhuw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE4>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmulhuw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE4>, mrm_v<hold<T...>, Y...>>;
};

//  pmulhuw ANY [RM] r  [66] E4 

template<typename ...T, typename ...Y>
struct asm_pmulhuw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE4>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmulhuw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE4>, mrm_v<hold<T...>, Y...>>;
};

//  pmulhw ANY [RM] r  [] E5 
template<class T, class Enable = bool> struct asm_pmulhw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','u','l','h','w', str...>, hold<T...>> {
    using value = typename asm_pmulhw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmulhw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE5>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmulhw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE5>, mrm_v<hold<T...>, Y...>>;
};

//  pmulhw ANY [RM] r  [66] E5 

template<typename ...T, typename ...Y>
struct asm_pmulhw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE5>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmulhw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE5>, mrm_v<hold<T...>, Y...>>;
};

//  pmulld ANY [RM] r  [66] 40 
template<class T, class Enable = bool> struct asm_pmulld {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','u','l','l','d', str...>, hold<T...>> {
    using value = typename asm_pmulld<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmulld<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x40>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmulld<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x40>, mrm_v<hold<T...>, Y...>>;
};

//  pmullw ANY [RM] r  [] D5 
template<class T, class Enable = bool> struct asm_pmullw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','u','l','l','w', str...>, hold<T...>> {
    using value = typename asm_pmullw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmullw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD5>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmullw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD5>, mrm_v<hold<T...>, Y...>>;
};

//  pmullw ANY [RM] r  [66] D5 

template<typename ...T, typename ...Y>
struct asm_pmullw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD5>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmullw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD5>, mrm_v<hold<T...>, Y...>>;
};

//  pmuludq ANY [RM] r  [] F4 
template<class T, class Enable = bool> struct asm_pmuludq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','u','l','u','d','q', str...>, hold<T...>> {
    using value = typename asm_pmuludq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pmuludq<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF4>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmuludq<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF4>, mrm_v<hold<T...>, Y...>>;
};

//  pmuludq ANY [RM] r  [66] F4 

template<typename ...T, typename ...Y>
struct asm_pmuludq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF4>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pmuludq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF4>, mrm_v<hold<T...>, Y...>>;
};

//  pop ANY [M] 0  [66] 8F 
template<class T, class Enable = bool> struct asm_pop {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','o','p', str...>, hold<T...>> {
    using value = typename asm_pop<hold<T...>>::value;
};
template<typename ...T>
struct asm_pop<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x8F>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_pop<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x8F>, mrm_v<hold<reg<0>>, T...>>;
};

//  pop X86 [M] 0  [] 8F 

template<typename ...T>
struct asm_pop<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x8F>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_pop<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x8F>, mrm_v<hold<reg<0>>, T...>>;
};

//  pop X64 [M] 0  [] 8F 

template<typename ...T>
struct asm_pop<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x8F>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_pop<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x8F>, mrm_v<hold<reg<0>>, T...>>;
};

//  pop ANY [O]   [66] 58 

//  pop X86 [O]   [] 58 

//  pop X64 [O]   [] 58 

//  popa X86 [NONE]   [66] 61 
template<class T, class Enable = bool> struct asm_popa {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','o','p','a', str...>, hold<T...>> {
    using value = typename asm_popa<hold<T...>>::value;
};
template <> struct asm_popa<hold<>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x61>>; };
//  popad X86 [NONE]   [] 61 
template<class T, class Enable = bool> struct asm_popad {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','o','p','a','d', str...>, hold<T...>> {
    using value = typename asm_popad<hold<T...>>::value;
};
template <> struct asm_popad<hold<>, bool> { using value = expseq_v<byte_seq<0x61>>; };
//  popcnt ANY [RM] r  [66F3] B8 
template<class T, class Enable = bool> struct asm_popcnt {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','o','p','c','n','t', str...>, hold<T...>> {
    using value = typename asm_popcnt<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_popcnt<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66, 0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB8>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_popcnt<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66, 0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB8>, mrm_v<hold<T...>, Y...>>;
};

//  popcnt ANY [RM] r  [F3] B8 

template<typename ...T, typename ...Y>
struct asm_popcnt<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB8>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_popcnt<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB8>, mrm_v<hold<T...>, Y...>>;
};

//  popcnt X64 [RM] r  [F3] B8 

template<typename ...T, typename ...Y>
struct asm_popcnt<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB8>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_popcnt<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB8>, mrm_v<hold<T...>, Y...>>;
};

//  popf ANY [NONE]   [66] 9D 
template<class T, class Enable = bool> struct asm_popf {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','o','p','f', str...>, hold<T...>> {
    using value = typename asm_popf<hold<T...>>::value;
};
template <> struct asm_popf<hold<>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x9D>>; };
//  popfd X86 [NONE]   [] 9D 
template<class T, class Enable = bool> struct asm_popfd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','o','p','f','d', str...>, hold<T...>> {
    using value = typename asm_popfd<hold<T...>>::value;
};
template <> struct asm_popfd<hold<>, bool> { using value = expseq_v<byte_seq<0x9D>>; };
//  popfq X64 [NONE]   [] 9D 
template<class T, class Enable = bool> struct asm_popfq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','o','p','f','q', str...>, hold<T...>> {
    using value = typename asm_popfq<hold<T...>>::value;
};
template <> struct asm_popfq<hold<>, bool> { using value = expseq_v<byte_seq<0x9D>>; };
//  por ANY [RM] r  [] EB 
template<class T, class Enable = bool> struct asm_por {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','o','r', str...>, hold<T...>> {
    using value = typename asm_por<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_por<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEB>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_por<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEB>, mrm_v<hold<T...>, Y...>>;
};

//  por ANY [RM] r  [66] EB 

template<typename ...T, typename ...Y>
struct asm_por<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEB>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_por<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEB>, mrm_v<hold<T...>, Y...>>;
};

//  prefetch ANY [M] 0  [] 0D 
template<class T, class Enable = bool> struct asm_prefetch {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','r','e','f','e','t','c','h', str...>, hold<T...>> {
    using value = typename asm_prefetch<hold<T...>>::value;
};
template<typename ...T>
struct asm_prefetch<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x0D>, mrm_v<hold<reg<0>>, T...>>;
};

//  prefetchnta ANY [M] 0  [] 18 
template<class T, class Enable = bool> struct asm_prefetchnta {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','r','e','f','e','t','c','h','n','t','a', str...>, hold<T...>> {
    using value = typename asm_prefetchnta<hold<T...>>::value;
};
template<typename ...T>
struct asm_prefetchnta<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x18>, mrm_v<hold<reg<0>>, T...>>;
};

//  prefetcht0 ANY [M] 1  [] 18 
template<class T, class Enable = bool> struct asm_prefetcht0 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','r','e','f','e','t','c','h','t','0', str...>, hold<T...>> {
    using value = typename asm_prefetcht0<hold<T...>>::value;
};
template<typename ...T>
struct asm_prefetcht0<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x18>, mrm_v<hold<reg<1>>, T...>>;
};

//  prefetcht1 ANY [M] 2  [] 18 
template<class T, class Enable = bool> struct asm_prefetcht1 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','r','e','f','e','t','c','h','t','1', str...>, hold<T...>> {
    using value = typename asm_prefetcht1<hold<T...>>::value;
};
template<typename ...T>
struct asm_prefetcht1<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x18>, mrm_v<hold<reg<2>>, T...>>;
};

//  prefetcht2 ANY [M] 3  [] 18 
template<class T, class Enable = bool> struct asm_prefetcht2 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','r','e','f','e','t','c','h','t','2', str...>, hold<T...>> {
    using value = typename asm_prefetcht2<hold<T...>>::value;
};
template<typename ...T>
struct asm_prefetcht2<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x18>, mrm_v<hold<reg<3>>, T...>>;
};

//  prefetchw ANY [M] 1  [] 0D 
template<class T, class Enable = bool> struct asm_prefetchw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','r','e','f','e','t','c','h','w', str...>, hold<T...>> {
    using value = typename asm_prefetchw<hold<T...>>::value;
};
template<typename ...T>
struct asm_prefetchw<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x0D>, mrm_v<hold<reg<1>>, T...>>;
};

//  prefetchwt1 ANY [M] 2  [] 0D 
template<class T, class Enable = bool> struct asm_prefetchwt1 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','r','e','f','e','t','c','h','w','t','1', str...>, hold<T...>> {
    using value = typename asm_prefetchwt1<hold<T...>>::value;
};
template<typename ...T>
struct asm_prefetchwt1<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x0D>, mrm_v<hold<reg<2>>, T...>>;
};

//  psadbw ANY [RM] r  [] F6 
template<class T, class Enable = bool> struct asm_psadbw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','a','d','b','w', str...>, hold<T...>> {
    using value = typename asm_psadbw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_psadbw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psadbw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, mrm_v<hold<T...>, Y...>>;
};

//  psadbw ANY [RM] r  [66] F6 

template<typename ...T, typename ...Y>
struct asm_psadbw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psadbw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, mrm_v<hold<T...>, Y...>>;
};

//  pshufb ANY [RM] r  [] 00 
template<class T, class Enable = bool> struct asm_pshufb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','h','u','f','b', str...>, hold<T...>> {
    using value = typename asm_pshufb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pshufb<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pshufb<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x00>, mrm_v<hold<T...>, Y...>>;
};

//  pshufb ANY [RM] r  [66] 00 

template<typename ...T, typename ...Y>
struct asm_pshufb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pshufb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x00>, mrm_v<hold<T...>, Y...>>;
};

//  pshufd ANY [RMI] r  [66] 70 
template<class T, class Enable = bool> struct asm_pshufd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','h','u','f','d', str...>, hold<T...>> {
    using value = typename asm_pshufd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_pshufd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_pshufd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x70>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  pshufhw ANY [RMI] r  [F3] 70 
template<class T, class Enable = bool> struct asm_pshufhw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','h','u','f','h','w', str...>, hold<T...>> {
    using value = typename asm_pshufhw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_pshufhw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_pshufhw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x70>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  pshuflw ANY [RMI] r  [F2] 70 
template<class T, class Enable = bool> struct asm_pshuflw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','h','u','f','l','w', str...>, hold<T...>> {
    using value = typename asm_pshuflw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_pshuflw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_pshuflw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x70>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  pshufw ANY [RMI] r  [] 70 
template<class T, class Enable = bool> struct asm_pshufw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','h','u','f','w', str...>, hold<T...>> {
    using value = typename asm_pshufw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_pshufw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_pshufw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x70>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  psignb ANY [RM] r  [] 08 
template<class T, class Enable = bool> struct asm_psignb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','i','g','n','b', str...>, hold<T...>> {
    using value = typename asm_psignb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_psignb<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x08>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psignb<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x08>, mrm_v<hold<T...>, Y...>>;
};

//  psignb ANY [RM] r  [66] 08 

template<typename ...T, typename ...Y>
struct asm_psignb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x08>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psignb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x08>, mrm_v<hold<T...>, Y...>>;
};

//  psignd ANY [RM] r  [] 0A 
template<class T, class Enable = bool> struct asm_psignd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','i','g','n','d', str...>, hold<T...>> {
    using value = typename asm_psignd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_psignd<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psignd<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0A>, mrm_v<hold<T...>, Y...>>;
};

//  psignd ANY [RM] r  [66] 0A 

template<typename ...T, typename ...Y>
struct asm_psignd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psignd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0A>, mrm_v<hold<T...>, Y...>>;
};

//  psignw ANY [RM] r  [] 09 
template<class T, class Enable = bool> struct asm_psignw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','i','g','n','w', str...>, hold<T...>> {
    using value = typename asm_psignw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_psignw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x09>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psignw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x09>, mrm_v<hold<T...>, Y...>>;
};

//  psignw ANY [RM] r  [66] 09 

template<typename ...T, typename ...Y>
struct asm_psignw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x09>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psignw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x09>, mrm_v<hold<T...>, Y...>>;
};

//  pslld ANY [MI] 6  [] 72 
template<class T, class Enable = bool> struct asm_pslld {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','l','l','d', str...>, hold<T...>> {
    using value = typename asm_pslld<hold<T...>>::value;
};
//  pslld ANY [RM] r  [] F2 

template<typename ...T, typename ...Y>
struct asm_pslld<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF2>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pslld<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF2>, mrm_v<hold<T...>, Y...>>;
};

//  pslld ANY [MI] 6  [66] 72 

//  pslld ANY [RM] r  [66] F2 

template<typename ...T, typename ...Y>
struct asm_pslld<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF2>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pslld<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF2>, mrm_v<hold<T...>, Y...>>;
};

//  pslldq ANY [MI] 7  [66] 73 
template<class T, class Enable = bool> struct asm_pslldq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','l','l','d','q', str...>, hold<T...>> {
    using value = typename asm_pslldq<hold<T...>>::value;
};
//  psllq ANY [MI] 6  [] 73 
template<class T, class Enable = bool> struct asm_psllq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','l','l','q', str...>, hold<T...>> {
    using value = typename asm_psllq<hold<T...>>::value;
};
//  psllq ANY [RM] r  [] F3 

template<typename ...T, typename ...Y>
struct asm_psllq<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF3>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psllq<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF3>, mrm_v<hold<T...>, Y...>>;
};

//  psllq ANY [MI] 6  [66] 73 

//  psllq ANY [RM] r  [66] F3 

template<typename ...T, typename ...Y>
struct asm_psllq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF3>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psllq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF3>, mrm_v<hold<T...>, Y...>>;
};

//  psllw ANY [MI] 6  [] 71 
template<class T, class Enable = bool> struct asm_psllw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','l','l','w', str...>, hold<T...>> {
    using value = typename asm_psllw<hold<T...>>::value;
};
//  psllw ANY [RM] r  [] F1 

template<typename ...T, typename ...Y>
struct asm_psllw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF1>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psllw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF1>, mrm_v<hold<T...>, Y...>>;
};

//  psllw ANY [MI] 6  [66] 71 

//  psllw ANY [RM] r  [66] F1 

template<typename ...T, typename ...Y>
struct asm_psllw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF1>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psllw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF1>, mrm_v<hold<T...>, Y...>>;
};

//  psmash X64 [NONE]   [F3] FF 
template<class T, class Enable = bool> struct asm_psmash {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','m','a','s','h', str...>, hold<T...>> {
    using value = typename asm_psmash<hold<T...>>::value;
};
template <> struct asm_psmash<hold<>, bool> { using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x01>, byte_seq<0xFF>>; };
//  psrad ANY [MI] 4  [] 72 
template<class T, class Enable = bool> struct asm_psrad {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','r','a','d', str...>, hold<T...>> {
    using value = typename asm_psrad<hold<T...>>::value;
};
//  psrad ANY [RM] r  [] E2 

template<typename ...T, typename ...Y>
struct asm_psrad<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE2>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psrad<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE2>, mrm_v<hold<T...>, Y...>>;
};

//  psrad ANY [MI] 4  [66] 72 

//  psrad ANY [RM] r  [66] E2 

template<typename ...T, typename ...Y>
struct asm_psrad<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE2>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psrad<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE2>, mrm_v<hold<T...>, Y...>>;
};

//  psraw ANY [MI] 4  [] 71 
template<class T, class Enable = bool> struct asm_psraw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','r','a','w', str...>, hold<T...>> {
    using value = typename asm_psraw<hold<T...>>::value;
};
//  psraw ANY [RM] r  [] E1 

template<typename ...T, typename ...Y>
struct asm_psraw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE1>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psraw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE1>, mrm_v<hold<T...>, Y...>>;
};

//  psraw ANY [MI] 4  [66] 71 

//  psraw ANY [RM] r  [66] E1 

template<typename ...T, typename ...Y>
struct asm_psraw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE1>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psraw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE1>, mrm_v<hold<T...>, Y...>>;
};

//  psrld ANY [MI] 2  [] 72 
template<class T, class Enable = bool> struct asm_psrld {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','r','l','d', str...>, hold<T...>> {
    using value = typename asm_psrld<hold<T...>>::value;
};
//  psrld ANY [RM] r  [] D2 

template<typename ...T, typename ...Y>
struct asm_psrld<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psrld<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD2>, mrm_v<hold<T...>, Y...>>;
};

//  psrld ANY [MI] 2  [66] 72 

//  psrld ANY [RM] r  [66] D2 

template<typename ...T, typename ...Y>
struct asm_psrld<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psrld<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD2>, mrm_v<hold<T...>, Y...>>;
};

//  psrldq ANY [MI] 3  [66] 73 
template<class T, class Enable = bool> struct asm_psrldq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','r','l','d','q', str...>, hold<T...>> {
    using value = typename asm_psrldq<hold<T...>>::value;
};
//  psrlq ANY [MI] 2  [] 73 
template<class T, class Enable = bool> struct asm_psrlq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','r','l','q', str...>, hold<T...>> {
    using value = typename asm_psrlq<hold<T...>>::value;
};
//  psrlq ANY [RM] r  [] D3 

template<typename ...T, typename ...Y>
struct asm_psrlq<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psrlq<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD3>, mrm_v<hold<T...>, Y...>>;
};

//  psrlq ANY [MI] 2  [66] 73 

//  psrlq ANY [RM] r  [66] D3 

template<typename ...T, typename ...Y>
struct asm_psrlq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psrlq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD3>, mrm_v<hold<T...>, Y...>>;
};

//  psrlw ANY [MI] 2  [] 71 
template<class T, class Enable = bool> struct asm_psrlw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','r','l','w', str...>, hold<T...>> {
    using value = typename asm_psrlw<hold<T...>>::value;
};
//  psrlw ANY [RM] r  [] D1 

template<typename ...T, typename ...Y>
struct asm_psrlw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psrlw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD1>, mrm_v<hold<T...>, Y...>>;
};

//  psrlw ANY [MI] 2  [66] 71 

//  psrlw ANY [RM] r  [66] D1 

template<typename ...T, typename ...Y>
struct asm_psrlw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psrlw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD1>, mrm_v<hold<T...>, Y...>>;
};

//  psubb ANY [RM] r  [] F8 
template<class T, class Enable = bool> struct asm_psubb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','u','b','b', str...>, hold<T...>> {
    using value = typename asm_psubb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_psubb<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF8>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psubb<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF8>, mrm_v<hold<T...>, Y...>>;
};

//  psubb ANY [RM] r  [66] F8 

template<typename ...T, typename ...Y>
struct asm_psubb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF8>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psubb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF8>, mrm_v<hold<T...>, Y...>>;
};

//  psubd ANY [RM] r  [] FA 
template<class T, class Enable = bool> struct asm_psubd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','u','b','d', str...>, hold<T...>> {
    using value = typename asm_psubd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_psubd<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFA>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psubd<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFA>, mrm_v<hold<T...>, Y...>>;
};

//  psubd ANY [RM] r  [66] FA 

template<typename ...T, typename ...Y>
struct asm_psubd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFA>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psubd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFA>, mrm_v<hold<T...>, Y...>>;
};

//  psubq ANY [RM] r  [] FB 
template<class T, class Enable = bool> struct asm_psubq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','u','b','q', str...>, hold<T...>> {
    using value = typename asm_psubq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_psubq<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFB>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psubq<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFB>, mrm_v<hold<T...>, Y...>>;
};

//  psubq ANY [RM] r  [66] FB 

template<typename ...T, typename ...Y>
struct asm_psubq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFB>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psubq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFB>, mrm_v<hold<T...>, Y...>>;
};

//  psubsb ANY [RM] r  [] E8 
template<class T, class Enable = bool> struct asm_psubsb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','u','b','s','b', str...>, hold<T...>> {
    using value = typename asm_psubsb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_psubsb<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE8>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psubsb<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE8>, mrm_v<hold<T...>, Y...>>;
};

//  psubsb ANY [RM] r  [66] E8 

template<typename ...T, typename ...Y>
struct asm_psubsb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE8>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psubsb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE8>, mrm_v<hold<T...>, Y...>>;
};

//  psubsw ANY [RM] r  [] E9 
template<class T, class Enable = bool> struct asm_psubsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','u','b','s','w', str...>, hold<T...>> {
    using value = typename asm_psubsw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_psubsw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE9>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psubsw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE9>, mrm_v<hold<T...>, Y...>>;
};

//  psubsw ANY [RM] r  [66] E9 

template<typename ...T, typename ...Y>
struct asm_psubsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE9>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psubsw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE9>, mrm_v<hold<T...>, Y...>>;
};

//  psubusb ANY [RM] r  [] D8 
template<class T, class Enable = bool> struct asm_psubusb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','u','b','u','s','b', str...>, hold<T...>> {
    using value = typename asm_psubusb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_psubusb<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psubusb<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD8>, mrm_v<hold<T...>, Y...>>;
};

//  psubusb ANY [RM] r  [66] D8 

template<typename ...T, typename ...Y>
struct asm_psubusb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psubusb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD8>, mrm_v<hold<T...>, Y...>>;
};

//  psubusw ANY [RM] r  [] D9 
template<class T, class Enable = bool> struct asm_psubusw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','u','b','u','s','w', str...>, hold<T...>> {
    using value = typename asm_psubusw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_psubusw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD9>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psubusw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD9>, mrm_v<hold<T...>, Y...>>;
};

//  psubusw ANY [RM] r  [66] D9 

template<typename ...T, typename ...Y>
struct asm_psubusw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD9>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psubusw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD9>, mrm_v<hold<T...>, Y...>>;
};

//  psubw ANY [RM] r  [] F9 
template<class T, class Enable = bool> struct asm_psubw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','u','b','w', str...>, hold<T...>> {
    using value = typename asm_psubw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_psubw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF9>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psubw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF9>, mrm_v<hold<T...>, Y...>>;
};

//  psubw ANY [RM] r  [66] F9 

template<typename ...T, typename ...Y>
struct asm_psubw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF9>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_psubw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF9>, mrm_v<hold<T...>, Y...>>;
};

//  pswapd ANY [RM] r  [] BB 
template<class T, class Enable = bool> struct asm_pswapd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','w','a','p','d', str...>, hold<T...>> {
    using value = typename asm_pswapd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pswapd<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBB>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pswapd<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBB>, mrm_v<hold<T...>, Y...>>;
};

//  ptest ANY [RM] r  [66] 17 
template<class T, class Enable = bool> struct asm_ptest {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','t','e','s','t', str...>, hold<T...>> {
    using value = typename asm_ptest<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_ptest<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x17>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_ptest<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x17>, mrm_v<hold<T...>, Y...>>;
};

//  ptwrite ANY [M] 4  [F3] AE 
template<class T, class Enable = bool> struct asm_ptwrite {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','t','w','r','i','t','e', str...>, hold<T...>> {
    using value = typename asm_ptwrite<hold<T...>>::value;
};
template<typename ...T>
struct asm_ptwrite<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_ptwrite<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, mrm_v<hold<reg<4>>, T...>>;
};

//  ptwrite X64 [M] 4  [F3] AE 

template<typename ...T>
struct asm_ptwrite<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_ptwrite<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, mrm_v<hold<reg<4>>, T...>>;
};

//  punpckhbw ANY [RM] r  [] 68 
template<class T, class Enable = bool> struct asm_punpckhbw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','n','p','c','k','h','b','w', str...>, hold<T...>> {
    using value = typename asm_punpckhbw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_punpckhbw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x68>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_punpckhbw<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x68>, mrm_v<hold<T...>, Y...>>;
};

//  punpckhbw ANY [RM] r  [66] 68 

template<typename ...T, typename ...Y>
struct asm_punpckhbw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x68>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_punpckhbw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x68>, mrm_v<hold<T...>, Y...>>;
};

//  punpckhdq ANY [RM] r  [] 6A 
template<class T, class Enable = bool> struct asm_punpckhdq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','n','p','c','k','h','d','q', str...>, hold<T...>> {
    using value = typename asm_punpckhdq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_punpckhdq<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_punpckhdq<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6A>, mrm_v<hold<T...>, Y...>>;
};

//  punpckhdq ANY [RM] r  [66] 6A 

template<typename ...T, typename ...Y>
struct asm_punpckhdq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_punpckhdq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6A>, mrm_v<hold<T...>, Y...>>;
};

//  punpckhqdq ANY [RM] r  [66] 6D 
template<class T, class Enable = bool> struct asm_punpckhqdq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','n','p','c','k','h','q','d','q', str...>, hold<T...>> {
    using value = typename asm_punpckhqdq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_punpckhqdq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_punpckhqdq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6D>, mrm_v<hold<T...>, Y...>>;
};

//  punpckhwd ANY [RM] r  [] 69 
template<class T, class Enable = bool> struct asm_punpckhwd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','n','p','c','k','h','w','d', str...>, hold<T...>> {
    using value = typename asm_punpckhwd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_punpckhwd<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x69>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_punpckhwd<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x69>, mrm_v<hold<T...>, Y...>>;
};

//  punpckhwd ANY [RM] r  [66] 69 

template<typename ...T, typename ...Y>
struct asm_punpckhwd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x69>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_punpckhwd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x69>, mrm_v<hold<T...>, Y...>>;
};

//  punpcklbw ANY [RM] r  [] 60 
template<class T, class Enable = bool> struct asm_punpcklbw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','n','p','c','k','l','b','w', str...>, hold<T...>> {
    using value = typename asm_punpcklbw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_punpcklbw<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x60>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_punpcklbw<hold<zip<mmx>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x60>, mrm_v<hold<T...>, Y...>>;
};

//  punpcklbw ANY [RM] r  [66] 60 

template<typename ...T, typename ...Y>
struct asm_punpcklbw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x60>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_punpcklbw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x60>, mrm_v<hold<T...>, Y...>>;
};

//  punpckldq ANY [RM] r  [] 62 
template<class T, class Enable = bool> struct asm_punpckldq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','n','p','c','k','l','d','q', str...>, hold<T...>> {
    using value = typename asm_punpckldq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_punpckldq<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x62>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_punpckldq<hold<zip<mmx>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x62>, mrm_v<hold<T...>, Y...>>;
};

//  punpckldq ANY [RM] r  [66] 62 

template<typename ...T, typename ...Y>
struct asm_punpckldq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x62>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_punpckldq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x62>, mrm_v<hold<T...>, Y...>>;
};

//  punpcklqdq ANY [RM] r  [66] 6C 
template<class T, class Enable = bool> struct asm_punpcklqdq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','n','p','c','k','l','q','d','q', str...>, hold<T...>> {
    using value = typename asm_punpcklqdq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_punpcklqdq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_punpcklqdq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6C>, mrm_v<hold<T...>, Y...>>;
};

//  punpcklwd ANY [RM] r  [] 61 
template<class T, class Enable = bool> struct asm_punpcklwd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','n','p','c','k','l','w','d', str...>, hold<T...>> {
    using value = typename asm_punpcklwd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_punpcklwd<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x61>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_punpcklwd<hold<zip<mmx>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x61>, mrm_v<hold<T...>, Y...>>;
};

//  punpcklwd ANY [RM] r  [66] 61 

template<typename ...T, typename ...Y>
struct asm_punpcklwd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x61>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_punpcklwd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x61>, mrm_v<hold<T...>, Y...>>;
};

//  push ANY [M] 6  [66] FF 
template<class T, class Enable = bool> struct asm_push {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','s','h', str...>, hold<T...>> {
    using value = typename asm_push<hold<T...>>::value;
};
template<typename ...T>
struct asm_push<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

template<typename ...T>
struct asm_push<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<6>>, T...>>;
};

//  push X86 [M] 6  [] FF 

template<typename ...T>
struct asm_push<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

template<typename ...T>
struct asm_push<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<6>>, T...>>;
};

//  push X64 [M] 6  [] FF 

template<typename ...T>
struct asm_push<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

template<typename ...T>
struct asm_push<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, mrm_v<hold<reg<6>>, T...>>;
};

//  push ANY [O]   [66] 50 

//  push X86 [O]   [] 50 

//  push X64 [O]   [] 50 

//  push ANY [I]   [] 6A 

template <class T> 
struct asm_push<hold<T>, typename i8_8<T>::type> {
  using value = expseq_v<byte_seq<0x6A>, typename i8_8<T>::value>;
};
//  push ANY [I]   [66] 68 

template <class T> 
struct asm_push<hold<T>, typename i16_8<T>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x68>, typename i16_8<T>::value>;
};
//  push X86 [I]   [] 68 

template <class T> 
struct asm_push<hold<T>, typename u32_8<T>::type> {
  using value = expseq_v<byte_seq<0x68>, typename u32_8<T>::value>;
};
//  push X64 [I]   [] 68 

template <class T> 
struct asm_push<hold<T>, typename i32_8<T>::type> {
  using value = expseq_v<byte_seq<0x68>, typename i32_8<T>::value>;
};
//  pusha X86 [NONE]   [66] 60 
template<class T, class Enable = bool> struct asm_pusha {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','s','h','a', str...>, hold<T...>> {
    using value = typename asm_pusha<hold<T...>>::value;
};
template <> struct asm_pusha<hold<>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x60>>; };
//  pushad X86 [NONE]   [] 60 
template<class T, class Enable = bool> struct asm_pushad {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','s','h','a','d', str...>, hold<T...>> {
    using value = typename asm_pushad<hold<T...>>::value;
};
template <> struct asm_pushad<hold<>, bool> { using value = expseq_v<byte_seq<0x60>>; };
//  pushf ANY [NONE]   [66] 9C 
template<class T, class Enable = bool> struct asm_pushf {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','s','h','f', str...>, hold<T...>> {
    using value = typename asm_pushf<hold<T...>>::value;
};
template <> struct asm_pushf<hold<>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x9C>>; };
//  pushfd X86 [NONE]   [] 9C 
template<class T, class Enable = bool> struct asm_pushfd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','s','h','f','d', str...>, hold<T...>> {
    using value = typename asm_pushfd<hold<T...>>::value;
};
template <> struct asm_pushfd<hold<>, bool> { using value = expseq_v<byte_seq<0x9C>>; };
//  pushfq X64 [NONE]   [] 9C 
template<class T, class Enable = bool> struct asm_pushfq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','s','h','f','q', str...>, hold<T...>> {
    using value = typename asm_pushfq<hold<T...>>::value;
};
template <> struct asm_pushfq<hold<>, bool> { using value = expseq_v<byte_seq<0x9C>>; };
//  pvalidate ANY [NONE]   [F2] FF 
template<class T, class Enable = bool> struct asm_pvalidate {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','v','a','l','i','d','a','t','e', str...>, hold<T...>> {
    using value = typename asm_pvalidate<hold<T...>>::value;
};
template <> struct asm_pvalidate<hold<>, bool> { using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x01>, byte_seq<0xFF>>; };
//  pxor ANY [RM] r  [] EF 
template<class T, class Enable = bool> struct asm_pxor {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','x','o','r', str...>, hold<T...>> {
    using value = typename asm_pxor<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_pxor<hold<zip<mmx>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEF>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pxor<hold<zip<mmx>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEF>, mrm_v<hold<T...>, Y...>>;
};

//  pxor ANY [RM] r  [66] EF 

template<typename ...T, typename ...Y>
struct asm_pxor<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEF>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_pxor<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEF>, mrm_v<hold<T...>, Y...>>;
};

//  rcl ANY [M] 2  [] D0 
template<class T, class Enable = bool> struct asm_rcl {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','c','l', str...>, hold<T...>> {
    using value = typename asm_rcl<hold<T...>>::value;
};
template<typename ...T>
struct asm_rcl<hold<zip<reg8>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_rcl<hold<ptr<reg8, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD0>, mrm_v<hold<reg<2>>, T...>>;
};

//  rcl ANY [M] 2  [] D2 

template<typename ...T>
struct asm_rcl<hold<zip<reg8>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_rcl<hold<ptr<reg8, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD2>, mrm_v<hold<reg<2>>, T...>>;
};

//  rcl ANY [MI] 2  [] C0 

template<typename ...T, class Y>
struct asm_rcl<hold<ptr<reg8, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC0>, mrm_v<hold<reg<2>>, T...>, typename u8_8<Y>::value>;
};

//  rcl ANY [M] 2  [66] D1 

template<typename ...T>
struct asm_rcl<hold<zip<reg16>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_rcl<hold<ptr<reg16, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<2>>, T...>>;
};

//  rcl ANY [M] 2  [66] D3 

template<typename ...T>
struct asm_rcl<hold<zip<reg16>::with<T...>, cl>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_rcl<hold<ptr<reg16, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<2>>, T...>>;
};

//  rcl ANY [MI] 2  [66] C1 

template<typename ...T, class Y>
struct asm_rcl<hold<ptr<reg16, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<2>>, T...>, typename u8_8<Y>::value>;
};

//  rcl ANY [M] 2  [] D1 

template<typename ...T>
struct asm_rcl<hold<zip<reg32>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_rcl<hold<ptr<reg32, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<2>>, T...>>;
};

//  rcl ANY [M] 2  [] D3 

template<typename ...T>
struct asm_rcl<hold<zip<reg32>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_rcl<hold<ptr<reg32, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<2>>, T...>>;
};

//  rcl ANY [MI] 2  [] C1 

template<typename ...T, class Y>
struct asm_rcl<hold<ptr<reg32, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<2>>, T...>, typename u8_8<Y>::value>;
};

//  rcl X64 [M] 2  [] D1 

template<typename ...T>
struct asm_rcl<hold<zip<reg64>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_rcl<hold<ptr<reg64, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<2>>, T...>>;
};

//  rcl X64 [M] 2  [] D3 

template<typename ...T>
struct asm_rcl<hold<zip<reg64>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_rcl<hold<ptr<reg64, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<2>>, T...>>;
};

//  rcl X64 [MI] 2  [] C1 

template<typename ...T, class Y>
struct asm_rcl<hold<ptr<reg64, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<2>>, T...>, typename u8_8<Y>::value>;
};

//  rcpps ANY [RM] r  [] 53 
template<class T, class Enable = bool> struct asm_rcpps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','c','p','p','s', str...>, hold<T...>> {
    using value = typename asm_rcpps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_rcpps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x53>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_rcpps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x53>, mrm_v<hold<T...>, Y...>>;
};

//  rcpss ANY [RM] r  [F3] 53 
template<class T, class Enable = bool> struct asm_rcpss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','c','p','s','s', str...>, hold<T...>> {
    using value = typename asm_rcpss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_rcpss<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x53>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_rcpss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x53>, mrm_v<hold<T...>, Y...>>;
};

//  rcr ANY [M] 3  [] D0 
template<class T, class Enable = bool> struct asm_rcr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','c','r', str...>, hold<T...>> {
    using value = typename asm_rcr<hold<T...>>::value;
};
template<typename ...T>
struct asm_rcr<hold<zip<reg8>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_rcr<hold<ptr<reg8, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD0>, mrm_v<hold<reg<3>>, T...>>;
};

//  rcr ANY [M] 3  [] D2 

template<typename ...T>
struct asm_rcr<hold<zip<reg8>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_rcr<hold<ptr<reg8, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD2>, mrm_v<hold<reg<3>>, T...>>;
};

//  rcr ANY [MI] 3  [] C0 

template<typename ...T, class Y>
struct asm_rcr<hold<ptr<reg8, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC0>, mrm_v<hold<reg<3>>, T...>, typename u8_8<Y>::value>;
};

//  rcr ANY [M] 3  [66] D1 

template<typename ...T>
struct asm_rcr<hold<zip<reg16>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_rcr<hold<ptr<reg16, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<3>>, T...>>;
};

//  rcr ANY [M] 3  [66] D3 

template<typename ...T>
struct asm_rcr<hold<zip<reg16>::with<T...>, cl>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_rcr<hold<ptr<reg16, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<3>>, T...>>;
};

//  rcr ANY [MI] 3  [66] C1 

template<typename ...T, class Y>
struct asm_rcr<hold<ptr<reg16, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<3>>, T...>, typename u8_8<Y>::value>;
};

//  rcr ANY [M] 3  [] D1 

template<typename ...T>
struct asm_rcr<hold<zip<reg32>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_rcr<hold<ptr<reg32, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<3>>, T...>>;
};

//  rcr ANY [M] 3  [] D3 

template<typename ...T>
struct asm_rcr<hold<zip<reg32>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_rcr<hold<ptr<reg32, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<3>>, T...>>;
};

//  rcr ANY [MI] 3  [] C1 

template<typename ...T, class Y>
struct asm_rcr<hold<ptr<reg32, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<3>>, T...>, typename u8_8<Y>::value>;
};

//  rcr X64 [M] 3  [] D1 

template<typename ...T>
struct asm_rcr<hold<zip<reg64>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_rcr<hold<ptr<reg64, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<3>>, T...>>;
};

//  rcr X64 [M] 3  [] D3 

template<typename ...T>
struct asm_rcr<hold<zip<reg64>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_rcr<hold<ptr<reg64, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<3>>, T...>>;
};

//  rcr X64 [MI] 3  [] C1 

template<typename ...T, class Y>
struct asm_rcr<hold<ptr<reg64, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<3>>, T...>, typename u8_8<Y>::value>;
};

//  rdfsbase X64 [M] 0  [F3] AE 
template<class T, class Enable = bool> struct asm_rdfsbase {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','f','s','b','a','s','e', str...>, hold<T...>> {
    using value = typename asm_rdfsbase<hold<T...>>::value;
};
template<typename ...T>
struct asm_rdfsbase<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

//  rdfsbase X64 [M] 0  [F3] AE 

template<typename ...T>
struct asm_rdfsbase<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

//  rdgsbase X64 [M] 1  [F3] AE 
template<class T, class Enable = bool> struct asm_rdgsbase {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','g','s','b','a','s','e', str...>, hold<T...>> {
    using value = typename asm_rdgsbase<hold<T...>>::value;
};
template<typename ...T>
struct asm_rdgsbase<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

//  rdgsbase X64 [M] 1  [F3] AE 

template<typename ...T>
struct asm_rdgsbase<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

//  rdmsr ANY [NONE]   [] 32 
template<class T, class Enable = bool> struct asm_rdmsr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','m','s','r', str...>, hold<T...>> {
    using value = typename asm_rdmsr<hold<T...>>::value;
};
template <>
struct asm_rdmsr<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x32>>; };
//  rdpid X86 [R] 7  [F3] C7 
template<class T, class Enable = bool> struct asm_rdpid {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','p','i','d', str...>, hold<T...>> {
    using value = typename asm_rdpid<hold<T...>>::value;
};
//  rdpid X64 [R] 7  [F3] C7 

//  rdpkru ANY [NONE]   [] EE 
template<class T, class Enable = bool> struct asm_rdpkru {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','p','k','r','u', str...>, hold<T...>> {
    using value = typename asm_rdpkru<hold<T...>>::value;
};
template <>
struct asm_rdpkru<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xEE>>; };
//  rdpmc ANY [NONE]   [] 33 
template<class T, class Enable = bool> struct asm_rdpmc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','p','m','c', str...>, hold<T...>> {
    using value = typename asm_rdpmc<hold<T...>>::value;
};
template <>
struct asm_rdpmc<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x33>>; };
//  rdpru ANY [NONE]   [] FD 
template<class T, class Enable = bool> struct asm_rdpru {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','p','r','u', str...>, hold<T...>> {
    using value = typename asm_rdpru<hold<T...>>::value;
};
template <>
struct asm_rdpru<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xFD>>; };
//  rdrand ANY [M] 6  [66] C7 
template<class T, class Enable = bool> struct asm_rdrand {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','r','a','n','d', str...>, hold<T...>> {
    using value = typename asm_rdrand<hold<T...>>::value;
};
template<typename ...T>
struct asm_rdrand<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

//  rdrand ANY [M] 6  [] C7 

template<typename ...T>
struct asm_rdrand<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

//  rdrand X64 [M] 6  [] C7 

template<typename ...T>
struct asm_rdrand<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

//  rdseed ANY [M] 7  [66] C7 
template<class T, class Enable = bool> struct asm_rdseed {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','s','e','e','d', str...>, hold<T...>> {
    using value = typename asm_rdseed<hold<T...>>::value;
};
template<typename ...T>
struct asm_rdseed<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

//  rdseed ANY [M] 7  [] C7 

template<typename ...T>
struct asm_rdseed<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

//  rdseed X64 [M] 7  [] C7 

template<typename ...T>
struct asm_rdseed<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

//  rdsspd ANY [M] 1  [F3] 1E 
template<class T, class Enable = bool> struct asm_rdsspd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','s','s','p','d', str...>, hold<T...>> {
    using value = typename asm_rdsspd<hold<T...>>::value;
};
template<typename ...T>
struct asm_rdsspd<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x1E>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

//  rdsspq X64 [M] 1  [F3] 1E 
template<class T, class Enable = bool> struct asm_rdsspq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','s','s','p','q', str...>, hold<T...>> {
    using value = typename asm_rdsspq<hold<T...>>::value;
};
template<typename ...T>
struct asm_rdsspq<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x1E>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

//  rdtsc ANY [NONE]   [] 31 
template<class T, class Enable = bool> struct asm_rdtsc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','t','s','c', str...>, hold<T...>> {
    using value = typename asm_rdtsc<hold<T...>>::value;
};
template <>
struct asm_rdtsc<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x31>>; };
//  rdtscp ANY [NONE]   [] F9 
template<class T, class Enable = bool> struct asm_rdtscp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','t','s','c','p', str...>, hold<T...>> {
    using value = typename asm_rdtscp<hold<T...>>::value;
};
template <>
struct asm_rdtscp<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xF9>>; };
//  ret ANY [NONE]   [] C3 
template<class T, class Enable = bool> struct asm_ret {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','e','t', str...>, hold<T...>> {
    using value = typename asm_ret<hold<T...>>::value;
};
template <> struct asm_ret<hold<>, bool> { using value = expseq_v<byte_seq<0xC3>>; };
//  ret ANY [I]   [] C2 

template <class T> 
struct asm_ret<hold<T>, typename u16_8<T>::type> {
  using value = expseq_v<byte_seq<0xC2>, typename u16_8<T>::value>;
};
//  retf ANY [NONE]   [] CB 
template<class T, class Enable = bool> struct asm_retf {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','e','t','f', str...>, hold<T...>> {
    using value = typename asm_retf<hold<T...>>::value;
};
template <> struct asm_retf<hold<>, bool> { using value = expseq_v<byte_seq<0xCB>>; };
//  retf ANY [I]   [] CA 

template <class T> 
struct asm_retf<hold<T>, typename u16_8<T>::type> {
  using value = expseq_v<byte_seq<0xCA>, typename u16_8<T>::value>;
};
//  rmpadjust X64 [NONE]   [F3] FE 
template<class T, class Enable = bool> struct asm_rmpadjust {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','m','p','a','d','j','u','s','t', str...>, hold<T...>> {
    using value = typename asm_rmpadjust<hold<T...>>::value;
};
template <> struct asm_rmpadjust<hold<>, bool> { using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x01>, byte_seq<0xFE>>; };
//  rmpupdate X64 [NONE]   [F2] FE 
template<class T, class Enable = bool> struct asm_rmpupdate {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','m','p','u','p','d','a','t','e', str...>, hold<T...>> {
    using value = typename asm_rmpupdate<hold<T...>>::value;
};
template <> struct asm_rmpupdate<hold<>, bool> { using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x01>, byte_seq<0xFE>>; };
//  rol ANY [M] 0  [] D0 
template<class T, class Enable = bool> struct asm_rol {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','o','l', str...>, hold<T...>> {
    using value = typename asm_rol<hold<T...>>::value;
};
template<typename ...T>
struct asm_rol<hold<zip<reg8>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_rol<hold<ptr<reg8, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD0>, mrm_v<hold<reg<0>>, T...>>;
};

//  rol ANY [M] 0  [] D2 

template<typename ...T>
struct asm_rol<hold<zip<reg8>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_rol<hold<ptr<reg8, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD2>, mrm_v<hold<reg<0>>, T...>>;
};

//  rol ANY [MI] 0  [] C0 

template<typename ...T, class Y>
struct asm_rol<hold<ptr<reg8, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC0>, mrm_v<hold<reg<0>>, T...>, typename u8_8<Y>::value>;
};

//  rol ANY [M] 0  [66] D1 

template<typename ...T>
struct asm_rol<hold<zip<reg16>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_rol<hold<ptr<reg16, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<0>>, T...>>;
};

//  rol ANY [M] 0  [66] D3 

template<typename ...T>
struct asm_rol<hold<zip<reg16>::with<T...>, cl>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_rol<hold<ptr<reg16, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<0>>, T...>>;
};

//  rol ANY [MI] 0  [66] C1 

template<typename ...T, class Y>
struct asm_rol<hold<ptr<reg16, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<0>>, T...>, typename u8_8<Y>::value>;
};

//  rol ANY [M] 0  [] D1 

template<typename ...T>
struct asm_rol<hold<zip<reg32>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_rol<hold<ptr<reg32, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<0>>, T...>>;
};

//  rol ANY [M] 0  [] D3 

template<typename ...T>
struct asm_rol<hold<zip<reg32>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_rol<hold<ptr<reg32, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<0>>, T...>>;
};

//  rol ANY [MI] 0  [] C1 

template<typename ...T, class Y>
struct asm_rol<hold<ptr<reg32, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<0>>, T...>, typename u8_8<Y>::value>;
};

//  rol X64 [M] 0  [] D1 

template<typename ...T>
struct asm_rol<hold<zip<reg64>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_rol<hold<ptr<reg64, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<0>>, T...>>;
};

//  rol X64 [M] 0  [] D3 

template<typename ...T>
struct asm_rol<hold<zip<reg64>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_rol<hold<ptr<reg64, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<0>>, T...>>;
};

//  rol X64 [MI] 0  [] C1 

template<typename ...T, class Y>
struct asm_rol<hold<ptr<reg64, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<0>>, T...>, typename u8_8<Y>::value>;
};

//  ror ANY [M] 1  [] D0 
template<class T, class Enable = bool> struct asm_ror {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','o','r', str...>, hold<T...>> {
    using value = typename asm_ror<hold<T...>>::value;
};
template<typename ...T>
struct asm_ror<hold<zip<reg8>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_ror<hold<ptr<reg8, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD0>, mrm_v<hold<reg<1>>, T...>>;
};

//  ror ANY [M] 1  [] D2 

template<typename ...T>
struct asm_ror<hold<zip<reg8>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_ror<hold<ptr<reg8, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD2>, mrm_v<hold<reg<1>>, T...>>;
};

//  ror ANY [MI] 1  [] C0 

template<typename ...T, class Y>
struct asm_ror<hold<ptr<reg8, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC0>, mrm_v<hold<reg<1>>, T...>, typename u8_8<Y>::value>;
};

//  ror ANY [M] 1  [66] D1 

template<typename ...T>
struct asm_ror<hold<zip<reg16>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_ror<hold<ptr<reg16, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<1>>, T...>>;
};

//  ror ANY [M] 1  [66] D3 

template<typename ...T>
struct asm_ror<hold<zip<reg16>::with<T...>, cl>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_ror<hold<ptr<reg16, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<1>>, T...>>;
};

//  ror ANY [MI] 1  [66] C1 

template<typename ...T, class Y>
struct asm_ror<hold<ptr<reg16, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<1>>, T...>, typename u8_8<Y>::value>;
};

//  ror ANY [M] 1  [] D1 

template<typename ...T>
struct asm_ror<hold<zip<reg32>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_ror<hold<ptr<reg32, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<1>>, T...>>;
};

//  ror ANY [M] 1  [] D3 

template<typename ...T>
struct asm_ror<hold<zip<reg32>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_ror<hold<ptr<reg32, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<1>>, T...>>;
};

//  ror ANY [MI] 1  [] C1 

template<typename ...T, class Y>
struct asm_ror<hold<ptr<reg32, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<1>>, T...>, typename u8_8<Y>::value>;
};

//  ror X64 [M] 1  [] D1 

template<typename ...T>
struct asm_ror<hold<zip<reg64>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_ror<hold<ptr<reg64, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<1>>, T...>>;
};

//  ror X64 [M] 1  [] D3 

template<typename ...T>
struct asm_ror<hold<zip<reg64>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_ror<hold<ptr<reg64, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<1>>, T...>>;
};

//  ror X64 [MI] 1  [] C1 

template<typename ...T, class Y>
struct asm_ror<hold<ptr<reg64, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<1>>, T...>, typename u8_8<Y>::value>;
};

//  rorx ANY [RMI] r  [F2] F0 
template<class T, class Enable = bool> struct asm_rorx {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','o','r','x', str...>, hold<T...>> {
    using value = typename asm_rorx<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_rorx<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_rorx<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF0>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  rorx X64 [RMI] r  [F2] F0 

template<typename ...T, typename ...Y, class Z>
struct asm_rorx<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<1>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_rorx<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<1>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF0>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  roundpd ANY [RMI] r  [66] 09 
template<class T, class Enable = bool> struct asm_roundpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','o','u','n','d','p','d', str...>, hold<T...>> {
    using value = typename asm_roundpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_roundpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x09>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_roundpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x09>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  roundps ANY [RMI] r  [66] 08 
template<class T, class Enable = bool> struct asm_roundps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','o','u','n','d','p','s', str...>, hold<T...>> {
    using value = typename asm_roundps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_roundps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x08>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_roundps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x08>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  roundsd ANY [RMI] r  [66] 0B 
template<class T, class Enable = bool> struct asm_roundsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','o','u','n','d','s','d', str...>, hold<T...>> {
    using value = typename asm_roundsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_roundsd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0B>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_roundsd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0B>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  roundss ANY [RMI] r  [66] 0A 
template<class T, class Enable = bool> struct asm_roundss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','o','u','n','d','s','s', str...>, hold<T...>> {
    using value = typename asm_roundss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_roundss<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0A>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_roundss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0A>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  rsm X86 [NONE]   [] AA 
template<class T, class Enable = bool> struct asm_rsm {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','s','m', str...>, hold<T...>> {
    using value = typename asm_rsm<hold<T...>>::value;
};
template <> struct asm_rsm<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0xAA>>; };
//  rsqrtps ANY [RM] r  [] 52 
template<class T, class Enable = bool> struct asm_rsqrtps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','s','q','r','t','p','s', str...>, hold<T...>> {
    using value = typename asm_rsqrtps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_rsqrtps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x52>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_rsqrtps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x52>, mrm_v<hold<T...>, Y...>>;
};

//  rsqrtss ANY [RM] r  [F3] 52 
template<class T, class Enable = bool> struct asm_rsqrtss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','s','q','r','t','s','s', str...>, hold<T...>> {
    using value = typename asm_rsqrtss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_rsqrtss<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x52>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_rsqrtss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x52>, mrm_v<hold<T...>, Y...>>;
};

//  rstorssp ANY [M] 5  [F3] 01 
template<class T, class Enable = bool> struct asm_rstorssp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','s','t','o','r','s','s','p', str...>, hold<T...>> {
    using value = typename asm_rstorssp<hold<T...>>::value;
};
template<typename ...T>
struct asm_rstorssp<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x01>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_rstorssp<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, mrm_v<hold<reg<5>>, T...>>;
};

//  sahf ANY [NONE]   [] 9E 
template<class T, class Enable = bool> struct asm_sahf {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','a','h','f', str...>, hold<T...>> {
    using value = typename asm_sahf<hold<T...>>::value;
};
template <>
struct asm_sahf<hold<>, bool> { using value = expseq_v<byte_seq<0x9E>>; };
//  sal ANY [M] 4  [] D0 
template<class T, class Enable = bool> struct asm_sal {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','a','l', str...>, hold<T...>> {
    using value = typename asm_sal<hold<T...>>::value;
};
template<typename ...T>
struct asm_sal<hold<zip<reg8>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_sal<hold<ptr<reg8, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD0>, mrm_v<hold<reg<4>>, T...>>;
};

//  sal ANY [M] 4  [] D2 

template<typename ...T>
struct asm_sal<hold<zip<reg8>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_sal<hold<ptr<reg8, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD2>, mrm_v<hold<reg<4>>, T...>>;
};

//  sal ANY [MI] 4  [] C0 

template<typename ...T, class Y>
struct asm_sal<hold<ptr<reg8, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC0>, mrm_v<hold<reg<4>>, T...>, typename u8_8<Y>::value>;
};

//  sal ANY [M] 4  [66] D1 

template<typename ...T>
struct asm_sal<hold<zip<reg16>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_sal<hold<ptr<reg16, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<4>>, T...>>;
};

//  sal ANY [M] 4  [66] D3 

template<typename ...T>
struct asm_sal<hold<zip<reg16>::with<T...>, cl>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_sal<hold<ptr<reg16, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<4>>, T...>>;
};

//  sal ANY [MI] 4  [66] C1 

template<typename ...T, class Y>
struct asm_sal<hold<ptr<reg16, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<4>>, T...>, typename u8_8<Y>::value>;
};

//  sal ANY [M] 4  [] D1 

template<typename ...T>
struct asm_sal<hold<zip<reg32>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_sal<hold<ptr<reg32, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<4>>, T...>>;
};

//  sal ANY [M] 4  [] D3 

template<typename ...T>
struct asm_sal<hold<zip<reg32>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_sal<hold<ptr<reg32, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<4>>, T...>>;
};

//  sal ANY [MI] 4  [] C1 

template<typename ...T, class Y>
struct asm_sal<hold<ptr<reg32, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<4>>, T...>, typename u8_8<Y>::value>;
};

//  sal X64 [M] 4  [] D1 

template<typename ...T>
struct asm_sal<hold<zip<reg64>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_sal<hold<ptr<reg64, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<4>>, T...>>;
};

//  sal X64 [M] 4  [] D3 

template<typename ...T>
struct asm_sal<hold<zip<reg64>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_sal<hold<ptr<reg64, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<4>>, T...>>;
};

//  sal X64 [MI] 4  [] C1 

template<typename ...T, class Y>
struct asm_sal<hold<ptr<reg64, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<4>>, T...>, typename u8_8<Y>::value>;
};

//  sar ANY [M] 7  [] D0 
template<class T, class Enable = bool> struct asm_sar {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','a','r', str...>, hold<T...>> {
    using value = typename asm_sar<hold<T...>>::value;
};
template<typename ...T>
struct asm_sar<hold<zip<reg8>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_sar<hold<ptr<reg8, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD0>, mrm_v<hold<reg<7>>, T...>>;
};

//  sar ANY [M] 7  [] D2 

template<typename ...T>
struct asm_sar<hold<zip<reg8>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_sar<hold<ptr<reg8, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD2>, mrm_v<hold<reg<7>>, T...>>;
};

//  sar ANY [MI] 7  [] C0 

template<typename ...T, class Y>
struct asm_sar<hold<ptr<reg8, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC0>, mrm_v<hold<reg<7>>, T...>, typename u8_8<Y>::value>;
};

//  sar ANY [M] 7  [66] D1 

template<typename ...T>
struct asm_sar<hold<zip<reg16>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_sar<hold<ptr<reg16, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<7>>, T...>>;
};

//  sar ANY [M] 7  [66] D3 

template<typename ...T>
struct asm_sar<hold<zip<reg16>::with<T...>, cl>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_sar<hold<ptr<reg16, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<7>>, T...>>;
};

//  sar ANY [MI] 7  [66] C1 

template<typename ...T, class Y>
struct asm_sar<hold<ptr<reg16, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<7>>, T...>, typename u8_8<Y>::value>;
};

//  sar ANY [M] 7  [] D1 

template<typename ...T>
struct asm_sar<hold<zip<reg32>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_sar<hold<ptr<reg32, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<7>>, T...>>;
};

//  sar ANY [M] 7  [] D3 

template<typename ...T>
struct asm_sar<hold<zip<reg32>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_sar<hold<ptr<reg32, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<7>>, T...>>;
};

//  sar ANY [MI] 7  [] C1 

template<typename ...T, class Y>
struct asm_sar<hold<ptr<reg32, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<7>>, T...>, typename u8_8<Y>::value>;
};

//  sar X64 [M] 7  [] D1 

template<typename ...T>
struct asm_sar<hold<zip<reg64>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_sar<hold<ptr<reg64, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<7>>, T...>>;
};

//  sar X64 [M] 7  [] D3 

template<typename ...T>
struct asm_sar<hold<zip<reg64>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_sar<hold<ptr<reg64, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<7>>, T...>>;
};

//  sar X64 [MI] 7  [] C1 

template<typename ...T, class Y>
struct asm_sar<hold<ptr<reg64, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<7>>, T...>, typename u8_8<Y>::value>;
};

//  sarx ANY [RMV] r  [F3] F7 
template<class T, class Enable = bool> struct asm_sarx {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','a','r','x', str...>, hold<T...>> {
    using value = typename asm_sarx<hold<T...>>::value;
};
//  sarx X64 [RMV] r  [F3] F7 

//  saveprevssp ANY [NONE]   [F3] EA 
template<class T, class Enable = bool> struct asm_saveprevssp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','a','v','e','p','r','e','v','s','s','p', str...>, hold<T...>> {
    using value = typename asm_saveprevssp<hold<T...>>::value;
};
template <> struct asm_saveprevssp<hold<>, bool> { using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x01>, byte_seq<0xEA>>; };
//  sbb ANY [I]   [] 1C 
template<class T, class Enable = bool> struct asm_sbb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','b','b', str...>, hold<T...>> {
    using value = typename asm_sbb<hold<T...>>::value;
};
template <class Y> 
struct asm_sbb<hold<al, Y>, typename u8_8<Y>::type>{
  using value = expseq_v<byte_seq<0x1C>, typename u8_8<Y>::value>;
};
//  sbb ANY [I]   [66] 1D 

template <class Y> 
struct asm_sbb<hold<ax, Y>, typename u16_8<Y>::type>{
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x1D>, typename u16_8<Y>::value>;
};
//  sbb ANY [I]   [] 1D 

template <class Y> 
struct asm_sbb<hold<eax, Y>, typename u32_8<Y>::type>{
  using value = expseq_v<byte_seq<0x1D>, typename u32_8<Y>::value>;
};
//  sbb X64 [I]   [] 1D 

template <class Y> 
struct asm_sbb<hold<rax, Y>, typename i32_8<Y>::type>{
  using value = expseq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x1D>, typename i32_8<Y>::value>;
};
//  sbb ANY [MI] 3  [] 80 

template<typename ...T, class Y>
struct asm_sbb<hold<ptr<reg8, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x80>, mrm_v<hold<reg<3>>, T...>, typename u8_8<Y>::value>;
};

//  sbb ANY [MI] 3  [66] 81 

template<typename ...T, class Y>
struct asm_sbb<hold<ptr<reg16, T...>, Y>, typename u16_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<3>>, T...>, typename u16_8<Y>::value>;
};

//  sbb ANY [MI] 3  [] 81 

template<typename ...T, class Y>
struct asm_sbb<hold<ptr<reg32, T...>, Y>, typename u32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<3>>, T...>, typename u32_8<Y>::value>;
};

//  sbb X64 [MI] 3  [] 81 

template<typename ...T, class Y>
struct asm_sbb<hold<ptr<reg64, T...>, Y>, typename i32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<3>>, T...>, typename i32_8<Y>::value>;
};

//  sbb ANY [MI] 3  [66] 83 

template<typename ...T, class Y>
struct asm_sbb<hold<ptr<reg16, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<3>>, T...>, typename i8_8<Y>::value>;
};

//  sbb ANY [MI] 3  [] 83 

template<typename ...T, class Y>
struct asm_sbb<hold<ptr<reg32, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<3>>, T...>, typename i8_8<Y>::value>;
};

//  sbb X64 [MI] 3  [] 83 

template<typename ...T, class Y>
struct asm_sbb<hold<ptr<reg64, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<3>>, T...>, typename i8_8<Y>::value>;
};

//  sbb ANY [MR] r  [] 18 

template<typename ...T, typename ...Y>
struct asm_sbb<hold<ptr<reg8, T...>, zip<reg8>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x18>, mrm_v<hold<Y...>, T...>>;
};

//  sbb ANY [MR] r  [66] 19 

template<typename ...T, typename ...Y>
struct asm_sbb<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x19>, mrm_v<hold<Y...>, T...>>;
};

//  sbb ANY [MR] r  [] 19 

template<typename ...T, typename ...Y>
struct asm_sbb<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x19>, mrm_v<hold<Y...>, T...>>;
};

//  sbb X64 [MR] r  [] 19 

template<typename ...T, typename ...Y>
struct asm_sbb<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x19>, mrm_v<hold<Y...>, T...>>;
};

//  sbb ANY [RM] r  [] 1A 

template<typename ...T, typename ...Y>
struct asm_sbb<hold<zip<reg8>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_sbb<hold<zip<reg8>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1A>, mrm_v<hold<T...>, Y...>>;
};

//  sbb ANY [RM] r  [66] 1B 

template<typename ...T, typename ...Y>
struct asm_sbb<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_sbb<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1B>, mrm_v<hold<T...>, Y...>>;
};

//  sbb ANY [RM] r  [] 1B 

template<typename ...T, typename ...Y>
struct asm_sbb<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_sbb<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1B>, mrm_v<hold<T...>, Y...>>;
};

//  sbb X64 [RM] r  [] 1B 

template<typename ...T, typename ...Y>
struct asm_sbb<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_sbb<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1B>, mrm_v<hold<T...>, Y...>>;
};

//  scasb ANY [NONE]   [] AE 
template<class T, class Enable = bool> struct asm_scasb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','c','a','s','b', str...>, hold<T...>> {
    using value = typename asm_scasb<hold<T...>>::value;
};
template <>
struct asm_scasb<hold<>, bool> { using value = expseq_v<byte_seq<0xAE>>; };
//  scasd ANY [NONE]   [] AF 
template<class T, class Enable = bool> struct asm_scasd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','c','a','s','d', str...>, hold<T...>> {
    using value = typename asm_scasd<hold<T...>>::value;
};
template <>
struct asm_scasd<hold<>, bool> { using value = expseq_v<byte_seq<0xAF>>; };
//  scasq X64 [NONE]   [] AF 
template<class T, class Enable = bool> struct asm_scasq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','c','a','s','q', str...>, hold<T...>> {
    using value = typename asm_scasq<hold<T...>>::value;
};
template <>
struct asm_scasq<hold<>, bool> { using value = expseq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0xAF>>; };
//  scasw ANY [NONE]   [66] AF 
template<class T, class Enable = bool> struct asm_scasw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','c','a','s','w', str...>, hold<T...>> {
    using value = typename asm_scasw<hold<T...>>::value;
};
template <>
struct asm_scasw<hold<>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0xAF>>; };
//  seamcall ANY [NONE]   [66] CF 
template<class T, class Enable = bool> struct asm_seamcall {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','a','m','c','a','l','l', str...>, hold<T...>> {
    using value = typename asm_seamcall<hold<T...>>::value;
};
template <> struct asm_seamcall<hold<>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x01>, byte_seq<0xCF>>; };
//  seamops ANY [NONE]   [66] CE 
template<class T, class Enable = bool> struct asm_seamops {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','a','m','o','p','s', str...>, hold<T...>> {
    using value = typename asm_seamops<hold<T...>>::value;
};
template <> struct asm_seamops<hold<>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x01>, byte_seq<0xCE>>; };
//  seamret ANY [NONE]   [66] CD 
template<class T, class Enable = bool> struct asm_seamret {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','a','m','r','e','t', str...>, hold<T...>> {
    using value = typename asm_seamret<hold<T...>>::value;
};
template <> struct asm_seamret<hold<>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x01>, byte_seq<0xCD>>; };
//  senduipi X64 [R] 6  [F3] C7 
template<class T, class Enable = bool> struct asm_senduipi {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','n','d','u','i','p','i', str...>, hold<T...>> {
    using value = typename asm_senduipi<hold<T...>>::value;
};
//  serialize ANY [NONE]   [] E8 
template<class T, class Enable = bool> struct asm_serialize {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','r','i','a','l','i','z','e', str...>, hold<T...>> {
    using value = typename asm_serialize<hold<T...>>::value;
};
template <> struct asm_serialize<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xE8>>; };
//  seta ANY [M] r  [] 97 
template<class T, class Enable = bool> struct asm_seta {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','a', str...>, hold<T...>> {
    using value = typename asm_seta<hold<T...>>::value;
};
template<typename ...T>
struct asm_seta<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x97>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_seta<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x97>, mrm_v<hold<T...>, T...>>;
};

//  setae ANY [M] r  [] 93 
template<class T, class Enable = bool> struct asm_setae {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','a','e', str...>, hold<T...>> {
    using value = typename asm_setae<hold<T...>>::value;
};
template<typename ...T>
struct asm_setae<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x93>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setae<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x93>, mrm_v<hold<T...>, T...>>;
};

//  setb ANY [M] r  [] 92 
template<class T, class Enable = bool> struct asm_setb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','b', str...>, hold<T...>> {
    using value = typename asm_setb<hold<T...>>::value;
};
template<typename ...T>
struct asm_setb<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x92>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setb<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x92>, mrm_v<hold<T...>, T...>>;
};

//  setbe ANY [M] r  [] 96 
template<class T, class Enable = bool> struct asm_setbe {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','b','e', str...>, hold<T...>> {
    using value = typename asm_setbe<hold<T...>>::value;
};
template<typename ...T>
struct asm_setbe<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x96>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setbe<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x96>, mrm_v<hold<T...>, T...>>;
};

//  setc ANY [M] r  [] 92 
template<class T, class Enable = bool> struct asm_setc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','c', str...>, hold<T...>> {
    using value = typename asm_setc<hold<T...>>::value;
};
template<typename ...T>
struct asm_setc<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x92>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setc<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x92>, mrm_v<hold<T...>, T...>>;
};

//  sete ANY [M] r  [] 94 
template<class T, class Enable = bool> struct asm_sete {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','e', str...>, hold<T...>> {
    using value = typename asm_sete<hold<T...>>::value;
};
template<typename ...T>
struct asm_sete<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x94>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_sete<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x94>, mrm_v<hold<T...>, T...>>;
};

//  setg ANY [M] r  [] 9F 
template<class T, class Enable = bool> struct asm_setg {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','g', str...>, hold<T...>> {
    using value = typename asm_setg<hold<T...>>::value;
};
template<typename ...T>
struct asm_setg<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9F>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setg<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9F>, mrm_v<hold<T...>, T...>>;
};

//  setge ANY [M] r  [] 9D 
template<class T, class Enable = bool> struct asm_setge {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','g','e', str...>, hold<T...>> {
    using value = typename asm_setge<hold<T...>>::value;
};
template<typename ...T>
struct asm_setge<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9D>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setge<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9D>, mrm_v<hold<T...>, T...>>;
};

//  setl ANY [M] r  [] 9C 
template<class T, class Enable = bool> struct asm_setl {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','l', str...>, hold<T...>> {
    using value = typename asm_setl<hold<T...>>::value;
};
template<typename ...T>
struct asm_setl<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9C>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setl<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9C>, mrm_v<hold<T...>, T...>>;
};

//  setle ANY [M] r  [] 9E 
template<class T, class Enable = bool> struct asm_setle {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','l','e', str...>, hold<T...>> {
    using value = typename asm_setle<hold<T...>>::value;
};
template<typename ...T>
struct asm_setle<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9E>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setle<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9E>, mrm_v<hold<T...>, T...>>;
};

//  setna ANY [M] r  [] 96 
template<class T, class Enable = bool> struct asm_setna {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','a', str...>, hold<T...>> {
    using value = typename asm_setna<hold<T...>>::value;
};
template<typename ...T>
struct asm_setna<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x96>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setna<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x96>, mrm_v<hold<T...>, T...>>;
};

//  setnae ANY [M] r  [] 92 
template<class T, class Enable = bool> struct asm_setnae {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','a','e', str...>, hold<T...>> {
    using value = typename asm_setnae<hold<T...>>::value;
};
template<typename ...T>
struct asm_setnae<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x92>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setnae<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x92>, mrm_v<hold<T...>, T...>>;
};

//  setnb ANY [M] r  [] 93 
template<class T, class Enable = bool> struct asm_setnb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','b', str...>, hold<T...>> {
    using value = typename asm_setnb<hold<T...>>::value;
};
template<typename ...T>
struct asm_setnb<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x93>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setnb<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x93>, mrm_v<hold<T...>, T...>>;
};

//  setnbe ANY [M] r  [] 97 
template<class T, class Enable = bool> struct asm_setnbe {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','b','e', str...>, hold<T...>> {
    using value = typename asm_setnbe<hold<T...>>::value;
};
template<typename ...T>
struct asm_setnbe<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x97>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setnbe<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x97>, mrm_v<hold<T...>, T...>>;
};

//  setnc ANY [M] r  [] 93 
template<class T, class Enable = bool> struct asm_setnc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','c', str...>, hold<T...>> {
    using value = typename asm_setnc<hold<T...>>::value;
};
template<typename ...T>
struct asm_setnc<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x93>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setnc<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x93>, mrm_v<hold<T...>, T...>>;
};

//  setne ANY [M] r  [] 95 
template<class T, class Enable = bool> struct asm_setne {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','e', str...>, hold<T...>> {
    using value = typename asm_setne<hold<T...>>::value;
};
template<typename ...T>
struct asm_setne<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x95>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setne<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x95>, mrm_v<hold<T...>, T...>>;
};

//  setng ANY [M] r  [] 9E 
template<class T, class Enable = bool> struct asm_setng {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','g', str...>, hold<T...>> {
    using value = typename asm_setng<hold<T...>>::value;
};
template<typename ...T>
struct asm_setng<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9E>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setng<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9E>, mrm_v<hold<T...>, T...>>;
};

//  setnge ANY [M] r  [] 9C 
template<class T, class Enable = bool> struct asm_setnge {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','g','e', str...>, hold<T...>> {
    using value = typename asm_setnge<hold<T...>>::value;
};
template<typename ...T>
struct asm_setnge<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9C>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setnge<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9C>, mrm_v<hold<T...>, T...>>;
};

//  setnl ANY [M] r  [] 9D 
template<class T, class Enable = bool> struct asm_setnl {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','l', str...>, hold<T...>> {
    using value = typename asm_setnl<hold<T...>>::value;
};
template<typename ...T>
struct asm_setnl<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9D>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setnl<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9D>, mrm_v<hold<T...>, T...>>;
};

//  setnle ANY [M] r  [] 9F 
template<class T, class Enable = bool> struct asm_setnle {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','l','e', str...>, hold<T...>> {
    using value = typename asm_setnle<hold<T...>>::value;
};
template<typename ...T>
struct asm_setnle<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9F>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setnle<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9F>, mrm_v<hold<T...>, T...>>;
};

//  setno ANY [M] r  [] 91 
template<class T, class Enable = bool> struct asm_setno {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','o', str...>, hold<T...>> {
    using value = typename asm_setno<hold<T...>>::value;
};
template<typename ...T>
struct asm_setno<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x91>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setno<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x91>, mrm_v<hold<T...>, T...>>;
};

//  setnp ANY [M] r  [] 9B 
template<class T, class Enable = bool> struct asm_setnp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','p', str...>, hold<T...>> {
    using value = typename asm_setnp<hold<T...>>::value;
};
template<typename ...T>
struct asm_setnp<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9B>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setnp<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9B>, mrm_v<hold<T...>, T...>>;
};

//  setns ANY [M] r  [] 99 
template<class T, class Enable = bool> struct asm_setns {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','s', str...>, hold<T...>> {
    using value = typename asm_setns<hold<T...>>::value;
};
template<typename ...T>
struct asm_setns<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x99>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setns<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x99>, mrm_v<hold<T...>, T...>>;
};

//  setnz ANY [M] r  [] 95 
template<class T, class Enable = bool> struct asm_setnz {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','z', str...>, hold<T...>> {
    using value = typename asm_setnz<hold<T...>>::value;
};
template<typename ...T>
struct asm_setnz<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x95>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setnz<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x95>, mrm_v<hold<T...>, T...>>;
};

//  seto ANY [M] r  [] 90 
template<class T, class Enable = bool> struct asm_seto {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','o', str...>, hold<T...>> {
    using value = typename asm_seto<hold<T...>>::value;
};
template<typename ...T>
struct asm_seto<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x90>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_seto<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x90>, mrm_v<hold<T...>, T...>>;
};

//  setp ANY [M] r  [] 9A 
template<class T, class Enable = bool> struct asm_setp {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','p', str...>, hold<T...>> {
    using value = typename asm_setp<hold<T...>>::value;
};
template<typename ...T>
struct asm_setp<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9A>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setp<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9A>, mrm_v<hold<T...>, T...>>;
};

//  setpe ANY [M] r  [] 9A 
template<class T, class Enable = bool> struct asm_setpe {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','p','e', str...>, hold<T...>> {
    using value = typename asm_setpe<hold<T...>>::value;
};
template<typename ...T>
struct asm_setpe<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9A>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setpe<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9A>, mrm_v<hold<T...>, T...>>;
};

//  setpo ANY [M] r  [] 9B 
template<class T, class Enable = bool> struct asm_setpo {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','p','o', str...>, hold<T...>> {
    using value = typename asm_setpo<hold<T...>>::value;
};
template<typename ...T>
struct asm_setpo<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9B>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setpo<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9B>, mrm_v<hold<T...>, T...>>;
};

//  sets ANY [M] r  [] 98 
template<class T, class Enable = bool> struct asm_sets {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','s', str...>, hold<T...>> {
    using value = typename asm_sets<hold<T...>>::value;
};
template<typename ...T>
struct asm_sets<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x98>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_sets<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x98>, mrm_v<hold<T...>, T...>>;
};

//  setssbsy ANY [NONE]   [F3] E8 
template<class T, class Enable = bool> struct asm_setssbsy {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','s','s','b','s','y', str...>, hold<T...>> {
    using value = typename asm_setssbsy<hold<T...>>::value;
};
template <> struct asm_setssbsy<hold<>, bool> { using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x01>, byte_seq<0xE8>>; };
//  setz ANY [M] r  [] 94 
template<class T, class Enable = bool> struct asm_setz {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','z', str...>, hold<T...>> {
    using value = typename asm_setz<hold<T...>>::value;
};
template<typename ...T>
struct asm_setz<hold<zip<reg8>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x94>, typename modrm<hold<T...>, hold<T...>>::value>;
};

template<typename ...T>
struct asm_setz<hold<ptr<reg8, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x94>, mrm_v<hold<T...>, T...>>;
};

//  sfence ANY [NONE] 7 0 [] F8 
template<class T, class Enable = bool> struct asm_sfence {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','f','e','n','c','e', str...>, hold<T...>> {
    using value = typename asm_sfence<hold<T...>>::value;
};
template <> struct asm_sfence<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0xF8>>; };
//  sgdt ANY [M] 0  [] 01 
template<class T, class Enable = bool> struct asm_sgdt {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','g','d','t', str...>, hold<T...>> {
    using value = typename asm_sgdt<hold<T...>>::value;
};
template<typename ...T>
struct asm_sgdt<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, mrm_v<hold<reg<0>>, T...>>;
};

//  sha1msg1 ANY [RM] r  [] C9 
template<class T, class Enable = bool> struct asm_sha1msg1 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','a','1','m','s','g','1', str...>, hold<T...>> {
    using value = typename asm_sha1msg1<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_sha1msg1<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC9>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_sha1msg1<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC9>, mrm_v<hold<T...>, Y...>>;
};

//  sha1msg2 ANY [RM] r  [] CA 
template<class T, class Enable = bool> struct asm_sha1msg2 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','a','1','m','s','g','2', str...>, hold<T...>> {
    using value = typename asm_sha1msg2<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_sha1msg2<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xCA>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_sha1msg2<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xCA>, mrm_v<hold<T...>, Y...>>;
};

//  sha1nexte ANY [RM] r  [] C8 
template<class T, class Enable = bool> struct asm_sha1nexte {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','a','1','n','e','x','t','e', str...>, hold<T...>> {
    using value = typename asm_sha1nexte<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_sha1nexte<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC8>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_sha1nexte<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC8>, mrm_v<hold<T...>, Y...>>;
};

//  sha1rnds4 ANY [RMI] r  [] CC 
template<class T, class Enable = bool> struct asm_sha1rnds4 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','a','1','r','n','d','s','4', str...>, hold<T...>> {
    using value = typename asm_sha1rnds4<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_sha1rnds4<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xCC>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_sha1rnds4<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xCC>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  sha256msg1 ANY [RM] r  [] CC 
template<class T, class Enable = bool> struct asm_sha256msg1 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','a','2','5','6','m','s','g','1', str...>, hold<T...>> {
    using value = typename asm_sha256msg1<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_sha256msg1<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xCC>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_sha256msg1<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xCC>, mrm_v<hold<T...>, Y...>>;
};

//  sha256msg2 ANY [RM] r  [] CD 
template<class T, class Enable = bool> struct asm_sha256msg2 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','a','2','5','6','m','s','g','2', str...>, hold<T...>> {
    using value = typename asm_sha256msg2<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_sha256msg2<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xCD>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_sha256msg2<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xCD>, mrm_v<hold<T...>, Y...>>;
};

//  sha256rnds2 ANY [RM] r  [] CB 
template<class T, class Enable = bool> struct asm_sha256rnds2 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','a','2','5','6','r','n','d','s','2', str...>, hold<T...>> {
    using value = typename asm_sha256rnds2<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_sha256rnds2<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xCB>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_sha256rnds2<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xCB>, mrm_v<hold<T...>, Y...>>;
};

//  shl ANY [M] 4  [] D0 
template<class T, class Enable = bool> struct asm_shl {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','l', str...>, hold<T...>> {
    using value = typename asm_shl<hold<T...>>::value;
};
template<typename ...T>
struct asm_shl<hold<zip<reg8>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_shl<hold<ptr<reg8, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD0>, mrm_v<hold<reg<4>>, T...>>;
};

//  shl ANY [M] 4  [] D2 

template<typename ...T>
struct asm_shl<hold<zip<reg8>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_shl<hold<ptr<reg8, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD2>, mrm_v<hold<reg<4>>, T...>>;
};

//  shl ANY [MI] 4  [] C0 

template<typename ...T, class Y>
struct asm_shl<hold<ptr<reg8, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC0>, mrm_v<hold<reg<4>>, T...>, typename u8_8<Y>::value>;
};

//  shl ANY [M] 4  [66] D1 

template<typename ...T>
struct asm_shl<hold<zip<reg16>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_shl<hold<ptr<reg16, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<4>>, T...>>;
};

//  shl ANY [M] 4  [66] D3 

template<typename ...T>
struct asm_shl<hold<zip<reg16>::with<T...>, cl>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_shl<hold<ptr<reg16, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<4>>, T...>>;
};

//  shl ANY [MI] 4  [66] C1 

template<typename ...T, class Y>
struct asm_shl<hold<ptr<reg16, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<4>>, T...>, typename u8_8<Y>::value>;
};

//  shl ANY [M] 4  [] D1 

template<typename ...T>
struct asm_shl<hold<zip<reg32>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_shl<hold<ptr<reg32, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<4>>, T...>>;
};

//  shl ANY [M] 4  [] D3 

template<typename ...T>
struct asm_shl<hold<zip<reg32>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_shl<hold<ptr<reg32, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<4>>, T...>>;
};

//  shl ANY [MI] 4  [] C1 

template<typename ...T, class Y>
struct asm_shl<hold<ptr<reg32, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<4>>, T...>, typename u8_8<Y>::value>;
};

//  shl X64 [M] 4  [] D1 

template<typename ...T>
struct asm_shl<hold<zip<reg64>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_shl<hold<ptr<reg64, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<4>>, T...>>;
};

//  shl X64 [M] 4  [] D3 

template<typename ...T>
struct asm_shl<hold<zip<reg64>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_shl<hold<ptr<reg64, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<4>>, T...>>;
};

//  shl X64 [MI] 4  [] C1 

template<typename ...T, class Y>
struct asm_shl<hold<ptr<reg64, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<4>>, T...>, typename u8_8<Y>::value>;
};

//  shld ANY [MR] r  [66] A5 
template<class T, class Enable = bool> struct asm_shld {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','l','d', str...>, hold<T...>> {
    using value = typename asm_shld<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_shld<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xA5>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_shld<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xA5>, mrm_v<hold<Y...>, T...>>;
};

//  shld ANY [MRI] r  [66] A4 

template<typename ...T, typename ...Y, class Z>
struct asm_shld<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xA4>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  shld ANY [MR] r  [] A5 

template<typename ...T, typename ...Y>
struct asm_shld<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xA5>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_shld<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xA5>, mrm_v<hold<Y...>, T...>>;
};

//  shld ANY [MRI] r  [] A4 

template<typename ...T, typename ...Y, class Z>
struct asm_shld<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xA4>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  shld X64 [MR] r  [] A5 

template<typename ...T, typename ...Y>
struct asm_shld<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xA5>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_shld<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xA5>, mrm_v<hold<Y...>, T...>>;
};

//  shld X64 [MRI] r  [] A4 

template<typename ...T, typename ...Y, class Z>
struct asm_shld<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xA4>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  shlx ANY [RMV] r  [66] F7 
template<class T, class Enable = bool> struct asm_shlx {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','l','x', str...>, hold<T...>> {
    using value = typename asm_shlx<hold<T...>>::value;
};
//  shlx X64 [RMV] r  [66] F7 

//  shr ANY [M] 5  [] D0 
template<class T, class Enable = bool> struct asm_shr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','r', str...>, hold<T...>> {
    using value = typename asm_shr<hold<T...>>::value;
};
template<typename ...T>
struct asm_shr<hold<zip<reg8>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_shr<hold<ptr<reg8, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD0>, mrm_v<hold<reg<5>>, T...>>;
};

//  shr ANY [M] 5  [] D2 

template<typename ...T>
struct asm_shr<hold<zip<reg8>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_shr<hold<ptr<reg8, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD2>, mrm_v<hold<reg<5>>, T...>>;
};

//  shr ANY [MI] 5  [] C0 

template<typename ...T, class Y>
struct asm_shr<hold<ptr<reg8, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC0>, mrm_v<hold<reg<5>>, T...>, typename u8_8<Y>::value>;
};

//  shr ANY [M] 5  [66] D1 

template<typename ...T>
struct asm_shr<hold<zip<reg16>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_shr<hold<ptr<reg16, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<5>>, T...>>;
};

//  shr ANY [M] 5  [66] D3 

template<typename ...T>
struct asm_shr<hold<zip<reg16>::with<T...>, cl>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_shr<hold<ptr<reg16, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<5>>, T...>>;
};

//  shr ANY [MI] 5  [66] C1 

template<typename ...T, class Y>
struct asm_shr<hold<ptr<reg16, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<5>>, T...>, typename u8_8<Y>::value>;
};

//  shr ANY [M] 5  [] D1 

template<typename ...T>
struct asm_shr<hold<zip<reg32>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_shr<hold<ptr<reg32, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<5>>, T...>>;
};

//  shr ANY [M] 5  [] D3 

template<typename ...T>
struct asm_shr<hold<zip<reg32>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_shr<hold<ptr<reg32, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<5>>, T...>>;
};

//  shr ANY [MI] 5  [] C1 

template<typename ...T, class Y>
struct asm_shr<hold<ptr<reg32, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<5>>, T...>, typename u8_8<Y>::value>;
};

//  shr X64 [M] 5  [] D1 

template<typename ...T>
struct asm_shr<hold<zip<reg64>::with<T...>, disp8<1>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_shr<hold<ptr<reg64, T...>, disp8<1>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, mrm_v<hold<reg<5>>, T...>>;
};

//  shr X64 [M] 5  [] D3 

template<typename ...T>
struct asm_shr<hold<zip<reg64>::with<T...>, cl>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_shr<hold<ptr<reg64, T...>, cl>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, mrm_v<hold<reg<5>>, T...>>;
};

//  shr X64 [MI] 5  [] C1 

template<typename ...T, class Y>
struct asm_shr<hold<ptr<reg64, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<reg<5>>, T...>, typename u8_8<Y>::value>;
};

//  shrd ANY [MR] r  [66] AD 
template<class T, class Enable = bool> struct asm_shrd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','r','d', str...>, hold<T...>> {
    using value = typename asm_shrd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_shrd<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAD>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_shrd<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAD>, mrm_v<hold<Y...>, T...>>;
};

//  shrd ANY [MRI] r  [66] AC 

template<typename ...T, typename ...Y, class Z>
struct asm_shrd<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAC>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  shrd ANY [MR] r  [] AD 

template<typename ...T, typename ...Y>
struct asm_shrd<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAD>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_shrd<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAD>, mrm_v<hold<Y...>, T...>>;
};

//  shrd ANY [MRI] r  [] AC 

template<typename ...T, typename ...Y, class Z>
struct asm_shrd<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAC>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  shrd X64 [MR] r  [] AD 

template<typename ...T, typename ...Y>
struct asm_shrd<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAD>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_shrd<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAD>, mrm_v<hold<Y...>, T...>>;
};

//  shrd X64 [MRI] r  [] AC 

template<typename ...T, typename ...Y, class Z>
struct asm_shrd<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAC>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  shrx ANY [RMV] r  [F2] F7 
template<class T, class Enable = bool> struct asm_shrx {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','r','x', str...>, hold<T...>> {
    using value = typename asm_shrx<hold<T...>>::value;
};
//  shrx X64 [RMV] r  [F2] F7 

//  shufpd ANY [RMI] r  [66] C6 
template<class T, class Enable = bool> struct asm_shufpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','u','f','p','d', str...>, hold<T...>> {
    using value = typename asm_shufpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_shufpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC6>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_shufpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC6>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  shufps ANY [RMI] r  [] C6 
template<class T, class Enable = bool> struct asm_shufps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','u','f','p','s', str...>, hold<T...>> {
    using value = typename asm_shufps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_shufps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC6>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_shufps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC6>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  sidt ANY [M] 1  [] 01 
template<class T, class Enable = bool> struct asm_sidt {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','i','d','t', str...>, hold<T...>> {
    using value = typename asm_sidt<hold<T...>>::value;
};
template<typename ...T>
struct asm_sidt<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, mrm_v<hold<reg<1>>, T...>>;
};

//  skinit ANY [NONE]   [] DE 
template<class T, class Enable = bool> struct asm_skinit {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','k','i','n','i','t', str...>, hold<T...>> {
    using value = typename asm_skinit<hold<T...>>::value;
};
template <>
struct asm_skinit<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xDE>>; };
//  sldt ANY [M] 0  [66] 00 
template<class T, class Enable = bool> struct asm_sldt {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','l','d','t', str...>, hold<T...>> {
    using value = typename asm_sldt<hold<T...>>::value;
};
template<typename ...T>
struct asm_sldt<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_sldt<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x00>, mrm_v<hold<reg<0>>, T...>>;
};

//  sldt ANY [M] 0  [] 00 

template<typename ...T>
struct asm_sldt<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

//  sldt X64 [M] 0  [] 00 

template<typename ...T>
struct asm_sldt<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

//  slwpcb ANY [M] 1  [] 12 
template<class T, class Enable = bool> struct asm_slwpcb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','l','w','p','c','b', str...>, hold<T...>> {
    using value = typename asm_slwpcb<hold<T...>>::value;
};
template<typename ...T>
struct asm_slwpcb<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<reg<1>>>>, disp8<is_ext_v<hold<T...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

//  slwpcb X64 [M] 1  [] 12 

template<typename ...T>
struct asm_slwpcb<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<reg<1>>>>, disp8<is_ext_v<hold<T...>>>, disp8<0>, disp8<9>, disp8<1>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

//  smsw ANY [M] 4  [66] 01 
template<class T, class Enable = bool> struct asm_smsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','m','s','w', str...>, hold<T...>> {
    using value = typename asm_smsw<hold<T...>>::value;
};
template<typename ...T>
struct asm_smsw<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x01>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_smsw<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, mrm_v<hold<reg<4>>, T...>>;
};

//  smsw ANY [M] 4  [] 01 

template<typename ...T>
struct asm_smsw<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x01>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

//  smsw X64 [M] 4  [] 01 

template<typename ...T>
struct asm_smsw<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x01>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

//  sqrtpd ANY [RM] r  [66] 51 
template<class T, class Enable = bool> struct asm_sqrtpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','q','r','t','p','d', str...>, hold<T...>> {
    using value = typename asm_sqrtpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_sqrtpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x51>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_sqrtpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x51>, mrm_v<hold<T...>, Y...>>;
};

//  sqrtps ANY [RM] r  [] 51 
template<class T, class Enable = bool> struct asm_sqrtps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','q','r','t','p','s', str...>, hold<T...>> {
    using value = typename asm_sqrtps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_sqrtps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x51>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_sqrtps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x51>, mrm_v<hold<T...>, Y...>>;
};

//  sqrtsd ANY [RM] r  [F2] 51 
template<class T, class Enable = bool> struct asm_sqrtsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','q','r','t','s','d', str...>, hold<T...>> {
    using value = typename asm_sqrtsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_sqrtsd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x51>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_sqrtsd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x51>, mrm_v<hold<T...>, Y...>>;
};

//  sqrtss ANY [RM] r  [F3] 51 
template<class T, class Enable = bool> struct asm_sqrtss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','q','r','t','s','s', str...>, hold<T...>> {
    using value = typename asm_sqrtss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_sqrtss<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x51>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_sqrtss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x51>, mrm_v<hold<T...>, Y...>>;
};

//  stac ANY [NONE]   [] CB 
template<class T, class Enable = bool> struct asm_stac {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','a','c', str...>, hold<T...>> {
    using value = typename asm_stac<hold<T...>>::value;
};
template <> struct asm_stac<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xCB>>; };
//  stc ANY [NONE]   [] F9 
template<class T, class Enable = bool> struct asm_stc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','c', str...>, hold<T...>> {
    using value = typename asm_stc<hold<T...>>::value;
};
template <> struct asm_stc<hold<>, bool> { using value = expseq_v<byte_seq<0xF9>>; };
//  std ANY [NONE]   [] FD 
template<class T, class Enable = bool> struct asm_std {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','d', str...>, hold<T...>> {
    using value = typename asm_std<hold<T...>>::value;
};
template <> struct asm_std<hold<>, bool> { using value = expseq_v<byte_seq<0xFD>>; };
//  stgi ANY [NONE]   [] DC 
template<class T, class Enable = bool> struct asm_stgi {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','g','i', str...>, hold<T...>> {
    using value = typename asm_stgi<hold<T...>>::value;
};
template <> struct asm_stgi<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xDC>>; };
//  sti ANY [NONE]   [] FB 
template<class T, class Enable = bool> struct asm_sti {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','i', str...>, hold<T...>> {
    using value = typename asm_sti<hold<T...>>::value;
};
template <> struct asm_sti<hold<>, bool> { using value = expseq_v<byte_seq<0xFB>>; };
//  stmxcsr ANY [M] 3  [] AE 
template<class T, class Enable = bool> struct asm_stmxcsr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','m','x','c','s','r', str...>, hold<T...>> {
    using value = typename asm_stmxcsr<hold<T...>>::value;
};
template<typename ...T>
struct asm_stmxcsr<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_stmxcsr<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, mrm_v<hold<reg<3>>, T...>>;
};

//  stosb ANY [NONE]   [] AA 
template<class T, class Enable = bool> struct asm_stosb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','o','s','b', str...>, hold<T...>> {
    using value = typename asm_stosb<hold<T...>>::value;
};
template <>
struct asm_stosb<hold<>, bool> { using value = expseq_v<byte_seq<0xAA>>; };
//  stosd ANY [NONE]   [] AB 
template<class T, class Enable = bool> struct asm_stosd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','o','s','d', str...>, hold<T...>> {
    using value = typename asm_stosd<hold<T...>>::value;
};
template <>
struct asm_stosd<hold<>, bool> { using value = expseq_v<byte_seq<0xAB>>; };
//  stosq X64 [NONE]   [] AB 
template<class T, class Enable = bool> struct asm_stosq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','o','s','q', str...>, hold<T...>> {
    using value = typename asm_stosq<hold<T...>>::value;
};
template <>
struct asm_stosq<hold<>, bool> { using value = expseq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0xAB>>; };
//  stosw ANY [NONE]   [66] AB 
template<class T, class Enable = bool> struct asm_stosw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','o','s','w', str...>, hold<T...>> {
    using value = typename asm_stosw<hold<T...>>::value;
};
template <>
struct asm_stosw<hold<>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0xAB>>; };
//  str ANY [M] 1  [66] 00 
template<class T, class Enable = bool> struct asm_str {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','r', str...>, hold<T...>> {
    using value = typename asm_str<hold<T...>>::value;
};
template<typename ...T>
struct asm_str<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

template<typename ...T>
struct asm_str<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x00>, mrm_v<hold<reg<1>>, T...>>;
};

//  str ANY [M] 1  [] 00 

template<typename ...T>
struct asm_str<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

//  str X64 [M] 1  [] 00 

template<typename ...T>
struct asm_str<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<1>>>::value>;
};

//  sttilecfg X64 [M] 0  [66] 49 
template<class T, class Enable = bool> struct asm_sttilecfg {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','t','i','l','e','c','f','g', str...>, hold<T...>> {
    using value = typename asm_sttilecfg<hold<T...>>::value;
};
template<typename ...T>
struct asm_sttilecfg<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<0>>>>, disp8<is_ext_v<hold<T...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x49>, typename modrm<hold<T...>, hold<reg<0>>>::value>;
};

template<typename ...T>
struct asm_sttilecfg<hold<ptr<reg512, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<reg<0>>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x49>, mrm_v<hold<reg<0>>, T...>>;
};

//  stui X64 [NONE]   [F3] EF 
template<class T, class Enable = bool> struct asm_stui {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','u','i', str...>, hold<T...>> {
    using value = typename asm_stui<hold<T...>>::value;
};
template <> struct asm_stui<hold<>, bool> { using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x01>, byte_seq<0xEF>>; };
//  sub ANY [I]   [] 2C 
template<class T, class Enable = bool> struct asm_sub {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','u','b', str...>, hold<T...>> {
    using value = typename asm_sub<hold<T...>>::value;
};
template <class Y> 
struct asm_sub<hold<al, Y>, typename u8_8<Y>::type>{
  using value = expseq_v<byte_seq<0x2C>, typename u8_8<Y>::value>;
};
//  sub ANY [I]   [66] 2D 

template <class Y> 
struct asm_sub<hold<ax, Y>, typename u16_8<Y>::type>{
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x2D>, typename u16_8<Y>::value>;
};
//  sub ANY [I]   [] 2D 

template <class Y> 
struct asm_sub<hold<eax, Y>, typename u32_8<Y>::type>{
  using value = expseq_v<byte_seq<0x2D>, typename u32_8<Y>::value>;
};
//  sub X64 [I]   [] 2D 

template <class Y> 
struct asm_sub<hold<rax, Y>, typename i32_8<Y>::type>{
  using value = expseq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x2D>, typename i32_8<Y>::value>;
};
//  sub ANY [MI] 5  [] 80 

template<typename ...T, class Y>
struct asm_sub<hold<ptr<reg8, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x80>, mrm_v<hold<reg<5>>, T...>, typename u8_8<Y>::value>;
};

//  sub ANY [MI] 5  [66] 81 

template<typename ...T, class Y>
struct asm_sub<hold<ptr<reg16, T...>, Y>, typename u16_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<5>>, T...>, typename u16_8<Y>::value>;
};

//  sub ANY [MI] 5  [] 81 

template<typename ...T, class Y>
struct asm_sub<hold<ptr<reg32, T...>, Y>, typename u32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<5>>, T...>, typename u32_8<Y>::value>;
};

//  sub X64 [MI] 5  [] 81 

template<typename ...T, class Y>
struct asm_sub<hold<ptr<reg64, T...>, Y>, typename i32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<5>>, T...>, typename i32_8<Y>::value>;
};

//  sub ANY [MI] 5  [66] 83 

template<typename ...T, class Y>
struct asm_sub<hold<ptr<reg16, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<5>>, T...>, typename i8_8<Y>::value>;
};

//  sub ANY [MI] 5  [] 83 

template<typename ...T, class Y>
struct asm_sub<hold<ptr<reg32, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<5>>, T...>, typename i8_8<Y>::value>;
};

//  sub X64 [MI] 5  [] 83 

template<typename ...T, class Y>
struct asm_sub<hold<ptr<reg64, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<5>>, T...>, typename i8_8<Y>::value>;
};

//  sub ANY [MR] r  [] 28 

template<typename ...T, typename ...Y>
struct asm_sub<hold<ptr<reg8, T...>, zip<reg8>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x28>, mrm_v<hold<Y...>, T...>>;
};

//  sub ANY [MR] r  [66] 29 

template<typename ...T, typename ...Y>
struct asm_sub<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x29>, mrm_v<hold<Y...>, T...>>;
};

//  sub ANY [MR] r  [] 29 

template<typename ...T, typename ...Y>
struct asm_sub<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x29>, mrm_v<hold<Y...>, T...>>;
};

//  sub X64 [MR] r  [] 29 

template<typename ...T, typename ...Y>
struct asm_sub<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x29>, mrm_v<hold<Y...>, T...>>;
};

//  sub ANY [RM] r  [] 2A 

template<typename ...T, typename ...Y>
struct asm_sub<hold<zip<reg8>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_sub<hold<zip<reg8>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2A>, mrm_v<hold<T...>, Y...>>;
};

//  sub ANY [RM] r  [66] 2B 

template<typename ...T, typename ...Y>
struct asm_sub<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_sub<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2B>, mrm_v<hold<T...>, Y...>>;
};

//  sub ANY [RM] r  [] 2B 

template<typename ...T, typename ...Y>
struct asm_sub<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_sub<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2B>, mrm_v<hold<T...>, Y...>>;
};

//  sub X64 [RM] r  [] 2B 

template<typename ...T, typename ...Y>
struct asm_sub<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_sub<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2B>, mrm_v<hold<T...>, Y...>>;
};

//  subpd ANY [RM] r  [66] 5C 
template<class T, class Enable = bool> struct asm_subpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','u','b','p','d', str...>, hold<T...>> {
    using value = typename asm_subpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_subpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_subpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5C>, mrm_v<hold<T...>, Y...>>;
};

//  subps ANY [RM] r  [] 5C 
template<class T, class Enable = bool> struct asm_subps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','u','b','p','s', str...>, hold<T...>> {
    using value = typename asm_subps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_subps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_subps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5C>, mrm_v<hold<T...>, Y...>>;
};

//  subsd ANY [RM] r  [F2] 5C 
template<class T, class Enable = bool> struct asm_subsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','u','b','s','d', str...>, hold<T...>> {
    using value = typename asm_subsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_subsd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_subsd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5C>, mrm_v<hold<T...>, Y...>>;
};

//  subss ANY [RM] r  [F3] 5C 
template<class T, class Enable = bool> struct asm_subss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','u','b','s','s', str...>, hold<T...>> {
    using value = typename asm_subss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_subss<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_subss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5C>, mrm_v<hold<T...>, Y...>>;
};

//  swapgs X64 [NONE]   [] F8 
template<class T, class Enable = bool> struct asm_swapgs {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','w','a','p','g','s', str...>, hold<T...>> {
    using value = typename asm_swapgs<hold<T...>>::value;
};
template <> struct asm_swapgs<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xF8>>; };
//  syscall X64 [NONE]   [] 05 
template<class T, class Enable = bool> struct asm_syscall {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','y','s','c','a','l','l', str...>, hold<T...>> {
    using value = typename asm_syscall<hold<T...>>::value;
};
template <> struct asm_syscall<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x05>>; };
//  sysenter ANY [NONE]   [] 34 
template<class T, class Enable = bool> struct asm_sysenter {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','y','s','e','n','t','e','r', str...>, hold<T...>> {
    using value = typename asm_sysenter<hold<T...>>::value;
};
template <> struct asm_sysenter<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x34>>; };
//  sysexit ANY [NONE]   [] 35 
template<class T, class Enable = bool> struct asm_sysexit {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','y','s','e','x','i','t', str...>, hold<T...>> {
    using value = typename asm_sysexit<hold<T...>>::value;
};
template <> struct asm_sysexit<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x35>>; };
//  sysexitq ANY [NONE]   [] 35 
template<class T, class Enable = bool> struct asm_sysexitq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','y','s','e','x','i','t','q', str...>, hold<T...>> {
    using value = typename asm_sysexitq<hold<T...>>::value;
};
template <> struct asm_sysexitq<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, typename REX<1, 0, 0, 0>::value, byte_seq<0x35>>; };
//  sysret X64 [NONE]   [] 07 
template<class T, class Enable = bool> struct asm_sysret {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','y','s','r','e','t', str...>, hold<T...>> {
    using value = typename asm_sysret<hold<T...>>::value;
};
template <> struct asm_sysret<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x07>>; };
//  sysretq X64 [NONE]   [] 07 
template<class T, class Enable = bool> struct asm_sysretq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','y','s','r','e','t','q', str...>, hold<T...>> {
    using value = typename asm_sysretq<hold<T...>>::value;
};
template <> struct asm_sysretq<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, typename REX<1, 0, 0, 0>::value, byte_seq<0x07>>; };
//  t1mskc ANY [VM] 7  [] 01 
template<class T, class Enable = bool> struct asm_t1mskc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','1','m','s','k','c', str...>, hold<T...>> {
    using value = typename asm_t1mskc<hold<T...>>::value;
};
//  t1mskc X64 [VM] 7  [] 01 

//  tdcall ANY [NONE]   [66] CC 
template<class T, class Enable = bool> struct asm_tdcall {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','d','c','a','l','l', str...>, hold<T...>> {
    using value = typename asm_tdcall<hold<T...>>::value;
};
template <> struct asm_tdcall<hold<>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x01>, byte_seq<0xCC>>; };
//  tdpbf16ps X64 [RMV] r  [F3] 5C 
template<class T, class Enable = bool> struct asm_tdpbf16ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','d','p','b','f','1','6','p','s', str...>, hold<T...>> {
    using value = typename asm_tdpbf16ps<hold<T...>>::value;
};
//  tdpbssd X64 [RMV] r  [F2] 5E 
template<class T, class Enable = bool> struct asm_tdpbssd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','d','p','b','s','s','d', str...>, hold<T...>> {
    using value = typename asm_tdpbssd<hold<T...>>::value;
};
//  tdpbsud X64 [RMV] r  [F3] 5E 
template<class T, class Enable = bool> struct asm_tdpbsud {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','d','p','b','s','u','d', str...>, hold<T...>> {
    using value = typename asm_tdpbsud<hold<T...>>::value;
};
//  tdpbusd X64 [RMV] r  [66] 5E 
template<class T, class Enable = bool> struct asm_tdpbusd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','d','p','b','u','s','d', str...>, hold<T...>> {
    using value = typename asm_tdpbusd<hold<T...>>::value;
};
//  tdpbuud X64 [RMV] r  [] 5E 
template<class T, class Enable = bool> struct asm_tdpbuud {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','d','p','b','u','u','d', str...>, hold<T...>> {
    using value = typename asm_tdpbuud<hold<T...>>::value;
};
//  test ANY [I]   [] A8 
template<class T, class Enable = bool> struct asm_test {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','e','s','t', str...>, hold<T...>> {
    using value = typename asm_test<hold<T...>>::value;
};
template <class Y> 
struct asm_test<hold<al, Y>, typename u8_8<Y>::type>{
  using value = expseq_v<byte_seq<0xA8>, typename u8_8<Y>::value>;
};
//  test ANY [I]   [66] A9 

template <class Y> 
struct asm_test<hold<ax, Y>, typename u16_8<Y>::type>{
  using value = expseq_v<byte_seq<0x66>, byte_seq<0xA9>, typename u16_8<Y>::value>;
};
//  test ANY [I]   [] A9 

template <class Y> 
struct asm_test<hold<eax, Y>, typename u32_8<Y>::type>{
  using value = expseq_v<byte_seq<0xA9>, typename u32_8<Y>::value>;
};
//  test X64 [I]   [] A9 

template <class Y> 
struct asm_test<hold<rax, Y>, typename i32_8<Y>::type>{
  using value = expseq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0xA9>, typename i32_8<Y>::value>;
};
//  test ANY [MI] 0  [] F6 

template<typename ...T, class Y>
struct asm_test<hold<ptr<reg8, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF6>, mrm_v<hold<reg<0>>, T...>, typename u8_8<Y>::value>;
};

//  test ANY [MI] 0  [66] F7 

template<typename ...T, class Y>
struct asm_test<hold<ptr<reg16, T...>, Y>, typename u16_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<0>>, T...>, typename u16_8<Y>::value>;
};

//  test ANY [MI] 0  [] F7 

template<typename ...T, class Y>
struct asm_test<hold<ptr<reg32, T...>, Y>, typename u32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<0>>, T...>, typename u32_8<Y>::value>;
};

//  test X64 [MI] 0  [] F7 

template<typename ...T, class Y>
struct asm_test<hold<ptr<reg64, T...>, Y>, typename i32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF7>, mrm_v<hold<reg<0>>, T...>, typename i32_8<Y>::value>;
};

//  test ANY [MR] r  [] 84 

template<typename ...T, typename ...Y>
struct asm_test<hold<zip<reg8>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x84>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_test<hold<ptr<reg8, T...>, zip<reg8>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x84>, mrm_v<hold<Y...>, T...>>;
};

//  test ANY [MR] r  [66] 85 

template<typename ...T, typename ...Y>
struct asm_test<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x85>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_test<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x85>, mrm_v<hold<Y...>, T...>>;
};

//  test ANY [MR] r  [] 85 

template<typename ...T, typename ...Y>
struct asm_test<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x85>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_test<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x85>, mrm_v<hold<Y...>, T...>>;
};

//  test X64 [MR] r  [] 85 

template<typename ...T, typename ...Y>
struct asm_test<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x85>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_test<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x85>, mrm_v<hold<Y...>, T...>>;
};

//  testui X64 [NONE]   [F3] ED 
template<class T, class Enable = bool> struct asm_testui {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','e','s','t','u','i', str...>, hold<T...>> {
    using value = typename asm_testui<hold<T...>>::value;
};
template <> struct asm_testui<hold<>, bool> { using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x01>, byte_seq<0xED>>; };
//  tileloadd X64 [RM] r  [F2] 4B 
template<class T, class Enable = bool> struct asm_tileloadd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','i','l','e','l','o','a','d','d', str...>, hold<T...>> {
    using value = typename asm_tileloadd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_tileloadd<hold<zip<reg512>::with<T...>, zip<reg1024>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x4B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_tileloadd<hold<zip<reg512>::with<T...>, ptr<reg1024, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x4B>, mrm_v<hold<T...>, Y...>>;
};

//  tileloaddt1 X64 [RM] r  [66] 4B 
template<class T, class Enable = bool> struct asm_tileloaddt1 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','i','l','e','l','o','a','d','d','t','1', str...>, hold<T...>> {
    using value = typename asm_tileloaddt1<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_tileloaddt1<hold<zip<reg512>::with<T...>, zip<reg1024>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x4B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_tileloaddt1<hold<zip<reg512>::with<T...>, ptr<reg1024, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x4B>, mrm_v<hold<T...>, Y...>>;
};

//  tilerelease X64 [NONE] 0  [] 49 
template<class T, class Enable = bool> struct asm_tilerelease {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','i','l','e','r','e','l','e','a','s','e', str...>, hold<T...>> {
    using value = typename asm_tilerelease<hold<T...>>::value;
};
template <> struct asm_tilerelease<hold<>, bool> { using value = expseq_v<typename VEX<disp8<0>, disp8<0>, disp8<0>, disp8<2>, disp8<0>, hold<reg<0>>, disp16<128>, disp8<0>>::value, byte_seq<0x49>>; };
//  tilestored X64 [MR] r  [F3] 4B 
template<class T, class Enable = bool> struct asm_tilestored {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','i','l','e','s','t','o','r','e','d', str...>, hold<T...>> {
    using value = typename asm_tilestored<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_tilestored<hold<zip<reg1024>::with<T...>, zip<reg512>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<is_ext_v<hold<T...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x4B>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_tilestored<hold<ptr<reg1024, T...>, zip<reg512>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x4B>, mrm_v<hold<Y...>, T...>>;
};

//  tilezero X64 [R] r  [F2] 49 
template<class T, class Enable = bool> struct asm_tilezero {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','i','l','e','z','e','r','o', str...>, hold<T...>> {
    using value = typename asm_tilezero<hold<T...>>::value;
};
//  tpause ANY [M] 6  [66] AE 
template<class T, class Enable = bool> struct asm_tpause {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','p','a','u','s','e', str...>, hold<T...>> {
    using value = typename asm_tpause<hold<T...>>::value;
};
template<typename ...T>
struct asm_tpause<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

//  tzcnt ANY [RM] r  [66F3] BC 
template<class T, class Enable = bool> struct asm_tzcnt {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','z','c','n','t', str...>, hold<T...>> {
    using value = typename asm_tzcnt<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_tzcnt<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66, 0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBC>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_tzcnt<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66, 0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBC>, mrm_v<hold<T...>, Y...>>;
};

//  tzcnt ANY [RM] r  [F3] BC 

template<typename ...T, typename ...Y>
struct asm_tzcnt<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBC>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_tzcnt<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBC>, mrm_v<hold<T...>, Y...>>;
};

//  tzcnt X64 [RM] r  [F3] BC 

template<typename ...T, typename ...Y>
struct asm_tzcnt<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBC>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_tzcnt<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBC>, mrm_v<hold<T...>, Y...>>;
};

//  tzmsk ANY [VM] 4  [] 01 
template<class T, class Enable = bool> struct asm_tzmsk {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','z','m','s','k', str...>, hold<T...>> {
    using value = typename asm_tzmsk<hold<T...>>::value;
};
//  tzmsk X64 [VM] 4  [] 01 

//  ucomisd ANY [RM] r  [66] 2E 
template<class T, class Enable = bool> struct asm_ucomisd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','c','o','m','i','s','d', str...>, hold<T...>> {
    using value = typename asm_ucomisd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_ucomisd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_ucomisd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2E>, mrm_v<hold<T...>, Y...>>;
};

//  ucomiss ANY [RM] r  [] 2E 
template<class T, class Enable = bool> struct asm_ucomiss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','c','o','m','i','s','s', str...>, hold<T...>> {
    using value = typename asm_ucomiss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_ucomiss<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_ucomiss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2E>, mrm_v<hold<T...>, Y...>>;
};

//  ud0 ANY [RM] r  [] FF 
template<class T, class Enable = bool> struct asm_ud0 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','d','0', str...>, hold<T...>> {
    using value = typename asm_ud0<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_ud0<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_ud0<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFF>, mrm_v<hold<T...>, Y...>>;
};

//  ud1 ANY [RM] r  [] B9 
template<class T, class Enable = bool> struct asm_ud1 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','d','1', str...>, hold<T...>> {
    using value = typename asm_ud1<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_ud1<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB9>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_ud1<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB9>, mrm_v<hold<T...>, Y...>>;
};

//  ud2 ANY [NONE]   [] 0B 
template<class T, class Enable = bool> struct asm_ud2 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','d','2', str...>, hold<T...>> {
    using value = typename asm_ud2<hold<T...>>::value;
};
template <> struct asm_ud2<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x0B>>; };
//  uiret X64 [NONE]   [F3] EC 
template<class T, class Enable = bool> struct asm_uiret {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','i','r','e','t', str...>, hold<T...>> {
    using value = typename asm_uiret<hold<T...>>::value;
};
template <> struct asm_uiret<hold<>, bool> { using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x01>, byte_seq<0xEC>>; };
//  umonitor ANY [M] 6  [F3] AE 
template<class T, class Enable = bool> struct asm_umonitor {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','m','o','n','i','t','o','r', str...>, hold<T...>> {
    using value = typename asm_umonitor<hold<T...>>::value;
};
template<typename ...T>
struct asm_umonitor<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

//  umonitor X64 [M] 6  [F3] AE 

template<typename ...T>
struct asm_umonitor<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

//  umwait ANY [M] 6  [F2] AE 
template<class T, class Enable = bool> struct asm_umwait {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','m','w','a','i','t', str...>, hold<T...>> {
    using value = typename asm_umwait<hold<T...>>::value;
};
template<typename ...T>
struct asm_umwait<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

//  unpckhpd ANY [RM] r  [66] 15 
template<class T, class Enable = bool> struct asm_unpckhpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','n','p','c','k','h','p','d', str...>, hold<T...>> {
    using value = typename asm_unpckhpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_unpckhpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x15>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_unpckhpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x15>, mrm_v<hold<T...>, Y...>>;
};

//  unpckhps ANY [RM] r  [] 15 
template<class T, class Enable = bool> struct asm_unpckhps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','n','p','c','k','h','p','s', str...>, hold<T...>> {
    using value = typename asm_unpckhps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_unpckhps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x15>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_unpckhps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x15>, mrm_v<hold<T...>, Y...>>;
};

//  unpcklpd ANY [RM] r  [66] 14 
template<class T, class Enable = bool> struct asm_unpcklpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','n','p','c','k','l','p','d', str...>, hold<T...>> {
    using value = typename asm_unpcklpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_unpcklpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x14>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_unpcklpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x14>, mrm_v<hold<T...>, Y...>>;
};

//  unpcklps ANY [RM] r  [] 14 
template<class T, class Enable = bool> struct asm_unpcklps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','n','p','c','k','l','p','s', str...>, hold<T...>> {
    using value = typename asm_unpcklps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_unpcklps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x14>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_unpcklps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x14>, mrm_v<hold<T...>, Y...>>;
};

//  vaddpd ANY [RVM] r  [66] 58 
template<class T, class Enable = bool> struct asm_vaddpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','d','d','p','d', str...>, hold<T...>> {
    using value = typename asm_vaddpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x58>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x58>, mrm_v<hold<T...>, Z...>>;
};

//  vaddpd ANY [RVM] r  [66] 58 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x58>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x58>, mrm_v<hold<T...>, Z...>>;
};

//  vaddps ANY [RVM] r  [] 58 
template<class T, class Enable = bool> struct asm_vaddps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','d','d','p','s', str...>, hold<T...>> {
    using value = typename asm_vaddps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x58>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x58>, mrm_v<hold<T...>, Z...>>;
};

//  vaddps ANY [RVM] r  [] 58 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x58>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x58>, mrm_v<hold<T...>, Z...>>;
};

//  vaddsd ANY [RVM] r  [F2] 58 
template<class T, class Enable = bool> struct asm_vaddsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','d','d','s','d', str...>, hold<T...>> {
    using value = typename asm_vaddsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x58>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x58>, mrm_v<hold<T...>, Z...>>;
};

//  vaddss ANY [RVM] r  [F3] 58 
template<class T, class Enable = bool> struct asm_vaddss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','d','d','s','s', str...>, hold<T...>> {
    using value = typename asm_vaddss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x58>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x58>, mrm_v<hold<T...>, Z...>>;
};

//  vaddsubpd ANY [RVM] r  [66] D0 
template<class T, class Enable = bool> struct asm_vaddsubpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','d','d','s','u','b','p','d', str...>, hold<T...>> {
    using value = typename asm_vaddsubpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddsubpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD0>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddsubpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD0>, mrm_v<hold<T...>, Z...>>;
};

//  vaddsubpd ANY [RVM] r  [66] D0 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddsubpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD0>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddsubpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD0>, mrm_v<hold<T...>, Z...>>;
};

//  vaddsubps ANY [RVM] r  [F2] D0 
template<class T, class Enable = bool> struct asm_vaddsubps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','d','d','s','u','b','p','s', str...>, hold<T...>> {
    using value = typename asm_vaddsubps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddsubps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xD0>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddsubps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xD0>, mrm_v<hold<T...>, Z...>>;
};

//  vaddsubps ANY [RVM] r  [F2] D0 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddsubps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0xD0>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaddsubps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0xD0>, mrm_v<hold<T...>, Z...>>;
};

//  vaesdec ANY [RVM] r  [66] DE 
template<class T, class Enable = bool> struct asm_vaesdec {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','e','s','d','e','c', str...>, hold<T...>> {
    using value = typename asm_vaesdec<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaesdec<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDE>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaesdec<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDE>, mrm_v<hold<T...>, Z...>>;
};

//  vaesdec ANY [RVM] r  [66] DE 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaesdec<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDE>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaesdec<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDE>, mrm_v<hold<T...>, Z...>>;
};

//  vaesdeclast ANY [RVM] r  [66] DF 
template<class T, class Enable = bool> struct asm_vaesdeclast {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','e','s','d','e','c','l','a','s','t', str...>, hold<T...>> {
    using value = typename asm_vaesdeclast<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaesdeclast<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDF>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaesdeclast<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDF>, mrm_v<hold<T...>, Z...>>;
};

//  vaesdeclast ANY [RVM] r  [66] DF 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaesdeclast<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDF>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaesdeclast<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDF>, mrm_v<hold<T...>, Z...>>;
};

//  vaesenc ANY [RVM] r  [66] DC 
template<class T, class Enable = bool> struct asm_vaesenc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','e','s','e','n','c', str...>, hold<T...>> {
    using value = typename asm_vaesenc<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaesenc<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDC>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaesenc<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDC>, mrm_v<hold<T...>, Z...>>;
};

//  vaesenc ANY [RVM] r  [66] DC 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaesenc<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDC>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaesenc<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDC>, mrm_v<hold<T...>, Z...>>;
};

//  vaesenclast ANY [RVM] r  [66] DD 
template<class T, class Enable = bool> struct asm_vaesenclast {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','e','s','e','n','c','l','a','s','t', str...>, hold<T...>> {
    using value = typename asm_vaesenclast<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaesenclast<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDD>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaesenclast<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDD>, mrm_v<hold<T...>, Z...>>;
};

//  vaesenclast ANY [RVM] r  [66] DD 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaesenclast<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDD>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vaesenclast<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDD>, mrm_v<hold<T...>, Z...>>;
};

//  vandnpd ANY [RVM] r  [66] 55 
template<class T, class Enable = bool> struct asm_vandnpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','n','d','n','p','d', str...>, hold<T...>> {
    using value = typename asm_vandnpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vandnpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x55>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vandnpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x55>, mrm_v<hold<T...>, Z...>>;
};

//  vandnpd ANY [RVM] r  [66] 55 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vandnpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x55>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vandnpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x55>, mrm_v<hold<T...>, Z...>>;
};

//  vandnps ANY [RVM] r  [] 55 
template<class T, class Enable = bool> struct asm_vandnps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','n','d','n','p','s', str...>, hold<T...>> {
    using value = typename asm_vandnps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vandnps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x55>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vandnps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x55>, mrm_v<hold<T...>, Z...>>;
};

//  vandnps ANY [RVM] r  [] 55 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vandnps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x55>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vandnps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x55>, mrm_v<hold<T...>, Z...>>;
};

//  vandpd ANY [RVM] r  [66] 54 
template<class T, class Enable = bool> struct asm_vandpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','n','d','p','d', str...>, hold<T...>> {
    using value = typename asm_vandpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vandpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x54>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vandpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x54>, mrm_v<hold<T...>, Z...>>;
};

//  vandpd ANY [RVM] r  [66] 54 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vandpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x54>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vandpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x54>, mrm_v<hold<T...>, Z...>>;
};

//  vandps ANY [RVM] r  [] 54 
template<class T, class Enable = bool> struct asm_vandps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','n','d','p','s', str...>, hold<T...>> {
    using value = typename asm_vandps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vandps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x54>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vandps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x54>, mrm_v<hold<T...>, Z...>>;
};

//  vandps ANY [RVM] r  [] 54 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vandps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x54>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vandps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x54>, mrm_v<hold<T...>, Z...>>;
};

//  vblendpd ANY [RVMI] r  [66] 0D 
template<class T, class Enable = bool> struct asm_vblendpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','b','l','e','n','d','p','d', str...>, hold<T...>> {
    using value = typename asm_vblendpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vblendpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0D>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vblendpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0D>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vblendpd ANY [RVMI] r  [66] 0D 

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vblendpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0D>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vblendpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0D>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vblendps ANY [RVMI] r  [66] 0C 
template<class T, class Enable = bool> struct asm_vblendps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','b','l','e','n','d','p','s', str...>, hold<T...>> {
    using value = typename asm_vblendps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vblendps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0C>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vblendps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0C>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vblendps ANY [RVMI] r  [66] 0C 

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vblendps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0C>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vblendps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0C>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vblendvpd ANY [RVMS] r  [66] 4B 
template<class T, class Enable = bool> struct asm_vblendvpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','b','l','e','n','d','v','p','d', str...>, hold<T...>> {
    using value = typename asm_vblendvpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vblendvpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x4B>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vblendvpd ANY [RVMS] r  [66] 4B 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vblendvpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x4B>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vblendvps ANY [RVMS] r  [66] 4A 
template<class T, class Enable = bool> struct asm_vblendvps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','b','l','e','n','d','v','p','s', str...>, hold<T...>> {
    using value = typename asm_vblendvps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vblendvps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x4A>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vblendvps ANY [RVMS] r  [66] 4A 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vblendvps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x4A>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vbroadcastf128 ANY [RM] r  [66] 1A 
template<class T, class Enable = bool> struct asm_vbroadcastf128 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','b','r','o','a','d','c','a','s','t','f','1','2','8', str...>, hold<T...>> {
    using value = typename asm_vbroadcastf128<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vbroadcastf128<hold<zip<reg256>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x1A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vbroadcastf128<hold<zip<reg256>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x1A>, mrm_v<hold<T...>, Y...>>;
};

//  vbroadcasti128 ANY [RM] r  [66] 5A 
template<class T, class Enable = bool> struct asm_vbroadcasti128 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','b','r','o','a','d','c','a','s','t','i','1','2','8', str...>, hold<T...>> {
    using value = typename asm_vbroadcasti128<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vbroadcasti128<hold<zip<reg256>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vbroadcasti128<hold<zip<reg256>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5A>, mrm_v<hold<T...>, Y...>>;
};

//  vbroadcastsd ANY [RM] r  [66] 19 
template<class T, class Enable = bool> struct asm_vbroadcastsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','b','r','o','a','d','c','a','s','t','s','d', str...>, hold<T...>> {
    using value = typename asm_vbroadcastsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vbroadcastsd<hold<zip<reg256>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x19>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vbroadcastsd<hold<zip<reg256>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x19>, mrm_v<hold<T...>, Y...>>;
};

//  vbroadcastsd ANY [RM] r  [66] 19 

template<typename ...T, typename ...Y>
struct asm_vbroadcastsd<hold<zip<reg256>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x19>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  vbroadcastss ANY [RM] r  [66] 18 
template<class T, class Enable = bool> struct asm_vbroadcastss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','b','r','o','a','d','c','a','s','t','s','s', str...>, hold<T...>> {
    using value = typename asm_vbroadcastss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vbroadcastss<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x18>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vbroadcastss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x18>, mrm_v<hold<T...>, Y...>>;
};

//  vbroadcastss ANY [RM] r  [66] 18 

template<typename ...T, typename ...Y>
struct asm_vbroadcastss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x18>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  vbroadcastss ANY [RM] r  [66] 18 

template<typename ...T, typename ...Y>
struct asm_vbroadcastss<hold<zip<reg256>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x18>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vbroadcastss<hold<zip<reg256>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x18>, mrm_v<hold<T...>, Y...>>;
};

//  vbroadcastss ANY [RM] r  [66] 18 

template<typename ...T, typename ...Y>
struct asm_vbroadcastss<hold<zip<reg256>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x18>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  vcmppd ANY [RVMI] r  [66] C2 
template<class T, class Enable = bool> struct asm_vcmppd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','m','p','p','d', str...>, hold<T...>> {
    using value = typename asm_vcmppd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vcmppd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xC2>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vcmppd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xC2>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vcmppd ANY [RVMI] r  [66] C2 

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vcmppd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xC2>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vcmppd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xC2>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vcmpps ANY [RVMI] r  [] C2 
template<class T, class Enable = bool> struct asm_vcmpps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','m','p','p','s', str...>, hold<T...>> {
    using value = typename asm_vcmpps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vcmpps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xC2>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vcmpps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xC2>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vcmpps ANY [RVMI] r  [] C2 

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vcmpps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0xC2>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vcmpps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0xC2>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vcmpsd ANY [RVMI] r  [F2] C2 
template<class T, class Enable = bool> struct asm_vcmpsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','m','p','s','d', str...>, hold<T...>> {
    using value = typename asm_vcmpsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vcmpsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0xC2>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vcmpsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0xC2>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vcmpss ANY [RVMI] r  [F3] C2 
template<class T, class Enable = bool> struct asm_vcmpss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','m','p','s','s', str...>, hold<T...>> {
    using value = typename asm_vcmpss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vcmpss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0xC2>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vcmpss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0xC2>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vcomisd ANY [RM] r  [66] 2F 
template<class T, class Enable = bool> struct asm_vcomisd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','o','m','i','s','d', str...>, hold<T...>> {
    using value = typename asm_vcomisd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vcomisd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x2F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcomisd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x2F>, mrm_v<hold<T...>, Y...>>;
};

//  vcomiss ANY [RM] r  [] 2F 
template<class T, class Enable = bool> struct asm_vcomiss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','o','m','i','s','s', str...>, hold<T...>> {
    using value = typename asm_vcomiss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vcomiss<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0>>::value, byte_seq<0x2F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcomiss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0>>::value, byte_seq<0x2F>, mrm_v<hold<T...>, Y...>>;
};

//  vcvtdq2pd ANY [RM] r  [F3] E6 
template<class T, class Enable = bool> struct asm_vcvtdq2pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','d','q','2','p','d', str...>, hold<T...>> {
    using value = typename asm_vcvtdq2pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vcvtdq2pd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0xE6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvtdq2pd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0xE6>, mrm_v<hold<T...>, Y...>>;
};

//  vcvtdq2pd ANY [RM] r  [F3] E6 

template<typename ...T, typename ...Y>
struct asm_vcvtdq2pd<hold<zip<reg256>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0xE6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvtdq2pd<hold<zip<reg256>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0xE6>, mrm_v<hold<T...>, Y...>>;
};

//  vcvtdq2ps ANY [RM] r  [] 5B 
template<class T, class Enable = bool> struct asm_vcvtdq2ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','d','q','2','p','s', str...>, hold<T...>> {
    using value = typename asm_vcvtdq2ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vcvtdq2ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x5B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvtdq2ps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x5B>, mrm_v<hold<T...>, Y...>>;
};

//  vcvtdq2ps ANY [RM] r  [] 5B 

template<typename ...T, typename ...Y>
struct asm_vcvtdq2ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x5B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvtdq2ps<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x5B>, mrm_v<hold<T...>, Y...>>;
};

//  vcvtpd2dq ANY [RM] r  [F2] E6 
template<class T, class Enable = bool> struct asm_vcvtpd2dq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','p','d','2','d','q', str...>, hold<T...>> {
    using value = typename asm_vcvtpd2dq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vcvtpd2dq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xE6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvtpd2dq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xE6>, mrm_v<hold<T...>, Y...>>;
};

//  vcvtpd2dq ANY [RM] r  [F2] E6 

template<typename ...T, typename ...Y>
struct asm_vcvtpd2dq<hold<zip<reg128>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0xE6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvtpd2dq<hold<zip<reg128>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0xE6>, mrm_v<hold<T...>, Y...>>;
};

//  vcvtpd2ps ANY [RM] r  [66] 5A 
template<class T, class Enable = bool> struct asm_vcvtpd2ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','p','d','2','p','s', str...>, hold<T...>> {
    using value = typename asm_vcvtpd2ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vcvtpd2ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvtpd2ps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5A>, mrm_v<hold<T...>, Y...>>;
};

//  vcvtpd2ps ANY [RM] r  [66] 5A 

template<typename ...T, typename ...Y>
struct asm_vcvtpd2ps<hold<zip<reg128>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvtpd2ps<hold<zip<reg128>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5A>, mrm_v<hold<T...>, Y...>>;
};

//  vcvtph2ps ANY [RM] r  [66] 13 
template<class T, class Enable = bool> struct asm_vcvtph2ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','p','h','2','p','s', str...>, hold<T...>> {
    using value = typename asm_vcvtph2ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vcvtph2ps<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x13>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvtph2ps<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x13>, mrm_v<hold<T...>, Y...>>;
};

//  vcvtph2ps ANY [RM] r  [66] 13 

template<typename ...T, typename ...Y>
struct asm_vcvtph2ps<hold<zip<reg256>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x13>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvtph2ps<hold<zip<reg256>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x13>, mrm_v<hold<T...>, Y...>>;
};

//  vcvtps2dq ANY [RM] r  [66] 5B 
template<class T, class Enable = bool> struct asm_vcvtps2dq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','p','s','2','d','q', str...>, hold<T...>> {
    using value = typename asm_vcvtps2dq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vcvtps2dq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvtps2dq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5B>, mrm_v<hold<T...>, Y...>>;
};

//  vcvtps2dq ANY [RM] r  [66] 5B 

template<typename ...T, typename ...Y>
struct asm_vcvtps2dq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvtps2dq<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5B>, mrm_v<hold<T...>, Y...>>;
};

//  vcvtps2pd ANY [RM] r  [] 5A 
template<class T, class Enable = bool> struct asm_vcvtps2pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','p','s','2','p','d', str...>, hold<T...>> {
    using value = typename asm_vcvtps2pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vcvtps2pd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x5A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvtps2pd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x5A>, mrm_v<hold<T...>, Y...>>;
};

//  vcvtps2pd ANY [RM] r  [] 5A 

template<typename ...T, typename ...Y>
struct asm_vcvtps2pd<hold<zip<reg256>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x5A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvtps2pd<hold<zip<reg256>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x5A>, mrm_v<hold<T...>, Y...>>;
};

//  vcvtps2ph ANY [MRI] r  [66] 1D 
template<class T, class Enable = bool> struct asm_vcvtps2ph {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','p','s','2','p','h', str...>, hold<T...>> {
    using value = typename asm_vcvtps2ph<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vcvtps2ph<hold<ptr<reg64, T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x1D>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  vcvtps2ph ANY [MRI] r  [66] 1D 

template<typename ...T, typename ...Y, class Z>
struct asm_vcvtps2ph<hold<ptr<reg128, T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x1D>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  vcvtsd2si ANY [RM] r  [F2] 2D 
template<class T, class Enable = bool> struct asm_vcvtsd2si {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','s','d','2','s','i', str...>, hold<T...>> {
    using value = typename asm_vcvtsd2si<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vcvtsd2si<hold<zip<reg32>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<0>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvtsd2si<hold<zip<reg32>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<1>, disp8<0>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2D>, mrm_v<hold<T...>, Y...>>;
};

//  vcvtsd2si X64 [RM] r  [F2] 2D 

template<typename ...T, typename ...Y>
struct asm_vcvtsd2si<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<1>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvtsd2si<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<1>, disp8<1>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2D>, mrm_v<hold<T...>, Y...>>;
};

//  vcvtsd2ss ANY [RVM] r  [F2] 5A 
template<class T, class Enable = bool> struct asm_vcvtsd2ss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','s','d','2','s','s', str...>, hold<T...>> {
    using value = typename asm_vcvtsd2ss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vcvtsd2ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5A>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vcvtsd2ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5A>, mrm_v<hold<T...>, Z...>>;
};

//  vcvtsi2sd ANY [RVM] r  [F2] 2A 
template<class T, class Enable = bool> struct asm_vcvtsi2sd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','s','i','2','s','d', str...>, hold<T...>> {
    using value = typename asm_vcvtsi2sd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vcvtsi2sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<1>, disp8<0>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2A>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vcvtsi2sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<1>, disp8<0>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2A>, mrm_v<hold<T...>, Z...>>;
};

//  vcvtsi2sd X64 [RVM] r  [F2] 2A 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vcvtsi2sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<1>, disp8<1>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2A>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vcvtsi2sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<1>, disp8<1>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2A>, mrm_v<hold<T...>, Z...>>;
};

//  vcvtsi2ss ANY [RVM] r  [F3] 2A 
template<class T, class Enable = bool> struct asm_vcvtsi2ss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','s','i','2','s','s', str...>, hold<T...>> {
    using value = typename asm_vcvtsi2ss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vcvtsi2ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<1>, disp8<0>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2A>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vcvtsi2ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<1>, disp8<0>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2A>, mrm_v<hold<T...>, Z...>>;
};

//  vcvtsi2ss X64 [RVM] r  [F3] 2A 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vcvtsi2ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<1>, disp8<1>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2A>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vcvtsi2ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<1>, disp8<1>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2A>, mrm_v<hold<T...>, Z...>>;
};

//  vcvtss2sd ANY [RVM] r  [F3] 5A 
template<class T, class Enable = bool> struct asm_vcvtss2sd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','s','s','2','s','d', str...>, hold<T...>> {
    using value = typename asm_vcvtss2sd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vcvtss2sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5A>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vcvtss2sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5A>, mrm_v<hold<T...>, Z...>>;
};

//  vcvtss2si ANY [RM] r  [F3] 2D 
template<class T, class Enable = bool> struct asm_vcvtss2si {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','s','s','2','s','i', str...>, hold<T...>> {
    using value = typename asm_vcvtss2si<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vcvtss2si<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<0>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvtss2si<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<1>, disp8<0>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2D>, mrm_v<hold<T...>, Y...>>;
};

//  vcvtss2si X64 [RM] r  [F3] 2D 

template<typename ...T, typename ...Y>
struct asm_vcvtss2si<hold<zip<reg64>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<1>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvtss2si<hold<zip<reg64>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<1>, disp8<1>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2D>, mrm_v<hold<T...>, Y...>>;
};

//  vcvttpd2dq ANY [RM] r  [66] E6 
template<class T, class Enable = bool> struct asm_vcvttpd2dq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','t','p','d','2','d','q', str...>, hold<T...>> {
    using value = typename asm_vcvttpd2dq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vcvttpd2dq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvttpd2dq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE6>, mrm_v<hold<T...>, Y...>>;
};

//  vcvttpd2dq ANY [RM] r  [66] E6 

template<typename ...T, typename ...Y>
struct asm_vcvttpd2dq<hold<zip<reg128>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvttpd2dq<hold<zip<reg128>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE6>, mrm_v<hold<T...>, Y...>>;
};

//  vcvttps2dq ANY [RM] r  [F3] 5B 
template<class T, class Enable = bool> struct asm_vcvttps2dq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','t','p','s','2','d','q', str...>, hold<T...>> {
    using value = typename asm_vcvttps2dq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vcvttps2dq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x5B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvttps2dq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x5B>, mrm_v<hold<T...>, Y...>>;
};

//  vcvttps2dq ANY [RM] r  [F3] 5B 

template<typename ...T, typename ...Y>
struct asm_vcvttps2dq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x5B>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvttps2dq<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x5B>, mrm_v<hold<T...>, Y...>>;
};

//  vcvttsd2si ANY [RM] r  [F2] 2C 
template<class T, class Enable = bool> struct asm_vcvttsd2si {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','t','s','d','2','s','i', str...>, hold<T...>> {
    using value = typename asm_vcvttsd2si<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vcvttsd2si<hold<zip<reg32>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<0>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvttsd2si<hold<zip<reg32>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<1>, disp8<0>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2C>, mrm_v<hold<T...>, Y...>>;
};

//  vcvttsd2si X64 [RM] r  [F2] 2C 

template<typename ...T, typename ...Y>
struct asm_vcvttsd2si<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<1>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvttsd2si<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<1>, disp8<1>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2C>, mrm_v<hold<T...>, Y...>>;
};

//  vcvttss2si ANY [RM] r  [F3] 2C 
template<class T, class Enable = bool> struct asm_vcvttss2si {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','t','s','s','2','s','i', str...>, hold<T...>> {
    using value = typename asm_vcvttss2si<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vcvttss2si<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<0>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvttss2si<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<1>, disp8<0>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2C>, mrm_v<hold<T...>, Y...>>;
};

//  vcvttss2si X64 [RM] r  [F3] 2C 

template<typename ...T, typename ...Y>
struct asm_vcvttss2si<hold<zip<reg64>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<1>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vcvttss2si<hold<zip<reg64>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<1>, disp8<1>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2C>, mrm_v<hold<T...>, Y...>>;
};

//  vdivpd ANY [RVM] r  [66] 5E 
template<class T, class Enable = bool> struct asm_vdivpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','d','i','v','p','d', str...>, hold<T...>> {
    using value = typename asm_vdivpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vdivpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5E>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vdivpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5E>, mrm_v<hold<T...>, Z...>>;
};

//  vdivpd ANY [RVM] r  [66] 5E 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vdivpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5E>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vdivpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5E>, mrm_v<hold<T...>, Z...>>;
};

//  vdivps ANY [RVM] r  [] 5E 
template<class T, class Enable = bool> struct asm_vdivps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','d','i','v','p','s', str...>, hold<T...>> {
    using value = typename asm_vdivps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vdivps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x5E>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vdivps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x5E>, mrm_v<hold<T...>, Z...>>;
};

//  vdivps ANY [RVM] r  [] 5E 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vdivps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x5E>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vdivps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x5E>, mrm_v<hold<T...>, Z...>>;
};

//  vdivsd ANY [RVM] r  [F2] 5E 
template<class T, class Enable = bool> struct asm_vdivsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','d','i','v','s','d', str...>, hold<T...>> {
    using value = typename asm_vdivsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vdivsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5E>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vdivsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5E>, mrm_v<hold<T...>, Z...>>;
};

//  vdivss ANY [RVM] r  [F3] 5E 
template<class T, class Enable = bool> struct asm_vdivss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','d','i','v','s','s', str...>, hold<T...>> {
    using value = typename asm_vdivss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vdivss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5E>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vdivss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5E>, mrm_v<hold<T...>, Z...>>;
};

//  vdppd ANY [RVMI] r  [66] 41 
template<class T, class Enable = bool> struct asm_vdppd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','d','p','p','d', str...>, hold<T...>> {
    using value = typename asm_vdppd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vdppd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x41>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vdppd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x41>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vdpps ANY [RVMI] r  [66] 40 
template<class T, class Enable = bool> struct asm_vdpps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','d','p','p','s', str...>, hold<T...>> {
    using value = typename asm_vdpps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vdpps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x40>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vdpps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x40>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vdpps ANY [RVMI] r  [66] 40 

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vdpps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x40>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vdpps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x40>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  verr ANY [M] 4  [] 00 
template<class T, class Enable = bool> struct asm_verr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','e','r','r', str...>, hold<T...>> {
    using value = typename asm_verr<hold<T...>>::value;
};
template<typename ...T>
struct asm_verr<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<4>>>::value>;
};

template<typename ...T>
struct asm_verr<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x00>, mrm_v<hold<reg<4>>, T...>>;
};

//  verw ANY [M] 5  [] 00 
template<class T, class Enable = bool> struct asm_verw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','e','r','w', str...>, hold<T...>> {
    using value = typename asm_verw<hold<T...>>::value;
};
template<typename ...T>
struct asm_verw<hold<zip<reg16>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<5>>>::value>;
};

template<typename ...T>
struct asm_verw<hold<ptr<reg16, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x00>, mrm_v<hold<reg<5>>, T...>>;
};

//  vextractf128 ANY [MRI] r  [66] 19 
template<class T, class Enable = bool> struct asm_vextractf128 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','e','x','t','r','a','c','t','f','1','2','8', str...>, hold<T...>> {
    using value = typename asm_vextractf128<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vextractf128<hold<ptr<reg128, T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x19>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  vextracti128 ANY [MRI] r  [66] 39 
template<class T, class Enable = bool> struct asm_vextracti128 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','e','x','t','r','a','c','t','i','1','2','8', str...>, hold<T...>> {
    using value = typename asm_vextracti128<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vextracti128<hold<ptr<reg128, T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x39>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  vextractps ANY [MRI] r  [66] 17 
template<class T, class Enable = bool> struct asm_vextractps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','e','x','t','r','a','c','t','p','s', str...>, hold<T...>> {
    using value = typename asm_vextractps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vextractps<hold<ptr<reg32, T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x17>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  vfmadd132pd ANY [RVM] r  [66] 98 
template<class T, class Enable = bool> struct asm_vfmadd132pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','1','3','2','p','d', str...>, hold<T...>> {
    using value = typename asm_vfmadd132pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd132pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x98>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd132pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x98>, mrm_v<hold<T...>, Z...>>;
};

//  vfmadd132pd ANY [RVM] r  [66] 98 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd132pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x98>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd132pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x98>, mrm_v<hold<T...>, Z...>>;
};

//  vfmadd132ps ANY [RVM] r  [66] 98 
template<class T, class Enable = bool> struct asm_vfmadd132ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','1','3','2','p','s', str...>, hold<T...>> {
    using value = typename asm_vfmadd132ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd132ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x98>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd132ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x98>, mrm_v<hold<T...>, Z...>>;
};

//  vfmadd132ps ANY [RVM] r  [66] 98 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd132ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x98>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd132ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x98>, mrm_v<hold<T...>, Z...>>;
};

//  vfmadd132sd ANY [RVM] r  [66] 99 
template<class T, class Enable = bool> struct asm_vfmadd132sd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','1','3','2','s','d', str...>, hold<T...>> {
    using value = typename asm_vfmadd132sd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd132sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x99>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd132sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x99>, mrm_v<hold<T...>, Z...>>;
};

//  vfmadd132ss ANY [RVM] r  [66] 99 
template<class T, class Enable = bool> struct asm_vfmadd132ss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','1','3','2','s','s', str...>, hold<T...>> {
    using value = typename asm_vfmadd132ss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd132ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x99>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd132ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x99>, mrm_v<hold<T...>, Z...>>;
};

//  vfmadd213pd ANY [RVM] r  [66] A8 
template<class T, class Enable = bool> struct asm_vfmadd213pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','2','1','3','p','d', str...>, hold<T...>> {
    using value = typename asm_vfmadd213pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd213pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA8>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd213pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA8>, mrm_v<hold<T...>, Z...>>;
};

//  vfmadd213pd ANY [RVM] r  [66] A8 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd213pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA8>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd213pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA8>, mrm_v<hold<T...>, Z...>>;
};

//  vfmadd213ps ANY [RVM] r  [66] A8 
template<class T, class Enable = bool> struct asm_vfmadd213ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','2','1','3','p','s', str...>, hold<T...>> {
    using value = typename asm_vfmadd213ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd213ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA8>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd213ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA8>, mrm_v<hold<T...>, Z...>>;
};

//  vfmadd213ps ANY [RVM] r  [66] A8 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd213ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA8>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd213ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA8>, mrm_v<hold<T...>, Z...>>;
};

//  vfmadd213sd ANY [RVM] r  [66] A9 
template<class T, class Enable = bool> struct asm_vfmadd213sd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','2','1','3','s','d', str...>, hold<T...>> {
    using value = typename asm_vfmadd213sd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd213sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xA9>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd213sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xA9>, mrm_v<hold<T...>, Z...>>;
};

//  vfmadd213ss ANY [RVM] r  [66] A9 
template<class T, class Enable = bool> struct asm_vfmadd213ss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','2','1','3','s','s', str...>, hold<T...>> {
    using value = typename asm_vfmadd213ss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd213ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xA9>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd213ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xA9>, mrm_v<hold<T...>, Z...>>;
};

//  vfmadd231pd ANY [RVM] r  [66] B8 
template<class T, class Enable = bool> struct asm_vfmadd231pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','2','3','1','p','d', str...>, hold<T...>> {
    using value = typename asm_vfmadd231pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd231pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB8>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd231pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB8>, mrm_v<hold<T...>, Z...>>;
};

//  vfmadd231pd ANY [RVM] r  [66] B8 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd231pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB8>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd231pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB8>, mrm_v<hold<T...>, Z...>>;
};

//  vfmadd231ps ANY [RVM] r  [66] B8 
template<class T, class Enable = bool> struct asm_vfmadd231ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','2','3','1','p','s', str...>, hold<T...>> {
    using value = typename asm_vfmadd231ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd231ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB8>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd231ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB8>, mrm_v<hold<T...>, Z...>>;
};

//  vfmadd231ps ANY [RVM] r  [66] B8 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd231ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB8>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd231ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB8>, mrm_v<hold<T...>, Z...>>;
};

//  vfmadd231sd ANY [RVM] r  [66] B9 
template<class T, class Enable = bool> struct asm_vfmadd231sd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','2','3','1','s','d', str...>, hold<T...>> {
    using value = typename asm_vfmadd231sd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd231sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xB9>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd231sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xB9>, mrm_v<hold<T...>, Z...>>;
};

//  vfmadd231ss ANY [RVM] r  [66] B9 
template<class T, class Enable = bool> struct asm_vfmadd231ss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','2','3','1','s','s', str...>, hold<T...>> {
    using value = typename asm_vfmadd231ss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd231ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xB9>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmadd231ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xB9>, mrm_v<hold<T...>, Z...>>;
};

//  vfmaddpd ANY [RVSM] r  [66] 69 
template<class T, class Enable = bool> struct asm_vfmaddpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','p','d', str...>, hold<T...>> {
    using value = typename asm_vfmaddpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x69>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x69>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmaddpd ANY [RVMS] r  [66] 69 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x69>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmaddpd ANY [RVSM] r  [66] 69 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x69>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x69>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmaddpd ANY [RVMS] r  [66] 69 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x69>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmaddps ANY [RVSM] r  [66] 68 
template<class T, class Enable = bool> struct asm_vfmaddps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','p','s', str...>, hold<T...>> {
    using value = typename asm_vfmaddps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x68>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x68>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmaddps ANY [RVMS] r  [66] 68 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x68>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmaddps ANY [RVSM] r  [66] 68 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x68>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x68>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmaddps ANY [RVMS] r  [66] 68 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x68>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmaddsd ANY [RVSM] r  [66] 6B 
template<class T, class Enable = bool> struct asm_vfmaddsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','d', str...>, hold<T...>> {
    using value = typename asm_vfmaddsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg64>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6B>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg64, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6B>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmaddsd ANY [RVMS] r  [66] 6B 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6B>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmaddss ANY [RVSM] r  [66] 6A 
template<class T, class Enable = bool> struct asm_vfmaddss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','s', str...>, hold<T...>> {
    using value = typename asm_vfmaddss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg32>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6A>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg32, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6A>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmaddss ANY [RVMS] r  [66] 6A 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6A>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmaddsub132pd ANY [RVM] r  [66] 96 
template<class T, class Enable = bool> struct asm_vfmaddsub132pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','u','b','1','3','2','p','d', str...>, hold<T...>> {
    using value = typename asm_vfmaddsub132pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub132pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x96>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub132pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x96>, mrm_v<hold<T...>, Z...>>;
};

//  vfmaddsub132pd ANY [RVM] r  [66] 96 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub132pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x96>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub132pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x96>, mrm_v<hold<T...>, Z...>>;
};

//  vfmaddsub132ps ANY [RVM] r  [66] 96 
template<class T, class Enable = bool> struct asm_vfmaddsub132ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','u','b','1','3','2','p','s', str...>, hold<T...>> {
    using value = typename asm_vfmaddsub132ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub132ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x96>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub132ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x96>, mrm_v<hold<T...>, Z...>>;
};

//  vfmaddsub132ps ANY [RVM] r  [66] 96 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub132ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x96>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub132ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x96>, mrm_v<hold<T...>, Z...>>;
};

//  vfmaddsub213pd ANY [RVM] r  [66] A6 
template<class T, class Enable = bool> struct asm_vfmaddsub213pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','u','b','2','1','3','p','d', str...>, hold<T...>> {
    using value = typename asm_vfmaddsub213pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub213pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA6>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub213pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA6>, mrm_v<hold<T...>, Z...>>;
};

//  vfmaddsub213pd ANY [RVM] r  [66] A6 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub213pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA6>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub213pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA6>, mrm_v<hold<T...>, Z...>>;
};

//  vfmaddsub213ps ANY [RVM] r  [66] A6 
template<class T, class Enable = bool> struct asm_vfmaddsub213ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','u','b','2','1','3','p','s', str...>, hold<T...>> {
    using value = typename asm_vfmaddsub213ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub213ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA6>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub213ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA6>, mrm_v<hold<T...>, Z...>>;
};

//  vfmaddsub213ps ANY [RVM] r  [66] A6 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub213ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA6>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub213ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA6>, mrm_v<hold<T...>, Z...>>;
};

//  vfmaddsub231pd ANY [RVM] r  [66] B6 
template<class T, class Enable = bool> struct asm_vfmaddsub231pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','u','b','2','3','1','p','d', str...>, hold<T...>> {
    using value = typename asm_vfmaddsub231pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub231pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB6>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub231pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB6>, mrm_v<hold<T...>, Z...>>;
};

//  vfmaddsub231pd ANY [RVM] r  [66] B6 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub231pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB6>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub231pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB6>, mrm_v<hold<T...>, Z...>>;
};

//  vfmaddsub231ps ANY [RVM] r  [66] B6 
template<class T, class Enable = bool> struct asm_vfmaddsub231ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','u','b','2','3','1','p','s', str...>, hold<T...>> {
    using value = typename asm_vfmaddsub231ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub231ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB6>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub231ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB6>, mrm_v<hold<T...>, Z...>>;
};

//  vfmaddsub231ps ANY [RVM] r  [66] B6 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub231ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB6>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmaddsub231ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB6>, mrm_v<hold<T...>, Z...>>;
};

//  vfmaddsubpd ANY [RVSM] r  [66] 5D 
template<class T, class Enable = bool> struct asm_vfmaddsubpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','u','b','p','d', str...>, hold<T...>> {
    using value = typename asm_vfmaddsubpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddsubpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5D>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddsubpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5D>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmaddsubpd ANY [RVMS] r  [66] 5D 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddsubpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5D>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmaddsubpd ANY [RVSM] r  [66] 5D 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddsubpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5D>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddsubpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5D>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmaddsubpd ANY [RVMS] r  [66] 5D 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddsubpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5D>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmaddsubps ANY [RVSM] r  [66] 5C 
template<class T, class Enable = bool> struct asm_vfmaddsubps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','u','b','p','s', str...>, hold<T...>> {
    using value = typename asm_vfmaddsubps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddsubps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5C>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddsubps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5C>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmaddsubps ANY [RVMS] r  [66] 5C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddsubps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5C>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmaddsubps ANY [RVSM] r  [66] 5C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddsubps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5C>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddsubps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5C>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmaddsubps ANY [RVMS] r  [66] 5C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmaddsubps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5C>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmsub132pd ANY [RVM] r  [66] 9A 
template<class T, class Enable = bool> struct asm_vfmsub132pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','1','3','2','p','d', str...>, hold<T...>> {
    using value = typename asm_vfmsub132pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub132pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9A>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub132pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9A>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsub132pd ANY [RVM] r  [66] 9A 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub132pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9A>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub132pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9A>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsub132ps ANY [RVM] r  [66] 9A 
template<class T, class Enable = bool> struct asm_vfmsub132ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','1','3','2','p','s', str...>, hold<T...>> {
    using value = typename asm_vfmsub132ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub132ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9A>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub132ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9A>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsub132ps ANY [RVM] r  [66] 9A 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub132ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9A>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub132ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9A>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsub132sd ANY [RVM] r  [66] 9B 
template<class T, class Enable = bool> struct asm_vfmsub132sd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','1','3','2','s','d', str...>, hold<T...>> {
    using value = typename asm_vfmsub132sd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub132sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9B>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub132sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9B>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsub132ss ANY [RVM] r  [66] 9B 
template<class T, class Enable = bool> struct asm_vfmsub132ss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','1','3','2','s','s', str...>, hold<T...>> {
    using value = typename asm_vfmsub132ss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub132ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9B>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub132ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9B>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsub213pd ANY [RVM] r  [66] AA 
template<class T, class Enable = bool> struct asm_vfmsub213pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','2','1','3','p','d', str...>, hold<T...>> {
    using value = typename asm_vfmsub213pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub213pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAA>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub213pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAA>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsub213pd ANY [RVM] r  [66] AA 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub213pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAA>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub213pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAA>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsub213ps ANY [RVM] r  [66] AA 
template<class T, class Enable = bool> struct asm_vfmsub213ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','2','1','3','p','s', str...>, hold<T...>> {
    using value = typename asm_vfmsub213ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub213ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAA>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub213ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAA>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsub213ps ANY [RVM] r  [66] AA 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub213ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAA>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub213ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAA>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsub213sd ANY [RVM] r  [66] AB 
template<class T, class Enable = bool> struct asm_vfmsub213sd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','2','1','3','s','d', str...>, hold<T...>> {
    using value = typename asm_vfmsub213sd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub213sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAB>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub213sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAB>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsub213ss ANY [RVM] r  [66] AB 
template<class T, class Enable = bool> struct asm_vfmsub213ss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','2','1','3','s','s', str...>, hold<T...>> {
    using value = typename asm_vfmsub213ss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub213ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAB>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub213ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAB>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsub231pd ANY [RVM] r  [66] BA 
template<class T, class Enable = bool> struct asm_vfmsub231pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','2','3','1','p','d', str...>, hold<T...>> {
    using value = typename asm_vfmsub231pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub231pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBA>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub231pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBA>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsub231pd ANY [RVM] r  [66] BA 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub231pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBA>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub231pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBA>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsub231ps ANY [RVM] r  [66] BA 
template<class T, class Enable = bool> struct asm_vfmsub231ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','2','3','1','p','s', str...>, hold<T...>> {
    using value = typename asm_vfmsub231ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub231ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBA>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub231ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBA>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsub231ps ANY [RVM] r  [66] BA 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub231ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBA>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub231ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBA>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsub231sd ANY [RVM] r  [66] BB 
template<class T, class Enable = bool> struct asm_vfmsub231sd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','2','3','1','s','d', str...>, hold<T...>> {
    using value = typename asm_vfmsub231sd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub231sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBB>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub231sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBB>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsub231ss ANY [RVM] r  [66] BB 
template<class T, class Enable = bool> struct asm_vfmsub231ss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','2','3','1','s','s', str...>, hold<T...>> {
    using value = typename asm_vfmsub231ss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub231ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBB>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsub231ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBB>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsubadd132pd ANY [RVM] r  [66] 97 
template<class T, class Enable = bool> struct asm_vfmsubadd132pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','a','d','d','1','3','2','p','d', str...>, hold<T...>> {
    using value = typename asm_vfmsubadd132pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd132pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x97>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd132pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x97>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsubadd132pd ANY [RVM] r  [66] 97 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd132pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x97>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd132pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x97>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsubadd132ps ANY [RVM] r  [66] 97 
template<class T, class Enable = bool> struct asm_vfmsubadd132ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','a','d','d','1','3','2','p','s', str...>, hold<T...>> {
    using value = typename asm_vfmsubadd132ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd132ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x97>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd132ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x97>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsubadd132ps ANY [RVM] r  [66] 97 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd132ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x97>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd132ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x97>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsubadd213pd ANY [RVM] r  [66] A7 
template<class T, class Enable = bool> struct asm_vfmsubadd213pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','a','d','d','2','1','3','p','d', str...>, hold<T...>> {
    using value = typename asm_vfmsubadd213pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd213pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA7>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd213pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA7>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsubadd213pd ANY [RVM] r  [66] A7 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd213pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA7>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd213pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA7>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsubadd213ps ANY [RVM] r  [66] A7 
template<class T, class Enable = bool> struct asm_vfmsubadd213ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','a','d','d','2','1','3','p','s', str...>, hold<T...>> {
    using value = typename asm_vfmsubadd213ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd213ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA7>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd213ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA7>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsubadd213ps ANY [RVM] r  [66] A7 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd213ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA7>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd213ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA7>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsubadd231pd ANY [RVM] r  [66] B7 
template<class T, class Enable = bool> struct asm_vfmsubadd231pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','a','d','d','2','3','1','p','d', str...>, hold<T...>> {
    using value = typename asm_vfmsubadd231pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd231pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB7>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd231pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB7>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsubadd231pd ANY [RVM] r  [66] B7 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd231pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB7>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd231pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB7>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsubadd231ps ANY [RVM] r  [66] B7 
template<class T, class Enable = bool> struct asm_vfmsubadd231ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','a','d','d','2','3','1','p','s', str...>, hold<T...>> {
    using value = typename asm_vfmsubadd231ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd231ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB7>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd231ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB7>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsubadd231ps ANY [RVM] r  [66] B7 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd231ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB7>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfmsubadd231ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB7>, mrm_v<hold<T...>, Z...>>;
};

//  vfmsubaddpd ANY [RVSM] r  [66] 5F 
template<class T, class Enable = bool> struct asm_vfmsubaddpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','a','d','d','p','d', str...>, hold<T...>> {
    using value = typename asm_vfmsubaddpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubaddpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5F>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubaddpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5F>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmsubaddpd ANY [RVMS] r  [66] 5F 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubaddpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5F>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmsubaddpd ANY [RVSM] r  [66] 5F 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubaddpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5F>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubaddpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5F>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmsubaddpd ANY [RVMS] r  [66] 5F 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubaddpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5F>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmsubaddps ANY [RVSM] r  [66] 5E 
template<class T, class Enable = bool> struct asm_vfmsubaddps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','a','d','d','p','s', str...>, hold<T...>> {
    using value = typename asm_vfmsubaddps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubaddps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5E>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubaddps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5E>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmsubaddps ANY [RVMS] r  [66] 5E 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubaddps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5E>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmsubaddps ANY [RVSM] r  [66] 5E 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubaddps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5E>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubaddps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5E>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmsubaddps ANY [RVMS] r  [66] 5E 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubaddps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5E>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmsubpd ANY [RVSM] r  [66] 6D 
template<class T, class Enable = bool> struct asm_vfmsubpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','p','d', str...>, hold<T...>> {
    using value = typename asm_vfmsubpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6D>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6D>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmsubpd ANY [RVMS] r  [66] 6D 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6D>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmsubpd ANY [RVSM] r  [66] 6D 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6D>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6D>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmsubpd ANY [RVMS] r  [66] 6D 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6D>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmsubps ANY [RVSM] r  [66] 6C 
template<class T, class Enable = bool> struct asm_vfmsubps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','p','s', str...>, hold<T...>> {
    using value = typename asm_vfmsubps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6C>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6C>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmsubps ANY [RVMS] r  [66] 6C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6C>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmsubps ANY [RVSM] r  [66] 6C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6C>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6C>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmsubps ANY [RVMS] r  [66] 6C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6C>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmsubsd ANY [RVSM] r  [66] 6F 
template<class T, class Enable = bool> struct asm_vfmsubsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','s','d', str...>, hold<T...>> {
    using value = typename asm_vfmsubsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg64>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6F>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg64, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6F>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmsubsd ANY [RVMS] r  [66] 6F 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6F>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfmsubss ANY [RVSM] r  [66] 6E 
template<class T, class Enable = bool> struct asm_vfmsubss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','s','s', str...>, hold<T...>> {
    using value = typename asm_vfmsubss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg32>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6E>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg32, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6E>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfmsubss ANY [RVMS] r  [66] 6E 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfmsubss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6E>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfnmadd132pd ANY [RVM] r  [66] 9C 
template<class T, class Enable = bool> struct asm_vfnmadd132pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','1','3','2','p','d', str...>, hold<T...>> {
    using value = typename asm_vfnmadd132pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd132pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd132pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9C>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmadd132pd ANY [RVM] r  [66] 9C 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd132pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd132pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9C>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmadd132ps ANY [RVM] r  [66] 9C 
template<class T, class Enable = bool> struct asm_vfnmadd132ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','1','3','2','p','s', str...>, hold<T...>> {
    using value = typename asm_vfnmadd132ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd132ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd132ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9C>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmadd132ps ANY [RVM] r  [66] 9C 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd132ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd132ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9C>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmadd132sd ANY [RVM] r  [66] 9D 
template<class T, class Enable = bool> struct asm_vfnmadd132sd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','1','3','2','s','d', str...>, hold<T...>> {
    using value = typename asm_vfnmadd132sd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd132sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd132sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9D>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmadd132ss ANY [RVM] r  [66] 9D 
template<class T, class Enable = bool> struct asm_vfnmadd132ss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','1','3','2','s','s', str...>, hold<T...>> {
    using value = typename asm_vfnmadd132ss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd132ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd132ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9D>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmadd213pd ANY [RVM] r  [66] AC 
template<class T, class Enable = bool> struct asm_vfnmadd213pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','2','1','3','p','d', str...>, hold<T...>> {
    using value = typename asm_vfnmadd213pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd213pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAC>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd213pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAC>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmadd213pd ANY [RVM] r  [66] AC 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd213pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAC>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd213pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAC>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmadd213ps ANY [RVM] r  [66] AC 
template<class T, class Enable = bool> struct asm_vfnmadd213ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','2','1','3','p','s', str...>, hold<T...>> {
    using value = typename asm_vfnmadd213ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd213ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAC>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd213ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAC>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmadd213ps ANY [RVM] r  [66] AC 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd213ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAC>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd213ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAC>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmadd213sd ANY [RVM] r  [66] AD 
template<class T, class Enable = bool> struct asm_vfnmadd213sd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','2','1','3','s','d', str...>, hold<T...>> {
    using value = typename asm_vfnmadd213sd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd213sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAD>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd213sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAD>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmadd213ss ANY [RVM] r  [66] AD 
template<class T, class Enable = bool> struct asm_vfnmadd213ss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','2','1','3','s','s', str...>, hold<T...>> {
    using value = typename asm_vfnmadd213ss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd213ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAD>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd213ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAD>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmadd231pd ANY [RVM] r  [66] BC 
template<class T, class Enable = bool> struct asm_vfnmadd231pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','2','3','1','p','d', str...>, hold<T...>> {
    using value = typename asm_vfnmadd231pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd231pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBC>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd231pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBC>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmadd231pd ANY [RVM] r  [66] BC 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd231pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBC>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd231pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBC>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmadd231ps ANY [RVM] r  [66] BC 
template<class T, class Enable = bool> struct asm_vfnmadd231ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','2','3','1','p','s', str...>, hold<T...>> {
    using value = typename asm_vfnmadd231ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd231ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBC>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd231ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBC>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmadd231ps ANY [RVM] r  [66] BC 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd231ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBC>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd231ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBC>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmadd231sd ANY [RVM] r  [66] BD 
template<class T, class Enable = bool> struct asm_vfnmadd231sd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','2','3','1','s','d', str...>, hold<T...>> {
    using value = typename asm_vfnmadd231sd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd231sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBD>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd231sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBD>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmadd231ss ANY [RVM] r  [66] BD 
template<class T, class Enable = bool> struct asm_vfnmadd231ss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','2','3','1','s','s', str...>, hold<T...>> {
    using value = typename asm_vfnmadd231ss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd231ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBD>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmadd231ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBD>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmaddpd ANY [RVSM] r  [66] 79 
template<class T, class Enable = bool> struct asm_vfnmaddpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','p','d', str...>, hold<T...>> {
    using value = typename asm_vfnmaddpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmaddpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x79>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmaddpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x79>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfnmaddpd ANY [RVMS] r  [66] 79 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmaddpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x79>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfnmaddpd ANY [RVSM] r  [66] 79 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmaddpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x79>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmaddpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x79>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfnmaddpd ANY [RVMS] r  [66] 79 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmaddpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x79>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfnmaddps ANY [RVSM] r  [66] 78 
template<class T, class Enable = bool> struct asm_vfnmaddps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','p','s', str...>, hold<T...>> {
    using value = typename asm_vfnmaddps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmaddps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x78>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmaddps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x78>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfnmaddps ANY [RVMS] r  [66] 78 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmaddps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x78>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfnmaddps ANY [RVSM] r  [66] 78 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmaddps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x78>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmaddps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x78>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfnmaddps ANY [RVMS] r  [66] 78 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmaddps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x78>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfnmaddsd ANY [RVSM] r  [66] 7B 
template<class T, class Enable = bool> struct asm_vfnmaddsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','s','d', str...>, hold<T...>> {
    using value = typename asm_vfnmaddsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmaddsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg64>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7B>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmaddsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg64, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7B>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfnmaddsd ANY [RVMS] r  [66] 7B 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmaddsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7B>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfnmaddss ANY [RVSM] r  [66] 7A 
template<class T, class Enable = bool> struct asm_vfnmaddss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','s','s', str...>, hold<T...>> {
    using value = typename asm_vfnmaddss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmaddss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg32>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7A>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmaddss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg32, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7A>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfnmaddss ANY [RVMS] r  [66] 7A 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmaddss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7A>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfnmsub132pd ANY [RVM] r  [66] 9E 
template<class T, class Enable = bool> struct asm_vfnmsub132pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','1','3','2','p','d', str...>, hold<T...>> {
    using value = typename asm_vfnmsub132pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub132pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9E>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub132pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9E>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmsub132pd ANY [RVM] r  [66] 9E 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub132pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9E>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub132pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9E>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmsub132ps ANY [RVM] r  [66] 9E 
template<class T, class Enable = bool> struct asm_vfnmsub132ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','1','3','2','p','s', str...>, hold<T...>> {
    using value = typename asm_vfnmsub132ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub132ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9E>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub132ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9E>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmsub132ps ANY [RVM] r  [66] 9E 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub132ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9E>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub132ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9E>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmsub132sd ANY [RVM] r  [66] 9F 
template<class T, class Enable = bool> struct asm_vfnmsub132sd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','1','3','2','s','d', str...>, hold<T...>> {
    using value = typename asm_vfnmsub132sd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub132sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9F>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub132sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9F>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmsub132ss ANY [RVM] r  [66] 9F 
template<class T, class Enable = bool> struct asm_vfnmsub132ss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','1','3','2','s','s', str...>, hold<T...>> {
    using value = typename asm_vfnmsub132ss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub132ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9F>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub132ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9F>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmsub213pd ANY [RVM] r  [66] AE 
template<class T, class Enable = bool> struct asm_vfnmsub213pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','2','1','3','p','d', str...>, hold<T...>> {
    using value = typename asm_vfnmsub213pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub213pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAE>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub213pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAE>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmsub213pd ANY [RVM] r  [66] AE 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub213pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAE>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub213pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAE>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmsub213ps ANY [RVM] r  [66] AE 
template<class T, class Enable = bool> struct asm_vfnmsub213ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','2','1','3','p','s', str...>, hold<T...>> {
    using value = typename asm_vfnmsub213ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub213ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAE>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub213ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAE>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmsub213ps ANY [RVM] r  [66] AE 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub213ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAE>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub213ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAE>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmsub213sd ANY [RVM] r  [66] AF 
template<class T, class Enable = bool> struct asm_vfnmsub213sd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','2','1','3','s','d', str...>, hold<T...>> {
    using value = typename asm_vfnmsub213sd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub213sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAF>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub213sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAF>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmsub213ss ANY [RVM] r  [66] AF 
template<class T, class Enable = bool> struct asm_vfnmsub213ss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','2','1','3','s','s', str...>, hold<T...>> {
    using value = typename asm_vfnmsub213ss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub213ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAF>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub213ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAF>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmsub231pd ANY [RVM] r  [66] BE 
template<class T, class Enable = bool> struct asm_vfnmsub231pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','2','3','1','p','d', str...>, hold<T...>> {
    using value = typename asm_vfnmsub231pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub231pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBE>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub231pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBE>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmsub231pd ANY [RVM] r  [66] BE 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub231pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBE>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub231pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBE>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmsub231ps ANY [RVM] r  [66] BE 
template<class T, class Enable = bool> struct asm_vfnmsub231ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','2','3','1','p','s', str...>, hold<T...>> {
    using value = typename asm_vfnmsub231ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub231ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBE>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub231ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBE>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmsub231ps ANY [RVM] r  [66] BE 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub231ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBE>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub231ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBE>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmsub231sd ANY [RVM] r  [66] BF 
template<class T, class Enable = bool> struct asm_vfnmsub231sd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','2','3','1','s','d', str...>, hold<T...>> {
    using value = typename asm_vfnmsub231sd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub231sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBF>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub231sd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBF>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmsub231ss ANY [RVM] r  [66] BF 
template<class T, class Enable = bool> struct asm_vfnmsub231ss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','2','3','1','s','s', str...>, hold<T...>> {
    using value = typename asm_vfnmsub231ss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub231ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBF>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vfnmsub231ss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBF>, mrm_v<hold<T...>, Z...>>;
};

//  vfnmsubpd ANY [RVSM] r  [66] 7D 
template<class T, class Enable = bool> struct asm_vfnmsubpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','p','d', str...>, hold<T...>> {
    using value = typename asm_vfnmsubpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmsubpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7D>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmsubpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7D>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfnmsubpd ANY [RVMS] r  [66] 7D 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmsubpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7D>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfnmsubpd ANY [RVSM] r  [66] 7D 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmsubpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7D>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmsubpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7D>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfnmsubpd ANY [RVMS] r  [66] 7D 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmsubpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7D>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfnmsubps ANY [RVSM] r  [66] 7C 
template<class T, class Enable = bool> struct asm_vfnmsubps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','p','s', str...>, hold<T...>> {
    using value = typename asm_vfnmsubps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmsubps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7C>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmsubps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7C>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfnmsubps ANY [RVMS] r  [66] 7C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmsubps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7C>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfnmsubps ANY [RVSM] r  [66] 7C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmsubps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7C>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmsubps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7C>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfnmsubps ANY [RVMS] r  [66] 7C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmsubps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7C>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfnmsubsd ANY [RVSM] r  [66] 7F 
template<class T, class Enable = bool> struct asm_vfnmsubsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','s','d', str...>, hold<T...>> {
    using value = typename asm_vfnmsubsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmsubsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg64>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7F>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmsubsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg64, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7F>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfnmsubsd ANY [RVMS] r  [66] 7F 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmsubsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7F>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfnmsubss ANY [RVSM] r  [66] 7E 
template<class T, class Enable = bool> struct asm_vfnmsubss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','s','s', str...>, hold<T...>> {
    using value = typename asm_vfnmsubss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmsubss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg32>::with<O...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7E>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmsubss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg32, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7E>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vfnmsubss ANY [RVMS] r  [66] 7E 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vfnmsubss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7E>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vfrczpd ANY [RM] r  [] 81 
template<class T, class Enable = bool> struct asm_vfrczpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','r','c','z','p','d', str...>, hold<T...>> {
    using value = typename asm_vfrczpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vfrczpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x81>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vfrczpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x81>, mrm_v<hold<T...>, Y...>>;
};

//  vfrczpd ANY [RM] r  [] 81 

template<typename ...T, typename ...Y>
struct asm_vfrczpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x81>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vfrczpd<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x81>, mrm_v<hold<T...>, Y...>>;
};

//  vfrczps ANY [RM] r  [] 80 
template<class T, class Enable = bool> struct asm_vfrczps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','r','c','z','p','s', str...>, hold<T...>> {
    using value = typename asm_vfrczps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vfrczps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x80>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vfrczps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x80>, mrm_v<hold<T...>, Y...>>;
};

//  vfrczps ANY [RM] r  [] 80 

template<typename ...T, typename ...Y>
struct asm_vfrczps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x80>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vfrczps<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x80>, mrm_v<hold<T...>, Y...>>;
};

//  vfrczsd ANY [RM] r  [] 83 
template<class T, class Enable = bool> struct asm_vfrczsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','r','c','z','s','d', str...>, hold<T...>> {
    using value = typename asm_vfrczsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vfrczsd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x83>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vfrczsd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x83>, mrm_v<hold<T...>, Y...>>;
};

//  vfrczss ANY [RM] r  [] 82 
template<class T, class Enable = bool> struct asm_vfrczss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','r','c','z','s','s', str...>, hold<T...>> {
    using value = typename asm_vfrczss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vfrczss<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x82>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vfrczss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x82>, mrm_v<hold<T...>, Y...>>;
};

//  vgatherdpd ANY [RMV] r  [66] 92 
template<class T, class Enable = bool> struct asm_vgatherdpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','g','a','t','h','e','r','d','p','d', str...>, hold<T...>> {
    using value = typename asm_vgatherdpd<hold<T...>>::value;
};
//  vgatherdpd ANY [RMV] r  [66] 92 

//  vgatherdps ANY [RMV] r  [66] 92 
template<class T, class Enable = bool> struct asm_vgatherdps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','g','a','t','h','e','r','d','p','s', str...>, hold<T...>> {
    using value = typename asm_vgatherdps<hold<T...>>::value;
};
//  vgatherdps ANY [RMV] r  [66] 92 

//  vgatherqpd ANY [RMV] r  [66] 93 
template<class T, class Enable = bool> struct asm_vgatherqpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','g','a','t','h','e','r','q','p','d', str...>, hold<T...>> {
    using value = typename asm_vgatherqpd<hold<T...>>::value;
};
//  vgatherqpd ANY [RMV] r  [66] 93 

//  vgatherqps ANY [RMV] r  [66] 93 
template<class T, class Enable = bool> struct asm_vgatherqps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','g','a','t','h','e','r','q','p','s', str...>, hold<T...>> {
    using value = typename asm_vgatherqps<hold<T...>>::value;
};
//  vgatherqps ANY [RMV] r  [66] 93 

//  vgf2p8affineinvqb ANY [RVMI] r  [66] CF 
template<class T, class Enable = bool> struct asm_vgf2p8affineinvqb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','g','f','2','p','8','a','f','f','i','n','e','i','n','v','q','b', str...>, hold<T...>> {
    using value = typename asm_vgf2p8affineinvqb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vgf2p8affineinvqb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xCF>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vgf2p8affineinvqb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xCF>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vgf2p8affineinvqb ANY [RVMI] r  [66] CF 

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vgf2p8affineinvqb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xCF>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vgf2p8affineinvqb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xCF>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vgf2p8affineqb ANY [RVMI] r  [66] CE 
template<class T, class Enable = bool> struct asm_vgf2p8affineqb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','g','f','2','p','8','a','f','f','i','n','e','q','b', str...>, hold<T...>> {
    using value = typename asm_vgf2p8affineqb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vgf2p8affineqb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xCE>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vgf2p8affineqb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xCE>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vgf2p8affineqb ANY [RVMI] r  [66] CE 

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vgf2p8affineqb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xCE>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vgf2p8affineqb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xCE>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vgf2p8mulb ANY [RVM] r  [66] CF 
template<class T, class Enable = bool> struct asm_vgf2p8mulb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','g','f','2','p','8','m','u','l','b', str...>, hold<T...>> {
    using value = typename asm_vgf2p8mulb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vgf2p8mulb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xCF>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vgf2p8mulb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xCF>, mrm_v<hold<T...>, Z...>>;
};

//  vgf2p8mulb ANY [RVM] r  [66] CF 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vgf2p8mulb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xCF>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vgf2p8mulb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xCF>, mrm_v<hold<T...>, Z...>>;
};

//  vhaddpd ANY [RVM] r  [66] 7C 
template<class T, class Enable = bool> struct asm_vhaddpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','h','a','d','d','p','d', str...>, hold<T...>> {
    using value = typename asm_vhaddpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vhaddpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vhaddpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7C>, mrm_v<hold<T...>, Z...>>;
};

//  vhaddpd ANY [RVM] r  [66] 7C 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vhaddpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vhaddpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7C>, mrm_v<hold<T...>, Z...>>;
};

//  vhaddps ANY [RVM] r  [F2] 7C 
template<class T, class Enable = bool> struct asm_vhaddps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','h','a','d','d','p','s', str...>, hold<T...>> {
    using value = typename asm_vhaddps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vhaddps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x7C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vhaddps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x7C>, mrm_v<hold<T...>, Z...>>;
};

//  vhaddps ANY [RVM] r  [F2] 7C 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vhaddps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0x7C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vhaddps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0x7C>, mrm_v<hold<T...>, Z...>>;
};

//  vhsubpd ANY [RVM] r  [66] 7D 
template<class T, class Enable = bool> struct asm_vhsubpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','h','s','u','b','p','d', str...>, hold<T...>> {
    using value = typename asm_vhsubpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vhsubpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vhsubpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7D>, mrm_v<hold<T...>, Z...>>;
};

//  vhsubpd ANY [RVM] r  [66] 7D 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vhsubpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vhsubpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7D>, mrm_v<hold<T...>, Z...>>;
};

//  vhsubps ANY [RVM] r  [F2] 7D 
template<class T, class Enable = bool> struct asm_vhsubps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','h','s','u','b','p','s', str...>, hold<T...>> {
    using value = typename asm_vhsubps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vhsubps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x7D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vhsubps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x7D>, mrm_v<hold<T...>, Z...>>;
};

//  vhsubps ANY [RVM] r  [F2] 7D 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vhsubps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0x7D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vhsubps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0x7D>, mrm_v<hold<T...>, Z...>>;
};

//  vinsertf128 ANY [RVMI] r  [66] 18 
template<class T, class Enable = bool> struct asm_vinsertf128 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','i','n','s','e','r','t','f','1','2','8', str...>, hold<T...>> {
    using value = typename asm_vinsertf128<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vinsertf128<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x18>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vinsertf128<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x18>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vinserti128 ANY [RVMI] r  [66] 38 
template<class T, class Enable = bool> struct asm_vinserti128 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','i','n','s','e','r','t','i','1','2','8', str...>, hold<T...>> {
    using value = typename asm_vinserti128<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vinserti128<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x38>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vinserti128<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x38>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vinsertps ANY [RVMI] r  [66] 21 
template<class T, class Enable = bool> struct asm_vinsertps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','i','n','s','e','r','t','p','s', str...>, hold<T...>> {
    using value = typename asm_vinsertps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vinsertps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x21>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vinsertps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x21>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vlddqu ANY [RM] r  [F2] F0 
template<class T, class Enable = bool> struct asm_vlddqu {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','l','d','d','q','u', str...>, hold<T...>> {
    using value = typename asm_vlddqu<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vlddqu<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vlddqu<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF0>, mrm_v<hold<T...>, Y...>>;
};

//  vlddqu ANY [RM] r  [F2] F0 

template<typename ...T, typename ...Y>
struct asm_vlddqu<hold<zip<reg256>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vlddqu<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0xF0>, mrm_v<hold<T...>, Y...>>;
};

//  vldmxcsr ANY [M] 2  [] AE 
template<class T, class Enable = bool> struct asm_vldmxcsr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','l','d','m','x','c','s','r', str...>, hold<T...>> {
    using value = typename asm_vldmxcsr<hold<T...>>::value;
};
template<typename ...T>
struct asm_vldmxcsr<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<2>>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

template<typename ...T>
struct asm_vldmxcsr<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<reg<2>>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xAE>, mrm_v<hold<reg<2>>, T...>>;
};

//  vmaskmovdqu ANY [RM] r  [66] F7 
template<class T, class Enable = bool> struct asm_vmaskmovdqu {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','a','s','k','m','o','v','d','q','u', str...>, hold<T...>> {
    using value = typename asm_vmaskmovdqu<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmaskmovdqu<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF7>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  vmaskmovpd ANY [MVR] r  [66] 2F 
template<class T, class Enable = bool> struct asm_vmaskmovpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','a','s','k','m','o','v','p','d', str...>, hold<T...>> {
    using value = typename asm_vmaskmovpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaskmovpd<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Z...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2F>, mrm_v<hold<Z...>, T...>>;
};

//  vmaskmovpd ANY [MVR] r  [66] 2F 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaskmovpd<hold<ptr<reg256, T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Z...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2F>, mrm_v<hold<Z...>, T...>>;
};

//  vmaskmovpd ANY [RVM] r  [66] 2D 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaskmovpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaskmovpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2D>, mrm_v<hold<T...>, Z...>>;
};

//  vmaskmovpd ANY [RVM] r  [66] 2D 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaskmovpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaskmovpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2D>, mrm_v<hold<T...>, Z...>>;
};

//  vmaskmovps ANY [MVR] r  [66] 2E 
template<class T, class Enable = bool> struct asm_vmaskmovps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','a','s','k','m','o','v','p','s', str...>, hold<T...>> {
    using value = typename asm_vmaskmovps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaskmovps<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Z...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2E>, mrm_v<hold<Z...>, T...>>;
};

//  vmaskmovps ANY [MVR] r  [66] 2E 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaskmovps<hold<ptr<reg256, T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Z...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2E>, mrm_v<hold<Z...>, T...>>;
};

//  vmaskmovps ANY [RVM] r  [66] 2C 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaskmovps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaskmovps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2C>, mrm_v<hold<T...>, Z...>>;
};

//  vmaskmovps ANY [RVM] r  [66] 2C 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaskmovps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaskmovps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2C>, mrm_v<hold<T...>, Z...>>;
};

//  vmaxpd ANY [RVM] r  [66] 5F 
template<class T, class Enable = bool> struct asm_vmaxpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','a','x','p','d', str...>, hold<T...>> {
    using value = typename asm_vmaxpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaxpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5F>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaxpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5F>, mrm_v<hold<T...>, Z...>>;
};

//  vmaxpd ANY [RVM] r  [66] 5F 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaxpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5F>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaxpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5F>, mrm_v<hold<T...>, Z...>>;
};

//  vmaxps ANY [RVM] r  [] 5F 
template<class T, class Enable = bool> struct asm_vmaxps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','a','x','p','s', str...>, hold<T...>> {
    using value = typename asm_vmaxps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaxps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x5F>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaxps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x5F>, mrm_v<hold<T...>, Z...>>;
};

//  vmaxps ANY [RVM] r  [] 5F 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaxps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x5F>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaxps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x5F>, mrm_v<hold<T...>, Z...>>;
};

//  vmaxsd ANY [RVM] r  [F2] 5F 
template<class T, class Enable = bool> struct asm_vmaxsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','a','x','s','d', str...>, hold<T...>> {
    using value = typename asm_vmaxsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaxsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5F>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaxsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5F>, mrm_v<hold<T...>, Z...>>;
};

//  vmaxss ANY [RVM] r  [F3] 5F 
template<class T, class Enable = bool> struct asm_vmaxss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','a','x','s','s', str...>, hold<T...>> {
    using value = typename asm_vmaxss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaxss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5F>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmaxss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5F>, mrm_v<hold<T...>, Z...>>;
};

//  vmcall ANY [NONE]   [] C1 
template<class T, class Enable = bool> struct asm_vmcall {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','c','a','l','l', str...>, hold<T...>> {
    using value = typename asm_vmcall<hold<T...>>::value;
};
template <> struct asm_vmcall<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xC1>>; };
//  vmclear ANY [M] 6  [66] C7 
template<class T, class Enable = bool> struct asm_vmclear {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','c','l','e','a','r', str...>, hold<T...>> {
    using value = typename asm_vmclear<hold<T...>>::value;
};
template<typename ...T>
struct asm_vmclear<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

template<typename ...T>
struct asm_vmclear<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, mrm_v<hold<reg<6>>, T...>>;
};

//  vmfunc ANY [NONE]   [] D4 
template<class T, class Enable = bool> struct asm_vmfunc {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','f','u','n','c', str...>, hold<T...>> {
    using value = typename asm_vmfunc<hold<T...>>::value;
};
template <> struct asm_vmfunc<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xD4>>; };
//  vminpd ANY [RVM] r  [66] 5D 
template<class T, class Enable = bool> struct asm_vminpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','i','n','p','d', str...>, hold<T...>> {
    using value = typename asm_vminpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vminpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vminpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5D>, mrm_v<hold<T...>, Z...>>;
};

//  vminpd ANY [RVM] r  [66] 5D 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vminpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vminpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5D>, mrm_v<hold<T...>, Z...>>;
};

//  vminps ANY [RVM] r  [] 5D 
template<class T, class Enable = bool> struct asm_vminps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','i','n','p','s', str...>, hold<T...>> {
    using value = typename asm_vminps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vminps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x5D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vminps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x5D>, mrm_v<hold<T...>, Z...>>;
};

//  vminps ANY [RVM] r  [] 5D 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vminps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x5D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vminps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x5D>, mrm_v<hold<T...>, Z...>>;
};

//  vminsd ANY [RVM] r  [F2] 5D 
template<class T, class Enable = bool> struct asm_vminsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','i','n','s','d', str...>, hold<T...>> {
    using value = typename asm_vminsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vminsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vminsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5D>, mrm_v<hold<T...>, Z...>>;
};

//  vminss ANY [RVM] r  [F3] 5D 
template<class T, class Enable = bool> struct asm_vminss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','i','n','s','s', str...>, hold<T...>> {
    using value = typename asm_vminss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vminss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vminss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5D>, mrm_v<hold<T...>, Z...>>;
};

//  vmlaunch ANY [NONE]   [] C2 
template<class T, class Enable = bool> struct asm_vmlaunch {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','l','a','u','n','c','h', str...>, hold<T...>> {
    using value = typename asm_vmlaunch<hold<T...>>::value;
};
template <> struct asm_vmlaunch<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xC2>>; };
//  vmload X86 [NONE]   [] DA 
template<class T, class Enable = bool> struct asm_vmload {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','l','o','a','d', str...>, hold<T...>> {
    using value = typename asm_vmload<hold<T...>>::value;
};
template <>
struct asm_vmload<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xDA>>; };
//  vmmcall ANY [NONE]   [] D9 
template<class T, class Enable = bool> struct asm_vmmcall {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','m','c','a','l','l', str...>, hold<T...>> {
    using value = typename asm_vmmcall<hold<T...>>::value;
};
template <> struct asm_vmmcall<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xD9>>; };
//  vmovapd ANY [RM] r  [66] 28 
template<class T, class Enable = bool> struct asm_vmovapd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','a','p','d', str...>, hold<T...>> {
    using value = typename asm_vmovapd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovapd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x28>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovapd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x28>, mrm_v<hold<T...>, Y...>>;
};

//  vmovapd ANY [MR] r  [66] 29 

template<typename ...T, typename ...Y>
struct asm_vmovapd<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x29>, mrm_v<hold<Y...>, T...>>;
};

//  vmovapd ANY [RM] r  [66] 28 

template<typename ...T, typename ...Y>
struct asm_vmovapd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x28>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovapd<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x28>, mrm_v<hold<T...>, Y...>>;
};

//  vmovapd ANY [MR] r  [66] 29 

template<typename ...T, typename ...Y>
struct asm_vmovapd<hold<ptr<reg256, T...>, zip<reg256>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x29>, mrm_v<hold<Y...>, T...>>;
};

//  vmovaps ANY [RM] r  [] 28 
template<class T, class Enable = bool> struct asm_vmovaps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','a','p','s', str...>, hold<T...>> {
    using value = typename asm_vmovaps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovaps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x28>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovaps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x28>, mrm_v<hold<T...>, Y...>>;
};

//  vmovaps ANY [MR] r  [] 29 

template<typename ...T, typename ...Y>
struct asm_vmovaps<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x29>, mrm_v<hold<Y...>, T...>>;
};

//  vmovaps ANY [RM] r  [] 28 

template<typename ...T, typename ...Y>
struct asm_vmovaps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x28>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovaps<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x28>, mrm_v<hold<T...>, Y...>>;
};

//  vmovaps ANY [MR] r  [] 29 

template<typename ...T, typename ...Y>
struct asm_vmovaps<hold<ptr<reg256, T...>, zip<reg256>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x29>, mrm_v<hold<Y...>, T...>>;
};

//  vmovd ANY [MR] r  [66] 7E 
template<class T, class Enable = bool> struct asm_vmovd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','d', str...>, hold<T...>> {
    using value = typename asm_vmovd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovd<hold<ptr<reg32, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<1>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7E>, mrm_v<hold<Y...>, T...>>;
};

//  vmovd ANY [RM] r  [66] 6E 

template<typename ...T, typename ...Y>
struct asm_vmovd<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovd<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<1>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6E>, mrm_v<hold<T...>, Y...>>;
};

//  vmovddup ANY [RM] r  [F2] 12 
template<class T, class Enable = bool> struct asm_vmovddup {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','d','d','u','p', str...>, hold<T...>> {
    using value = typename asm_vmovddup<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovddup<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovddup<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x12>, mrm_v<hold<T...>, Y...>>;
};

//  vmovddup ANY [RM] r  [F2] 12 

template<typename ...T, typename ...Y>
struct asm_vmovddup<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovddup<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0x12>, mrm_v<hold<T...>, Y...>>;
};

//  vmovdqa ANY [RM] r  [66] 6F 
template<class T, class Enable = bool> struct asm_vmovdqa {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','d','q','a', str...>, hold<T...>> {
    using value = typename asm_vmovdqa<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovdqa<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovdqa<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6F>, mrm_v<hold<T...>, Y...>>;
};

//  vmovdqa ANY [MR] r  [66] 7F 

template<typename ...T, typename ...Y>
struct asm_vmovdqa<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7F>, mrm_v<hold<Y...>, T...>>;
};

//  vmovdqa ANY [RM] r  [66] 6F 

template<typename ...T, typename ...Y>
struct asm_vmovdqa<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovdqa<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6F>, mrm_v<hold<T...>, Y...>>;
};

//  vmovdqa ANY [MR] r  [66] 7F 

template<typename ...T, typename ...Y>
struct asm_vmovdqa<hold<ptr<reg256, T...>, zip<reg256>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7F>, mrm_v<hold<Y...>, T...>>;
};

//  vmovdqu ANY [RM] r  [F3] 6F 
template<class T, class Enable = bool> struct asm_vmovdqu {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','d','q','u', str...>, hold<T...>> {
    using value = typename asm_vmovdqu<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovdqu<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x6F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovdqu<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x6F>, mrm_v<hold<T...>, Y...>>;
};

//  vmovdqu ANY [MR] r  [F3] 7F 

template<typename ...T, typename ...Y>
struct asm_vmovdqu<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x7F>, mrm_v<hold<Y...>, T...>>;
};

//  vmovdqu ANY [RM] r  [F3] 6F 

template<typename ...T, typename ...Y>
struct asm_vmovdqu<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x6F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovdqu<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x6F>, mrm_v<hold<T...>, Y...>>;
};

//  vmovdqu ANY [MR] r  [F3] 7F 

template<typename ...T, typename ...Y>
struct asm_vmovdqu<hold<ptr<reg256, T...>, zip<reg256>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x7F>, mrm_v<hold<Y...>, T...>>;
};

//  vmovhlps ANY [RVM] r  [] 12 
template<class T, class Enable = bool> struct asm_vmovhlps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','h','l','p','s', str...>, hold<T...>> {
    using value = typename asm_vmovhlps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmovhlps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

//  vmovhpd ANY [MR] r  [66] 17 
template<class T, class Enable = bool> struct asm_vmovhpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','h','p','d', str...>, hold<T...>> {
    using value = typename asm_vmovhpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovhpd<hold<zip<reg64>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x17>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovhpd<hold<ptr<reg64, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x17>, mrm_v<hold<Y...>, T...>>;
};

//  vmovhpd ANY [RVM] r  [66] 16 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmovhpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x16>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmovhpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x16>, mrm_v<hold<T...>, Z...>>;
};

//  vmovhps ANY [MR] r  [] 17 
template<class T, class Enable = bool> struct asm_vmovhps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','h','p','s', str...>, hold<T...>> {
    using value = typename asm_vmovhps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovhps<hold<zip<reg64>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x17>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovhps<hold<ptr<reg64, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x17>, mrm_v<hold<Y...>, T...>>;
};

//  vmovhps ANY [RVM] r  [] 16 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmovhps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x16>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmovhps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x16>, mrm_v<hold<T...>, Z...>>;
};

//  vmovlhps ANY [RVM] r  [] 16 
template<class T, class Enable = bool> struct asm_vmovlhps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','l','h','p','s', str...>, hold<T...>> {
    using value = typename asm_vmovlhps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmovlhps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x16>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

//  vmovlpd ANY [MR] r  [66] 13 
template<class T, class Enable = bool> struct asm_vmovlpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','l','p','d', str...>, hold<T...>> {
    using value = typename asm_vmovlpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovlpd<hold<zip<reg64>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x13>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovlpd<hold<ptr<reg64, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x13>, mrm_v<hold<Y...>, T...>>;
};

//  vmovlpd ANY [RVM] r  [66] 12 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmovlpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x12>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmovlpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x12>, mrm_v<hold<T...>, Z...>>;
};

//  vmovlps ANY [MR] r  [] 13 
template<class T, class Enable = bool> struct asm_vmovlps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','l','p','s', str...>, hold<T...>> {
    using value = typename asm_vmovlps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovlps<hold<zip<reg64>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x13>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovlps<hold<ptr<reg64, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x13>, mrm_v<hold<Y...>, T...>>;
};

//  vmovlps ANY [RVM] r  [] 12 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmovlps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmovlps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, mrm_v<hold<T...>, Z...>>;
};

//  vmovmskpd ANY [RM] r  [66] 50 
template<class T, class Enable = bool> struct asm_vmovmskpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','m','s','k','p','d', str...>, hold<T...>> {
    using value = typename asm_vmovmskpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovmskpd<hold<zip<reg32>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x50>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  vmovmskpd ANY [RM] r  [66] 50 

template<typename ...T, typename ...Y>
struct asm_vmovmskpd<hold<zip<reg32>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x50>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  vmovmskps ANY [RM] r  [] 50 
template<class T, class Enable = bool> struct asm_vmovmskps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','m','s','k','p','s', str...>, hold<T...>> {
    using value = typename asm_vmovmskps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovmskps<hold<zip<reg32>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x50>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  vmovmskps ANY [RM] r  [] 50 

template<typename ...T, typename ...Y>
struct asm_vmovmskps<hold<zip<reg32>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x50>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

//  vmovntdq ANY [MR] r  [66] E7 
template<class T, class Enable = bool> struct asm_vmovntdq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','n','t','d','q', str...>, hold<T...>> {
    using value = typename asm_vmovntdq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovntdq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE7>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovntdq<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE7>, mrm_v<hold<Y...>, T...>>;
};

//  vmovntdq ANY [MR] r  [66] E7 

template<typename ...T, typename ...Y>
struct asm_vmovntdq<hold<zip<reg64>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE7>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovntdq<hold<ptr<reg256, T...>, zip<reg256>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE7>, mrm_v<hold<Y...>, T...>>;
};

//  vmovntdqa ANY [RM] r  [66] 2A 
template<class T, class Enable = bool> struct asm_vmovntdqa {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','n','t','d','q','a', str...>, hold<T...>> {
    using value = typename asm_vmovntdqa<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovntdqa<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovntdqa<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2A>, mrm_v<hold<T...>, Y...>>;
};

//  vmovntdqa ANY [RM] r  [66] 2A 

template<typename ...T, typename ...Y>
struct asm_vmovntdqa<hold<zip<reg256>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovntdqa<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2A>, mrm_v<hold<T...>, Y...>>;
};

//  vmovntpd ANY [MR] r  [66] 2B 
template<class T, class Enable = bool> struct asm_vmovntpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','n','t','p','d', str...>, hold<T...>> {
    using value = typename asm_vmovntpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovntpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2B>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovntpd<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2B>, mrm_v<hold<Y...>, T...>>;
};

//  vmovntpd ANY [MR] r  [66] 2B 

template<typename ...T, typename ...Y>
struct asm_vmovntpd<hold<zip<reg64>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2B>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovntpd<hold<ptr<reg256, T...>, zip<reg256>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2B>, mrm_v<hold<Y...>, T...>>;
};

//  vmovntps ANY [MR] r  [] 2B 
template<class T, class Enable = bool> struct asm_vmovntps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','n','t','p','s', str...>, hold<T...>> {
    using value = typename asm_vmovntps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovntps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x2B>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovntps<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x2B>, mrm_v<hold<Y...>, T...>>;
};

//  vmovntps ANY [MR] r  [] 2B 

template<typename ...T, typename ...Y>
struct asm_vmovntps<hold<zip<reg64>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x2B>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovntps<hold<ptr<reg256, T...>, zip<reg256>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x2B>, mrm_v<hold<Y...>, T...>>;
};

//  vmovq X64 [MR] r  [66] 7E 
template<class T, class Enable = bool> struct asm_vmovq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','q', str...>, hold<T...>> {
    using value = typename asm_vmovq<hold<T...>>::value;
};
//  vmovq ANY [RM] r  [F3] 7E 

template<typename ...T, typename ...Y>
struct asm_vmovq<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x7E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovq<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x7E>, mrm_v<hold<T...>, Y...>>;
};

//  vmovq X64 [RM] r  [66] 6E 

//  vmovq ANY [MR] r  [66] D6 

template<typename ...T, typename ...Y>
struct asm_vmovq<hold<ptr<reg64, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD6>, mrm_v<hold<Y...>, T...>>;
};

//  vmovsd ANY [MR] r  [F2] 11 
template<class T, class Enable = bool> struct asm_vmovsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','s','d', str...>, hold<T...>> {
    using value = typename asm_vmovsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovsd<hold<ptr<reg64, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x11>, mrm_v<hold<Y...>, T...>>;
};

//  vmovsd ANY [RM] r  [F2] 10 

template<typename ...T, typename ...Y>
struct asm_vmovsd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovsd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x10>, mrm_v<hold<T...>, Y...>>;
};

//  vmovsd ANY [MVR] r  [F2] 11 

//  vmovsd ANY [RVM] r  [F2] 10 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmovsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x10>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

//  vmovshdup ANY [RM] r  [F3] 16 
template<class T, class Enable = bool> struct asm_vmovshdup {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','s','h','d','u','p', str...>, hold<T...>> {
    using value = typename asm_vmovshdup<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovshdup<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x16>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovshdup<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x16>, mrm_v<hold<T...>, Y...>>;
};

//  vmovshdup ANY [RM] r  [F3] 16 

template<typename ...T, typename ...Y>
struct asm_vmovshdup<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x16>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovshdup<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x16>, mrm_v<hold<T...>, Y...>>;
};

//  vmovsldup ANY [RM] r  [F3] 12 
template<class T, class Enable = bool> struct asm_vmovsldup {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','s','l','d','u','p', str...>, hold<T...>> {
    using value = typename asm_vmovsldup<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovsldup<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovsldup<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x12>, mrm_v<hold<T...>, Y...>>;
};

//  vmovsldup ANY [RM] r  [F3] 12 

template<typename ...T, typename ...Y>
struct asm_vmovsldup<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovsldup<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x12>, mrm_v<hold<T...>, Y...>>;
};

//  vmovss ANY [MR] r  [F3] 11 
template<class T, class Enable = bool> struct asm_vmovss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','s','s', str...>, hold<T...>> {
    using value = typename asm_vmovss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovss<hold<ptr<reg32, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x11>, mrm_v<hold<Y...>, T...>>;
};

//  vmovss ANY [RM] r  [F3] 10 

template<typename ...T, typename ...Y>
struct asm_vmovss<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x10>, mrm_v<hold<T...>, Y...>>;
};

//  vmovss ANY [MVR] r  [F3] 11 

//  vmovss ANY [RVM] r  [F3] 10 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmovss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x10>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

//  vmovupd ANY [RM] r  [] 10 
template<class T, class Enable = bool> struct asm_vmovupd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','u','p','d', str...>, hold<T...>> {
    using value = typename asm_vmovupd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovupd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovupd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x10>, mrm_v<hold<T...>, Y...>>;
};

//  vmovupd ANY [MR] r  [] 11 

template<typename ...T, typename ...Y>
struct asm_vmovupd<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x11>, mrm_v<hold<Y...>, T...>>;
};

//  vmovupd ANY [RM] r  [] 10 

template<typename ...T, typename ...Y>
struct asm_vmovupd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovupd<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x10>, mrm_v<hold<T...>, Y...>>;
};

//  vmovupd ANY [MR] r  [] 11 

template<typename ...T, typename ...Y>
struct asm_vmovupd<hold<ptr<reg256, T...>, zip<reg256>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x11>, mrm_v<hold<Y...>, T...>>;
};

//  vmovups ANY [RM] r  [66] 10 
template<class T, class Enable = bool> struct asm_vmovups {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','u','p','s', str...>, hold<T...>> {
    using value = typename asm_vmovups<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmovups<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovups<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x10>, mrm_v<hold<T...>, Y...>>;
};

//  vmovups ANY [MR] r  [66] 11 

template<typename ...T, typename ...Y>
struct asm_vmovups<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x11>, mrm_v<hold<Y...>, T...>>;
};

//  vmovups ANY [RM] r  [66] 10 

template<typename ...T, typename ...Y>
struct asm_vmovups<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmovups<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x10>, mrm_v<hold<T...>, Y...>>;
};

//  vmovups ANY [MR] r  [66] 11 

template<typename ...T, typename ...Y>
struct asm_vmovups<hold<ptr<reg256, T...>, zip<reg256>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x11>, mrm_v<hold<Y...>, T...>>;
};

//  vmpsadbw ANY [RVMI] r  [66] 42 
template<class T, class Enable = bool> struct asm_vmpsadbw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','p','s','a','d','b','w', str...>, hold<T...>> {
    using value = typename asm_vmpsadbw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vmpsadbw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x42>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vmpsadbw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x42>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vmpsadbw ANY [RVMI] r  [66] 42 

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vmpsadbw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x42>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vmpsadbw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x42>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vmptrld ANY [M] 6  [] C7 
template<class T, class Enable = bool> struct asm_vmptrld {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','p','t','r','l','d', str...>, hold<T...>> {
    using value = typename asm_vmptrld<hold<T...>>::value;
};
template<typename ...T>
struct asm_vmptrld<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

template<typename ...T>
struct asm_vmptrld<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, mrm_v<hold<reg<6>>, T...>>;
};

//  vmptrst ANY [M] 7  [] C7 
template<class T, class Enable = bool> struct asm_vmptrst {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','p','t','r','s','t', str...>, hold<T...>> {
    using value = typename asm_vmptrst<hold<T...>>::value;
};
template<typename ...T>
struct asm_vmptrst<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<7>>>::value>;
};

template<typename ...T>
struct asm_vmptrst<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, mrm_v<hold<reg<7>>, T...>>;
};

//  vmread X86 [MR] r  [] 78 
template<class T, class Enable = bool> struct asm_vmread {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','r','e','a','d', str...>, hold<T...>> {
    using value = typename asm_vmread<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmread<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x78>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmread<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x78>, mrm_v<hold<Y...>, T...>>;
};

//  vmread X64 [MR] r  [] 78 

template<typename ...T, typename ...Y>
struct asm_vmread<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x78>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmread<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x78>, mrm_v<hold<Y...>, T...>>;
};

//  vmresume ANY [NONE]   [] C3 
template<class T, class Enable = bool> struct asm_vmresume {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','r','e','s','u','m','e', str...>, hold<T...>> {
    using value = typename asm_vmresume<hold<T...>>::value;
};
template <> struct asm_vmresume<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xC3>>; };
//  vmrun X86 [NONE]   [] D8 
template<class T, class Enable = bool> struct asm_vmrun {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','r','u','n', str...>, hold<T...>> {
    using value = typename asm_vmrun<hold<T...>>::value;
};
template <>
struct asm_vmrun<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xD8>>; };
//  vmsave X86 [NONE]   [] DB 
template<class T, class Enable = bool> struct asm_vmsave {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','s','a','v','e', str...>, hold<T...>> {
    using value = typename asm_vmsave<hold<T...>>::value;
};
template <>
struct asm_vmsave<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xDB>>; };
//  vmulpd ANY [RVM] r  [66] 59 
template<class T, class Enable = bool> struct asm_vmulpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','u','l','p','d', str...>, hold<T...>> {
    using value = typename asm_vmulpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmulpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x59>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmulpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x59>, mrm_v<hold<T...>, Z...>>;
};

//  vmulpd ANY [RVM] r  [66] 59 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmulpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x59>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmulpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x59>, mrm_v<hold<T...>, Z...>>;
};

//  vmulps ANY [RVM] r  [] 59 
template<class T, class Enable = bool> struct asm_vmulps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','u','l','p','s', str...>, hold<T...>> {
    using value = typename asm_vmulps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmulps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x59>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmulps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x59>, mrm_v<hold<T...>, Z...>>;
};

//  vmulps ANY [RVM] r  [] 59 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmulps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x59>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmulps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x59>, mrm_v<hold<T...>, Z...>>;
};

//  vmulsd ANY [RVM] r  [F2] 59 
template<class T, class Enable = bool> struct asm_vmulsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','u','l','s','d', str...>, hold<T...>> {
    using value = typename asm_vmulsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmulsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x59>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmulsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x59>, mrm_v<hold<T...>, Z...>>;
};

//  vmulss ANY [RVM] r  [F3] 59 
template<class T, class Enable = bool> struct asm_vmulss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','u','l','s','s', str...>, hold<T...>> {
    using value = typename asm_vmulss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmulss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x59>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vmulss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x59>, mrm_v<hold<T...>, Z...>>;
};

//  vmwrite X86 [RM] r  [] 79 
template<class T, class Enable = bool> struct asm_vmwrite {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','w','r','i','t','e', str...>, hold<T...>> {
    using value = typename asm_vmwrite<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vmwrite<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x79>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmwrite<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x79>, mrm_v<hold<T...>, Y...>>;
};

//  vmwrite X64 [RM] r  [] 79 

template<typename ...T, typename ...Y>
struct asm_vmwrite<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x79>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vmwrite<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x79>, mrm_v<hold<T...>, Y...>>;
};

//  vmxon ANY [M] 6  [F3] C7 
template<class T, class Enable = bool> struct asm_vmxon {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','x','o','n', str...>, hold<T...>> {
    using value = typename asm_vmxon<hold<T...>>::value;
};
template<typename ...T>
struct asm_vmxon<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<6>>>::value>;
};

template<typename ...T>
struct asm_vmxon<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, mrm_v<hold<reg<6>>, T...>>;
};

//  vorpd ANY [RVM] r  [66] 56 
template<class T, class Enable = bool> struct asm_vorpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','o','r','p','d', str...>, hold<T...>> {
    using value = typename asm_vorpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vorpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x56>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vorpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x56>, mrm_v<hold<T...>, Z...>>;
};

//  vorpd ANY [RVM] r  [66] 56 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vorpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x56>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vorpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x56>, mrm_v<hold<T...>, Z...>>;
};

//  vorps ANY [RVM] r  [] 56 
template<class T, class Enable = bool> struct asm_vorps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','o','r','p','s', str...>, hold<T...>> {
    using value = typename asm_vorps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vorps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x56>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vorps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x56>, mrm_v<hold<T...>, Z...>>;
};

//  vorps ANY [RVM] r  [] 56 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vorps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x56>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vorps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x56>, mrm_v<hold<T...>, Z...>>;
};

//  vpabsb ANY [RM] r  [66] 1C 
template<class T, class Enable = bool> struct asm_vpabsb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','b','s','b', str...>, hold<T...>> {
    using value = typename asm_vpabsb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpabsb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x1C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpabsb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x1C>, mrm_v<hold<T...>, Y...>>;
};

//  vpabsb ANY [RM] r  [66] 1C 

template<typename ...T, typename ...Y>
struct asm_vpabsb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x1C>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpabsb<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x1C>, mrm_v<hold<T...>, Y...>>;
};

//  vpabsd ANY [RM] r  [66] 1E 
template<class T, class Enable = bool> struct asm_vpabsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','b','s','d', str...>, hold<T...>> {
    using value = typename asm_vpabsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpabsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x1E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpabsd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x1E>, mrm_v<hold<T...>, Y...>>;
};

//  vpabsd ANY [RM] r  [66] 1E 

template<typename ...T, typename ...Y>
struct asm_vpabsd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x1E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpabsd<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x1E>, mrm_v<hold<T...>, Y...>>;
};

//  vpabsw ANY [RM] r  [66] 1D 
template<class T, class Enable = bool> struct asm_vpabsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','b','s','w', str...>, hold<T...>> {
    using value = typename asm_vpabsw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpabsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x1D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpabsw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x1D>, mrm_v<hold<T...>, Y...>>;
};

//  vpabsw ANY [RM] r  [66] 1D 

template<typename ...T, typename ...Y>
struct asm_vpabsw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x1D>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpabsw<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x1D>, mrm_v<hold<T...>, Y...>>;
};

//  vpackssdw ANY [RVM] r  [66] 6B 
template<class T, class Enable = bool> struct asm_vpackssdw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','c','k','s','s','d','w', str...>, hold<T...>> {
    using value = typename asm_vpackssdw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpackssdw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6B>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpackssdw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6B>, mrm_v<hold<T...>, Z...>>;
};

//  vpackssdw ANY [RVM] r  [66] 6B 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpackssdw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6B>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpackssdw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6B>, mrm_v<hold<T...>, Z...>>;
};

//  vpacksswb ANY [RVM] r  [66] 63 
template<class T, class Enable = bool> struct asm_vpacksswb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','c','k','s','s','w','b', str...>, hold<T...>> {
    using value = typename asm_vpacksswb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpacksswb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x63>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpacksswb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x63>, mrm_v<hold<T...>, Z...>>;
};

//  vpacksswb ANY [RVM] r  [66] 63 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpacksswb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x63>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpacksswb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x63>, mrm_v<hold<T...>, Z...>>;
};

//  vpackusdw ANY [RVM] r  [66] 2B 
template<class T, class Enable = bool> struct asm_vpackusdw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','c','k','u','s','d','w', str...>, hold<T...>> {
    using value = typename asm_vpackusdw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpackusdw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2B>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpackusdw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2B>, mrm_v<hold<T...>, Z...>>;
};

//  vpackusdw ANY [RVM] r  [66] 2B 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpackusdw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2B>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpackusdw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2B>, mrm_v<hold<T...>, Z...>>;
};

//  vpackuswb ANY [RVM] r  [66] 67 
template<class T, class Enable = bool> struct asm_vpackuswb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','c','k','u','s','w','b', str...>, hold<T...>> {
    using value = typename asm_vpackuswb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpackuswb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x67>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpackuswb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x67>, mrm_v<hold<T...>, Z...>>;
};

//  vpackuswb ANY [RVM] r  [66] 67 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpackuswb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x67>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpackuswb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x67>, mrm_v<hold<T...>, Z...>>;
};

//  vpaddb ANY [RVM] r  [66] FC 
template<class T, class Enable = bool> struct asm_vpaddb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','d','d','b', str...>, hold<T...>> {
    using value = typename asm_vpaddb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFC>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFC>, mrm_v<hold<T...>, Z...>>;
};

//  vpaddb ANY [RVM] r  [66] FC 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFC>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFC>, mrm_v<hold<T...>, Z...>>;
};

//  vpaddd ANY [RVM] r  [66] FE 
template<class T, class Enable = bool> struct asm_vpaddd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','d','d','d', str...>, hold<T...>> {
    using value = typename asm_vpaddd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFE>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFE>, mrm_v<hold<T...>, Z...>>;
};

//  vpaddd ANY [RVM] r  [66] FE 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFE>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFE>, mrm_v<hold<T...>, Z...>>;
};

//  vpaddq ANY [RVM] r  [66] D4 
template<class T, class Enable = bool> struct asm_vpaddq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','d','d','q', str...>, hold<T...>> {
    using value = typename asm_vpaddq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD4>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD4>, mrm_v<hold<T...>, Z...>>;
};

//  vpaddq ANY [RVM] r  [66] D4 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD4>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD4>, mrm_v<hold<T...>, Z...>>;
};

//  vpaddsb ANY [RVM] r  [66] EC 
template<class T, class Enable = bool> struct asm_vpaddsb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','d','d','s','b', str...>, hold<T...>> {
    using value = typename asm_vpaddsb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddsb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEC>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddsb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEC>, mrm_v<hold<T...>, Z...>>;
};

//  vpaddsb ANY [RVM] r  [66] EC 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddsb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEC>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddsb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEC>, mrm_v<hold<T...>, Z...>>;
};

//  vpaddsw ANY [RVM] r  [66] ED 
template<class T, class Enable = bool> struct asm_vpaddsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','d','d','s','w', str...>, hold<T...>> {
    using value = typename asm_vpaddsw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xED>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xED>, mrm_v<hold<T...>, Z...>>;
};

//  vpaddsw ANY [RVM] r  [66] ED 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddsw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xED>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddsw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xED>, mrm_v<hold<T...>, Z...>>;
};

//  vpaddusb ANY [RVM] r  [66] DC 
template<class T, class Enable = bool> struct asm_vpaddusb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','d','d','u','s','b', str...>, hold<T...>> {
    using value = typename asm_vpaddusb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddusb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDC>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddusb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDC>, mrm_v<hold<T...>, Z...>>;
};

//  vpaddusb ANY [RVM] r  [66] DC 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddusb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDC>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddusb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDC>, mrm_v<hold<T...>, Z...>>;
};

//  vpaddusw ANY [RVM] r  [66] DD 
template<class T, class Enable = bool> struct asm_vpaddusw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','d','d','u','s','w', str...>, hold<T...>> {
    using value = typename asm_vpaddusw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddusw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDD>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddusw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDD>, mrm_v<hold<T...>, Z...>>;
};

//  vpaddusw ANY [RVM] r  [66] DD 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddusw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDD>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddusw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDD>, mrm_v<hold<T...>, Z...>>;
};

//  vpaddw ANY [RVM] r  [66] FD 
template<class T, class Enable = bool> struct asm_vpaddw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','d','d','w', str...>, hold<T...>> {
    using value = typename asm_vpaddw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFD>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFD>, mrm_v<hold<T...>, Z...>>;
};

//  vpaddw ANY [RVM] r  [66] FD 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFD>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpaddw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFD>, mrm_v<hold<T...>, Z...>>;
};

//  vpalignr ANY [RVMI] r  [66] 0F 
template<class T, class Enable = bool> struct asm_vpalignr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','l','i','g','n','r', str...>, hold<T...>> {
    using value = typename asm_vpalignr<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpalignr<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0F>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpalignr<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0F>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpalignr ANY [RVMI] r  [66] 0F 

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpalignr<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0F>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpalignr<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0F>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpand ANY [RVM] r  [66] DB 
template<class T, class Enable = bool> struct asm_vpand {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','n','d', str...>, hold<T...>> {
    using value = typename asm_vpand<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpand<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDB>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpand<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDB>, mrm_v<hold<T...>, Z...>>;
};

//  vpand ANY [RVM] r  [66] DB 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpand<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDB>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpand<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDB>, mrm_v<hold<T...>, Z...>>;
};

//  vpandn ANY [RVM] r  [66] DF 
template<class T, class Enable = bool> struct asm_vpandn {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','n','d','n', str...>, hold<T...>> {
    using value = typename asm_vpandn<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpandn<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDF>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpandn<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDF>, mrm_v<hold<T...>, Z...>>;
};

//  vpandn ANY [RVM] r  [66] DF 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpandn<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDF>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpandn<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDF>, mrm_v<hold<T...>, Z...>>;
};

//  vpavgb ANY [RVM] r  [66] E0 
template<class T, class Enable = bool> struct asm_vpavgb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','v','g','b', str...>, hold<T...>> {
    using value = typename asm_vpavgb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpavgb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE0>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpavgb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE0>, mrm_v<hold<T...>, Z...>>;
};

//  vpavgb ANY [RVM] r  [66] E0 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpavgb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE0>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpavgb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE0>, mrm_v<hold<T...>, Z...>>;
};

//  vpavgw ANY [RVM] r  [66] E3 
template<class T, class Enable = bool> struct asm_vpavgw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','v','g','w', str...>, hold<T...>> {
    using value = typename asm_vpavgw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpavgw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE3>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpavgw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE3>, mrm_v<hold<T...>, Z...>>;
};

//  vpavgw ANY [RVM] r  [66] E3 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpavgw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE3>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpavgw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE3>, mrm_v<hold<T...>, Z...>>;
};

//  vpblendd ANY [RVMI] r  [66] 02 
template<class T, class Enable = bool> struct asm_vpblendd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','b','l','e','n','d','d', str...>, hold<T...>> {
    using value = typename asm_vpblendd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpblendd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x02>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpblendd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x02>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpblendd ANY [RVMI] r  [66] 02 

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpblendd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x02>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpblendd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x02>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpblendvb ANY [RVMS] r  [66] 4C 
template<class T, class Enable = bool> struct asm_vpblendvb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','b','l','e','n','d','v','b', str...>, hold<T...>> {
    using value = typename asm_vpblendvb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpblendvb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x4C>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vpblendvb ANY [RVMS] r  [66] 4C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpblendvb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x4C>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vpblendw ANY [RVMI] r  [66] 0E 
template<class T, class Enable = bool> struct asm_vpblendw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','b','l','e','n','d','w', str...>, hold<T...>> {
    using value = typename asm_vpblendw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpblendw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0E>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpblendw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0E>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpblendw ANY [RVMI] r  [66] 0E 

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpblendw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0E>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpblendw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0E>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpbroadcastb ANY [RM] r  [66] 78 
template<class T, class Enable = bool> struct asm_vpbroadcastb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','b','r','o','a','d','c','a','s','t','b', str...>, hold<T...>> {
    using value = typename asm_vpbroadcastb<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpbroadcastb<hold<zip<reg128>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x78>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpbroadcastb<hold<zip<reg128>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x78>, mrm_v<hold<T...>, Y...>>;
};

//  vpbroadcastb ANY [RM] r  [66] 78 

template<typename ...T, typename ...Y>
struct asm_vpbroadcastb<hold<zip<reg256>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x78>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpbroadcastb<hold<zip<reg256>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x78>, mrm_v<hold<T...>, Y...>>;
};

//  vpbroadcastd ANY [RM] r  [66] 58 
template<class T, class Enable = bool> struct asm_vpbroadcastd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','b','r','o','a','d','c','a','s','t','d', str...>, hold<T...>> {
    using value = typename asm_vpbroadcastd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpbroadcastd<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x58>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpbroadcastd<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x58>, mrm_v<hold<T...>, Y...>>;
};

//  vpbroadcastd ANY [RM] r  [66] 58 

template<typename ...T, typename ...Y>
struct asm_vpbroadcastd<hold<zip<reg256>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x58>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpbroadcastd<hold<zip<reg256>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x58>, mrm_v<hold<T...>, Y...>>;
};

//  vpbroadcastq ANY [RM] r  [66] 59 
template<class T, class Enable = bool> struct asm_vpbroadcastq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','b','r','o','a','d','c','a','s','t','q', str...>, hold<T...>> {
    using value = typename asm_vpbroadcastq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpbroadcastq<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x59>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpbroadcastq<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x59>, mrm_v<hold<T...>, Y...>>;
};

//  vpbroadcastq ANY [RM] r  [66] 59 

template<typename ...T, typename ...Y>
struct asm_vpbroadcastq<hold<zip<reg256>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x59>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpbroadcastq<hold<zip<reg256>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x59>, mrm_v<hold<T...>, Y...>>;
};

//  vpbroadcastw ANY [RM] r  [66] 79 
template<class T, class Enable = bool> struct asm_vpbroadcastw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','b','r','o','a','d','c','a','s','t','w', str...>, hold<T...>> {
    using value = typename asm_vpbroadcastw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpbroadcastw<hold<zip<reg128>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x79>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpbroadcastw<hold<zip<reg128>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x79>, mrm_v<hold<T...>, Y...>>;
};

//  vpbroadcastw ANY [RM] r  [66] 79 

template<typename ...T, typename ...Y>
struct asm_vpbroadcastw<hold<zip<reg256>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x79>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpbroadcastw<hold<zip<reg256>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x79>, mrm_v<hold<T...>, Y...>>;
};

//  vpclmulqdq ANY [RVMI] r  [66] 44 
template<class T, class Enable = bool> struct asm_vpclmulqdq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','l','m','u','l','q','d','q', str...>, hold<T...>> {
    using value = typename asm_vpclmulqdq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpclmulqdq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x44>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpclmulqdq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x44>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpclmulqdq ANY [RVMI] r  [66] 44 

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpclmulqdq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x44>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpclmulqdq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x44>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpcmov ANY [RVSM] r  [] A2 
template<class T, class Enable = bool> struct asm_vpcmov {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','o','v', str...>, hold<T...>> {
    using value = typename asm_vpcmov<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpcmov<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<8>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xA2>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpcmov<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename XOP<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<8>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xA2>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vpcmov ANY [RVMS] r  [] A2 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpcmov<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xA2>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vpcmov ANY [RVSM] r  [] A2 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpcmov<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<8>, disp8<1>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0xA2>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpcmov<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename XOP<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<8>, disp8<1>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0xA2>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vpcmov ANY [RVMS] r  [] A2 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpcmov<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0xA2>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vpcmpeqb ANY [RVM] r  [66] 74 
template<class T, class Enable = bool> struct asm_vpcmpeqb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','e','q','b', str...>, hold<T...>> {
    using value = typename asm_vpcmpeqb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpeqb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x74>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpeqb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x74>, mrm_v<hold<T...>, Z...>>;
};

//  vpcmpeqb ANY [RVM] r  [66] 74 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpeqb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x74>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpeqb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x74>, mrm_v<hold<T...>, Z...>>;
};

//  vpcmpeqd ANY [RVM] r  [66] 76 
template<class T, class Enable = bool> struct asm_vpcmpeqd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','e','q','d', str...>, hold<T...>> {
    using value = typename asm_vpcmpeqd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpeqd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x76>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpeqd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x76>, mrm_v<hold<T...>, Z...>>;
};

//  vpcmpeqd ANY [RVM] r  [66] 76 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpeqd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x76>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpeqd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x76>, mrm_v<hold<T...>, Z...>>;
};

//  vpcmpeqq ANY [RVM] r  [66] 29 
template<class T, class Enable = bool> struct asm_vpcmpeqq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','e','q','q', str...>, hold<T...>> {
    using value = typename asm_vpcmpeqq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpeqq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x29>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpeqq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x29>, mrm_v<hold<T...>, Z...>>;
};

//  vpcmpeqq ANY [RVM] r  [66] 29 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpeqq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x29>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpeqq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x29>, mrm_v<hold<T...>, Z...>>;
};

//  vpcmpeqw ANY [RVM] r  [66] 75 
template<class T, class Enable = bool> struct asm_vpcmpeqw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','e','q','w', str...>, hold<T...>> {
    using value = typename asm_vpcmpeqw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpeqw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x75>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpeqw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x75>, mrm_v<hold<T...>, Z...>>;
};

//  vpcmpeqw ANY [RVM] r  [66] 75 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpeqw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x75>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpeqw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x75>, mrm_v<hold<T...>, Z...>>;
};

//  vpcmpestri ANY [RMI] r  [66] 61 
template<class T, class Enable = bool> struct asm_vpcmpestri {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','e','s','t','r','i', str...>, hold<T...>> {
    using value = typename asm_vpcmpestri<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpcmpestri<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x61>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vpcmpestri<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x61>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vpcmpestrm ANY [RMI] r  [66] 60 
template<class T, class Enable = bool> struct asm_vpcmpestrm {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','e','s','t','r','m', str...>, hold<T...>> {
    using value = typename asm_vpcmpestrm<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpcmpestrm<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x60>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vpcmpestrm<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x60>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vpcmpgtb ANY [RVM] r  [66] 64 
template<class T, class Enable = bool> struct asm_vpcmpgtb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','g','t','b', str...>, hold<T...>> {
    using value = typename asm_vpcmpgtb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpgtb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x64>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpgtb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x64>, mrm_v<hold<T...>, Z...>>;
};

//  vpcmpgtb ANY [RVM] r  [66] 64 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpgtb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x64>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpgtb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x64>, mrm_v<hold<T...>, Z...>>;
};

//  vpcmpgtd ANY [RVM] r  [66] 66 
template<class T, class Enable = bool> struct asm_vpcmpgtd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','g','t','d', str...>, hold<T...>> {
    using value = typename asm_vpcmpgtd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpgtd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x66>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpgtd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x66>, mrm_v<hold<T...>, Z...>>;
};

//  vpcmpgtd ANY [RVM] r  [66] 66 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpgtd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x66>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpgtd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x66>, mrm_v<hold<T...>, Z...>>;
};

//  vpcmpgtq ANY [RVM] r  [66] 37 
template<class T, class Enable = bool> struct asm_vpcmpgtq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','g','t','q', str...>, hold<T...>> {
    using value = typename asm_vpcmpgtq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpgtq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x37>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpgtq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x37>, mrm_v<hold<T...>, Z...>>;
};

//  vpcmpgtq ANY [RVM] r  [66] 37 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpgtq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x37>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpgtq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x37>, mrm_v<hold<T...>, Z...>>;
};

//  vpcmpgtw ANY [RVM] r  [66] 65 
template<class T, class Enable = bool> struct asm_vpcmpgtw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','g','t','w', str...>, hold<T...>> {
    using value = typename asm_vpcmpgtw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpgtw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x65>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpgtw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x65>, mrm_v<hold<T...>, Z...>>;
};

//  vpcmpgtw ANY [RVM] r  [66] 65 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpgtw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x65>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpcmpgtw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x65>, mrm_v<hold<T...>, Z...>>;
};

//  vpcmpistri ANY [RMI] r  [66] 63 
template<class T, class Enable = bool> struct asm_vpcmpistri {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','i','s','t','r','i', str...>, hold<T...>> {
    using value = typename asm_vpcmpistri<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpcmpistri<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x63>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vpcmpistri<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x63>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vpcmpistrm ANY [RMI] r  [66] 62 
template<class T, class Enable = bool> struct asm_vpcmpistrm {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','i','s','t','r','m', str...>, hold<T...>> {
    using value = typename asm_vpcmpistrm<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpcmpistrm<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x62>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vpcmpistrm<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x62>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vpcomb ANY [RVMI] r  [] CC 
template<class T, class Enable = bool> struct asm_vpcomb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','o','m','b', str...>, hold<T...>> {
    using value = typename asm_vpcomb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpcomb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xCC>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpcomb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xCC>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpcomd ANY [RVMI] r  [] CE 
template<class T, class Enable = bool> struct asm_vpcomd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','o','m','d', str...>, hold<T...>> {
    using value = typename asm_vpcomd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpcomd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xCE>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpcomd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xCE>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpcomq ANY [RVMI] r  [] CF 
template<class T, class Enable = bool> struct asm_vpcomq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','o','m','q', str...>, hold<T...>> {
    using value = typename asm_vpcomq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpcomq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xCF>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpcomq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xCF>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpcomub ANY [RVMI] r  [] EC 
template<class T, class Enable = bool> struct asm_vpcomub {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','o','m','u','b', str...>, hold<T...>> {
    using value = typename asm_vpcomub<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpcomub<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xEC>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpcomub<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xEC>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpcomud ANY [RVMI] r  [] EE 
template<class T, class Enable = bool> struct asm_vpcomud {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','o','m','u','d', str...>, hold<T...>> {
    using value = typename asm_vpcomud<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpcomud<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xEE>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpcomud<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xEE>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpcomuq ANY [RVMI] r  [] EF 
template<class T, class Enable = bool> struct asm_vpcomuq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','o','m','u','q', str...>, hold<T...>> {
    using value = typename asm_vpcomuq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpcomuq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xEF>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpcomuq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xEF>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpcomuw ANY [RVMI] r  [] ED 
template<class T, class Enable = bool> struct asm_vpcomuw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','o','m','u','w', str...>, hold<T...>> {
    using value = typename asm_vpcomuw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpcomuw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xED>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpcomuw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xED>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpcomw ANY [RVMI] r  [] CD 
template<class T, class Enable = bool> struct asm_vpcomw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','o','m','w', str...>, hold<T...>> {
    using value = typename asm_vpcomw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpcomw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xCD>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpcomw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xCD>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpdpbusd ANY [RVM] r  [66] 50 
template<class T, class Enable = bool> struct asm_vpdpbusd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','d','p','b','u','s','d', str...>, hold<T...>> {
    using value = typename asm_vpdpbusd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpdpbusd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x50>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpdpbusd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x50>, mrm_v<hold<T...>, Z...>>;
};

//  vpdpbusd ANY [RVM] r  [66] 50 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpdpbusd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x50>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpdpbusd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x50>, mrm_v<hold<T...>, Z...>>;
};

//  vpdpbusds ANY [RVM] r  [66] 51 
template<class T, class Enable = bool> struct asm_vpdpbusds {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','d','p','b','u','s','d','s', str...>, hold<T...>> {
    using value = typename asm_vpdpbusds<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpdpbusds<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x51>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpdpbusds<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x51>, mrm_v<hold<T...>, Z...>>;
};

//  vpdpbusds ANY [RVM] r  [66] 51 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpdpbusds<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x51>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpdpbusds<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x51>, mrm_v<hold<T...>, Z...>>;
};

//  vpdpwssd ANY [RVM] r  [66] 52 
template<class T, class Enable = bool> struct asm_vpdpwssd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','d','p','w','s','s','d', str...>, hold<T...>> {
    using value = typename asm_vpdpwssd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpdpwssd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x52>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpdpwssd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x52>, mrm_v<hold<T...>, Z...>>;
};

//  vpdpwssd ANY [RVM] r  [66] 52 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpdpwssd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x52>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpdpwssd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x52>, mrm_v<hold<T...>, Z...>>;
};

//  vpdpwssds ANY [RVM] r  [66] 53 
template<class T, class Enable = bool> struct asm_vpdpwssds {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','d','p','w','s','s','d','s', str...>, hold<T...>> {
    using value = typename asm_vpdpwssds<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpdpwssds<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x53>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpdpwssds<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x53>, mrm_v<hold<T...>, Z...>>;
};

//  vpdpwssds ANY [RVM] r  [66] 53 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpdpwssds<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x53>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpdpwssds<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x53>, mrm_v<hold<T...>, Z...>>;
};

//  vperm2f128 ANY [RVMI] r  [66] 06 
template<class T, class Enable = bool> struct asm_vperm2f128 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','2','f','1','2','8', str...>, hold<T...>> {
    using value = typename asm_vperm2f128<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vperm2f128<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x06>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vperm2f128<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x06>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vperm2i128 ANY [RVMI] r  [66] 46 
template<class T, class Enable = bool> struct asm_vperm2i128 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','2','i','1','2','8', str...>, hold<T...>> {
    using value = typename asm_vperm2i128<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vperm2i128<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x46>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vperm2i128<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x46>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpermd ANY [RVM] r  [66] 36 
template<class T, class Enable = bool> struct asm_vpermd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','d', str...>, hold<T...>> {
    using value = typename asm_vpermd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpermd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x36>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpermd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x36>, mrm_v<hold<T...>, Z...>>;
};

//  vpermil2pd ANY [RVMSI] r  [66] 49 
template<class T, class Enable = bool> struct asm_vpermil2pd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','i','l','2','p','d', str...>, hold<T...>> {
    using value = typename asm_vpermil2pd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
struct asm_vpermil2pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>, ub<P>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x49>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4 | P>>;
};

//  vpermil2pd ANY [RVSMI] r  [66] 49 

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
struct asm_vpermil2pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>, ub<P>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x49>, typename modrm<hold<O...>, hold<T...>>::value, byte_seq<reg_n<Z...>::value  << 4 | P>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
struct asm_vpermil2pd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>, ub<P>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x49>, mrm_v<hold<T...>, O...>, byte_seq<reg_n<Z...>::value  << 4 | P>>;
};

//  vpermil2pd ANY [RVMSI] r  [66] 49 

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
struct asm_vpermil2pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>, ub<P>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x49>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4 | P>>;
};

//  vpermil2pd ANY [RVSMI] r  [66] 49 

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
struct asm_vpermil2pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>, ub<P>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x49>, typename modrm<hold<O...>, hold<T...>>::value, byte_seq<reg_n<Z...>::value  << 4 | P>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
struct asm_vpermil2pd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>, ub<P>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x49>, mrm_v<hold<T...>, O...>, byte_seq<reg_n<Z...>::value  << 4 | P>>;
};

//  vpermil2ps ANY [RVMSI] r  [66] 48 
template<class T, class Enable = bool> struct asm_vpermil2ps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','i','l','2','p','s', str...>, hold<T...>> {
    using value = typename asm_vpermil2ps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
struct asm_vpermil2ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>, ub<P>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x48>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4 | P>>;
};

//  vpermil2ps ANY [RVSMI] r  [66] 48 

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
struct asm_vpermil2ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>, ub<P>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x48>, typename modrm<hold<O...>, hold<T...>>::value, byte_seq<reg_n<Z...>::value  << 4 | P>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
struct asm_vpermil2ps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>, ub<P>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x48>, mrm_v<hold<T...>, O...>, byte_seq<reg_n<Z...>::value  << 4 | P>>;
};

//  vpermil2ps ANY [RVMSI] r  [66] 48 

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
struct asm_vpermil2ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>, ub<P>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x48>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4 | P>>;
};

//  vpermil2ps ANY [RVSMI] r  [66] 48 

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
struct asm_vpermil2ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>, ub<P>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x48>, typename modrm<hold<O...>, hold<T...>>::value, byte_seq<reg_n<Z...>::value  << 4 | P>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
struct asm_vpermil2ps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>, ub<P>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x48>, mrm_v<hold<T...>, O...>, byte_seq<reg_n<Z...>::value  << 4 | P>>;
};

//  vpermilpd ANY [RVM] r  [66] 0D 
template<class T, class Enable = bool> struct asm_vpermilpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','i','l','p','d', str...>, hold<T...>> {
    using value = typename asm_vpermilpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpermilpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpermilpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0D>, mrm_v<hold<T...>, Z...>>;
};

//  vpermilpd ANY [RMI] r  [66] 05 

template<typename ...T, typename ...Y, class Z>
struct asm_vpermilpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x05>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vpermilpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x05>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vpermilpd ANY [RVM] r  [66] 0D 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpermilpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpermilpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0D>, mrm_v<hold<T...>, Z...>>;
};

//  vpermilpd ANY [RMI] r  [66] 05 

template<typename ...T, typename ...Y, class Z>
struct asm_vpermilpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x05>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vpermilpd<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x05>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vpermilps ANY [RVM] r  [66] 0C 
template<class T, class Enable = bool> struct asm_vpermilps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','i','l','p','s', str...>, hold<T...>> {
    using value = typename asm_vpermilps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpermilps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpermilps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0C>, mrm_v<hold<T...>, Z...>>;
};

//  vpermilps ANY [RMI] r  [66] 04 

template<typename ...T, typename ...Y, class Z>
struct asm_vpermilps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x04>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vpermilps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x04>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vpermilps ANY [RVM] r  [66] 0C 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpermilps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpermilps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0C>, mrm_v<hold<T...>, Z...>>;
};

//  vpermilps ANY [RMI] r  [66] 04 

template<typename ...T, typename ...Y, class Z>
struct asm_vpermilps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x04>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vpermilps<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x04>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vpermpd ANY [RMI] r  [66] 01 
template<class T, class Enable = bool> struct asm_vpermpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','p','d', str...>, hold<T...>> {
    using value = typename asm_vpermpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpermpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<1>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x01>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vpermpd<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<1>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x01>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vpermps ANY [RVM] r  [66] 16 
template<class T, class Enable = bool> struct asm_vpermps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','p','s', str...>, hold<T...>> {
    using value = typename asm_vpermps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpermps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x16>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpermps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x16>, mrm_v<hold<T...>, Z...>>;
};

//  vpermq ANY [RMI] r  [66] 00 
template<class T, class Enable = bool> struct asm_vpermq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','q', str...>, hold<T...>> {
    using value = typename asm_vpermq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpermq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<1>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x00>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vpermq<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<1>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x00>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vpextrb ANY [MRI] r  [66] 14 
template<class T, class Enable = bool> struct asm_vpextrb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','x','t','r','b', str...>, hold<T...>> {
    using value = typename asm_vpextrb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpextrb<hold<ptr<reg8, T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x14>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  vpextrd ANY [MRI] r  [66] 16 
template<class T, class Enable = bool> struct asm_vpextrd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','x','t','r','d', str...>, hold<T...>> {
    using value = typename asm_vpextrd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpextrd<hold<ptr<reg32, T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x16>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  vpextrq X64 [MRI] r  [66] 16 
template<class T, class Enable = bool> struct asm_vpextrq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','x','t','r','q', str...>, hold<T...>> {
    using value = typename asm_vpextrq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpextrq<hold<ptr<reg64, T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<3>, disp8<1>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x16>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  vpextrw ANY [RMI] r  [66] C5 
template<class T, class Enable = bool> struct asm_vpextrw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','x','t','r','w', str...>, hold<T...>> {
    using value = typename asm_vpextrw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpextrw<hold<zip<reg32>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xC5>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

//  vpextrw ANY [MRI] r  [66] 15 

template<typename ...T, typename ...Y, class Z>
struct asm_vpextrw<hold<ptr<reg16, T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x15>, mrm_v<hold<Y...>, T...>, typename u8_8<Z>::value>;
};

//  vpgatherdd ANY [RMV] r  [66] 90 
template<class T, class Enable = bool> struct asm_vpgatherdd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','g','a','t','h','e','r','d','d', str...>, hold<T...>> {
    using value = typename asm_vpgatherdd<hold<T...>>::value;
};
//  vpgatherdd ANY [RMV] r  [66] 90 

//  vpgatherdq ANY [RMV] r  [66] 90 
template<class T, class Enable = bool> struct asm_vpgatherdq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','g','a','t','h','e','r','d','q', str...>, hold<T...>> {
    using value = typename asm_vpgatherdq<hold<T...>>::value;
};
//  vpgatherdq ANY [RMV] r  [66] 90 

//  vpgatherqd ANY [RMV] r  [66] 91 
template<class T, class Enable = bool> struct asm_vpgatherqd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','g','a','t','h','e','r','q','d', str...>, hold<T...>> {
    using value = typename asm_vpgatherqd<hold<T...>>::value;
};
//  vpgatherqd ANY [RMV] r  [66] 91 

//  vpgatherqq ANY [RMV] r  [66] 91 
template<class T, class Enable = bool> struct asm_vpgatherqq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','g','a','t','h','e','r','q','q', str...>, hold<T...>> {
    using value = typename asm_vpgatherqq<hold<T...>>::value;
};
//  vpgatherqq ANY [RMV] r  [66] 91 

//  vphaddbd ANY [RM] r  [] C2 
template<class T, class Enable = bool> struct asm_vphaddbd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','b','d', str...>, hold<T...>> {
    using value = typename asm_vphaddbd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vphaddbd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC2>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vphaddbd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC2>, mrm_v<hold<T...>, Y...>>;
};

//  vphaddbq ANY [RM] r  [] C3 
template<class T, class Enable = bool> struct asm_vphaddbq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','b','q', str...>, hold<T...>> {
    using value = typename asm_vphaddbq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vphaddbq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC3>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vphaddbq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC3>, mrm_v<hold<T...>, Y...>>;
};

//  vphaddbw ANY [RM] r  [] C1 
template<class T, class Enable = bool> struct asm_vphaddbw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','b','w', str...>, hold<T...>> {
    using value = typename asm_vphaddbw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vphaddbw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC1>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vphaddbw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC1>, mrm_v<hold<T...>, Y...>>;
};

//  vphaddd ANY [RVM] r  [66] 02 
template<class T, class Enable = bool> struct asm_vphaddd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','d', str...>, hold<T...>> {
    using value = typename asm_vphaddd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphaddd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x02>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphaddd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x02>, mrm_v<hold<T...>, Z...>>;
};

//  vphaddd ANY [RVM] r  [66] 02 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphaddd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x02>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphaddd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x02>, mrm_v<hold<T...>, Z...>>;
};

//  vphadddq ANY [RM] r  [] CB 
template<class T, class Enable = bool> struct asm_vphadddq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','d','q', str...>, hold<T...>> {
    using value = typename asm_vphadddq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vphadddq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xCB>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vphadddq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xCB>, mrm_v<hold<T...>, Y...>>;
};

//  vphaddsw ANY [RVM] r  [66] 03 
template<class T, class Enable = bool> struct asm_vphaddsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','s','w', str...>, hold<T...>> {
    using value = typename asm_vphaddsw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphaddsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x03>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphaddsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x03>, mrm_v<hold<T...>, Z...>>;
};

//  vphaddsw ANY [RVM] r  [66] 03 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphaddsw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x03>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphaddsw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x03>, mrm_v<hold<T...>, Z...>>;
};

//  vphaddubd ANY [RM] r  [] D2 
template<class T, class Enable = bool> struct asm_vphaddubd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','u','b','d', str...>, hold<T...>> {
    using value = typename asm_vphaddubd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vphaddubd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD2>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vphaddubd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD2>, mrm_v<hold<T...>, Y...>>;
};

//  vphaddubq ANY [RM] r  [] D3 
template<class T, class Enable = bool> struct asm_vphaddubq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','u','b','q', str...>, hold<T...>> {
    using value = typename asm_vphaddubq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vphaddubq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD3>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vphaddubq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD3>, mrm_v<hold<T...>, Y...>>;
};

//  vphaddubw ANY [RM] r  [] D1 
template<class T, class Enable = bool> struct asm_vphaddubw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','u','b','w', str...>, hold<T...>> {
    using value = typename asm_vphaddubw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vphaddubw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD1>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vphaddubw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD1>, mrm_v<hold<T...>, Y...>>;
};

//  vphaddudq ANY [RM] r  [] DB 
template<class T, class Enable = bool> struct asm_vphaddudq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','u','d','q', str...>, hold<T...>> {
    using value = typename asm_vphaddudq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vphaddudq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xDB>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vphaddudq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xDB>, mrm_v<hold<T...>, Y...>>;
};

//  vphadduwd ANY [RM] r  [] D6 
template<class T, class Enable = bool> struct asm_vphadduwd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','u','w','d', str...>, hold<T...>> {
    using value = typename asm_vphadduwd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vphadduwd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vphadduwd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD6>, mrm_v<hold<T...>, Y...>>;
};

//  vphadduwq ANY [RM] r  [] D7 
template<class T, class Enable = bool> struct asm_vphadduwq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','u','w','q', str...>, hold<T...>> {
    using value = typename asm_vphadduwq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vphadduwq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD7>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vphadduwq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD7>, mrm_v<hold<T...>, Y...>>;
};

//  vphaddw ANY [RVM] r  [66] 01 
template<class T, class Enable = bool> struct asm_vphaddw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','w', str...>, hold<T...>> {
    using value = typename asm_vphaddw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphaddw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x01>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphaddw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x01>, mrm_v<hold<T...>, Z...>>;
};

//  vphaddw ANY [RVM] r  [66] 01 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphaddw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x01>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphaddw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x01>, mrm_v<hold<T...>, Z...>>;
};

//  vphaddwd ANY [RM] r  [] C6 
template<class T, class Enable = bool> struct asm_vphaddwd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','w','d', str...>, hold<T...>> {
    using value = typename asm_vphaddwd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vphaddwd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC6>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vphaddwd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC6>, mrm_v<hold<T...>, Y...>>;
};

//  vphaddwq ANY [RM] r  [] C7 
template<class T, class Enable = bool> struct asm_vphaddwq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','w','q', str...>, hold<T...>> {
    using value = typename asm_vphaddwq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vphaddwq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC7>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vphaddwq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC7>, mrm_v<hold<T...>, Y...>>;
};

//  vphminposuw ANY [RM] r  [66] 41 
template<class T, class Enable = bool> struct asm_vphminposuw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','m','i','n','p','o','s','u','w', str...>, hold<T...>> {
    using value = typename asm_vphminposuw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vphminposuw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x41>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vphminposuw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x41>, mrm_v<hold<T...>, Y...>>;
};

//  vphsubbw ANY [RM] r  [] E1 
template<class T, class Enable = bool> struct asm_vphsubbw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','s','u','b','b','w', str...>, hold<T...>> {
    using value = typename asm_vphsubbw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vphsubbw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xE1>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vphsubbw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xE1>, mrm_v<hold<T...>, Y...>>;
};

//  vphsubd ANY [RVM] r  [66] 06 
template<class T, class Enable = bool> struct asm_vphsubd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','s','u','b','d', str...>, hold<T...>> {
    using value = typename asm_vphsubd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphsubd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x06>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphsubd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x06>, mrm_v<hold<T...>, Z...>>;
};

//  vphsubd ANY [RVM] r  [66] 06 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphsubd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x06>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphsubd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x06>, mrm_v<hold<T...>, Z...>>;
};

//  vphsubdq ANY [RM] r  [] E3 
template<class T, class Enable = bool> struct asm_vphsubdq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','s','u','b','d','q', str...>, hold<T...>> {
    using value = typename asm_vphsubdq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vphsubdq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xE3>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vphsubdq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xE3>, mrm_v<hold<T...>, Y...>>;
};

//  vphsubsw ANY [RVM] r  [66] 07 
template<class T, class Enable = bool> struct asm_vphsubsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','s','u','b','s','w', str...>, hold<T...>> {
    using value = typename asm_vphsubsw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphsubsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x07>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphsubsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x07>, mrm_v<hold<T...>, Z...>>;
};

//  vphsubsw ANY [RVM] r  [66] 07 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphsubsw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x07>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphsubsw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x07>, mrm_v<hold<T...>, Z...>>;
};

//  vphsubw ANY [RVM] r  [66] 05 
template<class T, class Enable = bool> struct asm_vphsubw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','s','u','b','w', str...>, hold<T...>> {
    using value = typename asm_vphsubw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphsubw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x05>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphsubw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x05>, mrm_v<hold<T...>, Z...>>;
};

//  vphsubw ANY [RVM] r  [66] 05 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphsubw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x05>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vphsubw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x05>, mrm_v<hold<T...>, Z...>>;
};

//  vphsubwd ANY [RM] r  [] E2 
template<class T, class Enable = bool> struct asm_vphsubwd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','s','u','b','w','d', str...>, hold<T...>> {
    using value = typename asm_vphsubwd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vphsubwd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xE2>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vphsubwd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xE2>, mrm_v<hold<T...>, Y...>>;
};

//  vpinsrb ANY [RVMI] r  [66] 20 
template<class T, class Enable = bool> struct asm_vpinsrb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','i','n','s','r','b', str...>, hold<T...>> {
    using value = typename asm_vpinsrb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpinsrb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg8>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x20>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpinsrb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg8, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x20>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpinsrd ANY [RVMI] r  [66] 22 
template<class T, class Enable = bool> struct asm_vpinsrd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','i','n','s','r','d', str...>, hold<T...>> {
    using value = typename asm_vpinsrd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpinsrd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x22>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpinsrd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x22>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpinsrq X64 [RVMI] r  [66] 22 
template<class T, class Enable = bool> struct asm_vpinsrq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','i','n','s','r','q', str...>, hold<T...>> {
    using value = typename asm_vpinsrq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpinsrq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x22>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpinsrq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x22>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpinsrw ANY [RVMI] r  [66] C4 
template<class T, class Enable = bool> struct asm_vpinsrw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','i','n','s','r','w', str...>, hold<T...>> {
    using value = typename asm_vpinsrw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpinsrw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg16>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<1>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xC4>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vpinsrw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg16, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<1>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xC4>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vpmacsdd ANY [RVMS] r  [] 9E 
template<class T, class Enable = bool> struct asm_vpmacsdd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','d','d', str...>, hold<T...>> {
    using value = typename asm_vpmacsdd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpmacsdd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x9E>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vpmacsdqh ANY [RVMS] r  [] 9F 
template<class T, class Enable = bool> struct asm_vpmacsdqh {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','d','q','h', str...>, hold<T...>> {
    using value = typename asm_vpmacsdqh<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpmacsdqh<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x9F>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vpmacsdql ANY [RVMS] r  [] 97 
template<class T, class Enable = bool> struct asm_vpmacsdql {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','d','q','l', str...>, hold<T...>> {
    using value = typename asm_vpmacsdql<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpmacsdql<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x97>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vpmacssdd ANY [RVMS] r  [] 8E 
template<class T, class Enable = bool> struct asm_vpmacssdd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','s','d','d', str...>, hold<T...>> {
    using value = typename asm_vpmacssdd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpmacssdd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x8E>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vpmacssdqh ANY [RVMS] r  [] 8F 
template<class T, class Enable = bool> struct asm_vpmacssdqh {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','s','d','q','h', str...>, hold<T...>> {
    using value = typename asm_vpmacssdqh<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpmacssdqh<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x8F>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vpmacssdql ANY [RVMS] r  [] 87 
template<class T, class Enable = bool> struct asm_vpmacssdql {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','s','d','q','l', str...>, hold<T...>> {
    using value = typename asm_vpmacssdql<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpmacssdql<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x87>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vpmacsswd ANY [RVMS] r  [] 86 
template<class T, class Enable = bool> struct asm_vpmacsswd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','s','w','d', str...>, hold<T...>> {
    using value = typename asm_vpmacsswd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpmacsswd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x86>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vpmacssww ANY [RVMS] r  [] 85 
template<class T, class Enable = bool> struct asm_vpmacssww {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','s','w','w', str...>, hold<T...>> {
    using value = typename asm_vpmacssww<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpmacssww<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x85>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vpmacswd ANY [RVMS] r  [] 96 
template<class T, class Enable = bool> struct asm_vpmacswd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','w','d', str...>, hold<T...>> {
    using value = typename asm_vpmacswd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpmacswd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x96>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vpmacsww ANY [RVMS] r  [] 95 
template<class T, class Enable = bool> struct asm_vpmacsww {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','w','w', str...>, hold<T...>> {
    using value = typename asm_vpmacsww<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpmacsww<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x95>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vpmadcsswd ANY [RVMS] r  [] A6 
template<class T, class Enable = bool> struct asm_vpmadcsswd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','d','c','s','s','w','d', str...>, hold<T...>> {
    using value = typename asm_vpmadcsswd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpmadcsswd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xA6>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vpmadcswd ANY [RVMS] r  [] B6 
template<class T, class Enable = bool> struct asm_vpmadcswd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','d','c','s','w','d', str...>, hold<T...>> {
    using value = typename asm_vpmadcswd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpmadcswd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xB6>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vpmaddubsw ANY [RVM] r  [66] 04 
template<class T, class Enable = bool> struct asm_vpmaddubsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','d','d','u','b','s','w', str...>, hold<T...>> {
    using value = typename asm_vpmaddubsw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaddubsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x04>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaddubsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x04>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaddubsw ANY [RVM] r  [66] 04 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaddubsw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x04>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaddubsw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x04>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaddwd ANY [RVM] r  [66] F5 
template<class T, class Enable = bool> struct asm_vpmaddwd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','d','d','w','d', str...>, hold<T...>> {
    using value = typename asm_vpmaddwd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaddwd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF5>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaddwd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF5>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaddwd ANY [RVM] r  [66] F5 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaddwd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF5>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaddwd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF5>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaskmovd ANY [MVR] r  [66] 8E 
template<class T, class Enable = bool> struct asm_vpmaskmovd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','s','k','m','o','v','d', str...>, hold<T...>> {
    using value = typename asm_vpmaskmovd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaskmovd<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Z...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x8E>, mrm_v<hold<Z...>, T...>>;
};

//  vpmaskmovd ANY [MVR] r  [66] 8E 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaskmovd<hold<ptr<reg256, T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Z...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x8E>, mrm_v<hold<Z...>, T...>>;
};

//  vpmaskmovd ANY [RVM] r  [66] 8C 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaskmovd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x8C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaskmovd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x8C>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaskmovd ANY [RVM] r  [66] 8C 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaskmovd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x8C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaskmovd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x8C>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaskmovq ANY [MVR] r  [66] 8E 
template<class T, class Enable = bool> struct asm_vpmaskmovq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','s','k','m','o','v','q', str...>, hold<T...>> {
    using value = typename asm_vpmaskmovq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaskmovq<hold<ptr<reg128, T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Z...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x8E>, mrm_v<hold<Z...>, T...>>;
};

//  vpmaskmovq ANY [MVR] r  [66] 8E 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaskmovq<hold<ptr<reg256, T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<Z...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x8E>, mrm_v<hold<Z...>, T...>>;
};

//  vpmaskmovq ANY [RVM] r  [66] 8C 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaskmovq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x8C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaskmovq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x8C>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaskmovq ANY [RVM] r  [66] 8C 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaskmovq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x8C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaskmovq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x8C>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaxsb ANY [RVM] r  [66] 3C 
template<class T, class Enable = bool> struct asm_vpmaxsb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','x','s','b', str...>, hold<T...>> {
    using value = typename asm_vpmaxsb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxsb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxsb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3C>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaxsb ANY [RVM] r  [66] 3C 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxsb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxsb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3C>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaxsd ANY [RVM] r  [66] 3D 
template<class T, class Enable = bool> struct asm_vpmaxsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','x','s','d', str...>, hold<T...>> {
    using value = typename asm_vpmaxsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3D>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaxsd ANY [RVM] r  [66] 3D 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxsd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxsd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3D>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaxsw ANY [RVM] r  [66] EE 
template<class T, class Enable = bool> struct asm_vpmaxsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','x','s','w', str...>, hold<T...>> {
    using value = typename asm_vpmaxsw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEE>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEE>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaxsw ANY [RVM] r  [66] EE 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxsw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEE>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxsw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEE>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaxub ANY [RVM] r  [66] DE 
template<class T, class Enable = bool> struct asm_vpmaxub {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','x','u','b', str...>, hold<T...>> {
    using value = typename asm_vpmaxub<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxub<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDE>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxub<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDE>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaxub ANY [RVM] r  [66] DE 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxub<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDE>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxub<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDE>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaxud ANY [RVM] r  [66] 3F 
template<class T, class Enable = bool> struct asm_vpmaxud {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','x','u','d', str...>, hold<T...>> {
    using value = typename asm_vpmaxud<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxud<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3F>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxud<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3F>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaxud ANY [RVM] r  [66] 3F 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxud<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3F>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxud<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3F>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaxuw ANY [RVM] r  [66] 3E 
template<class T, class Enable = bool> struct asm_vpmaxuw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','x','u','w', str...>, hold<T...>> {
    using value = typename asm_vpmaxuw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxuw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3E>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxuw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3E>, mrm_v<hold<T...>, Z...>>;
};

//  vpmaxuw ANY [RVM] r  [66] 3E 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxuw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3E>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmaxuw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3E>, mrm_v<hold<T...>, Z...>>;
};

//  vpminsb ANY [RVM] r  [66] 38 
template<class T, class Enable = bool> struct asm_vpminsb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','i','n','s','b', str...>, hold<T...>> {
    using value = typename asm_vpminsb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminsb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x38>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminsb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x38>, mrm_v<hold<T...>, Z...>>;
};

//  vpminsb ANY [RVM] r  [66] 38 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminsb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x38>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminsb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x38>, mrm_v<hold<T...>, Z...>>;
};

//  vpminsd ANY [RVM] r  [66] 39 
template<class T, class Enable = bool> struct asm_vpminsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','i','n','s','d', str...>, hold<T...>> {
    using value = typename asm_vpminsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x39>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x39>, mrm_v<hold<T...>, Z...>>;
};

//  vpminsd ANY [RVM] r  [66] 39 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminsd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x39>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminsd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x39>, mrm_v<hold<T...>, Z...>>;
};

//  vpminsw ANY [RVM] r  [66] EA 
template<class T, class Enable = bool> struct asm_vpminsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','i','n','s','w', str...>, hold<T...>> {
    using value = typename asm_vpminsw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEA>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEA>, mrm_v<hold<T...>, Z...>>;
};

//  vpminsw ANY [RVM] r  [66] EA 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminsw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEA>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminsw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEA>, mrm_v<hold<T...>, Z...>>;
};

//  vpminub ANY [RVM] r  [66] DA 
template<class T, class Enable = bool> struct asm_vpminub {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','i','n','u','b', str...>, hold<T...>> {
    using value = typename asm_vpminub<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminub<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDA>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminub<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDA>, mrm_v<hold<T...>, Z...>>;
};

//  vpminub ANY [RVM] r  [66] DA 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminub<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDA>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminub<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDA>, mrm_v<hold<T...>, Z...>>;
};

//  vpminud ANY [RVM] r  [66] 3B 
template<class T, class Enable = bool> struct asm_vpminud {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','i','n','u','d', str...>, hold<T...>> {
    using value = typename asm_vpminud<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminud<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3B>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminud<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3B>, mrm_v<hold<T...>, Z...>>;
};

//  vpminud ANY [RVM] r  [66] 3B 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminud<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3B>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpminud<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3B>, mrm_v<hold<T...>, Z...>>;
};

//  vpmovsxbd ANY [RM] r  [66] 21 
template<class T, class Enable = bool> struct asm_vpmovsxbd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','s','x','b','d', str...>, hold<T...>> {
    using value = typename asm_vpmovsxbd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpmovsxbd<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x21>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovsxbd<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x21>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovsxbd ANY [RM] r  [66] 21 

template<typename ...T, typename ...Y>
struct asm_vpmovsxbd<hold<zip<reg256>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x21>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovsxbd<hold<zip<reg256>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x21>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovsxbq ANY [RM] r  [66] 22 
template<class T, class Enable = bool> struct asm_vpmovsxbq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','s','x','b','q', str...>, hold<T...>> {
    using value = typename asm_vpmovsxbq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpmovsxbq<hold<zip<reg128>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x22>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovsxbq<hold<zip<reg128>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x22>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovsxbq ANY [RM] r  [66] 22 

template<typename ...T, typename ...Y>
struct asm_vpmovsxbq<hold<zip<reg256>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x22>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovsxbq<hold<zip<reg256>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x22>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovsxbw ANY [RM] r  [66] 20 
template<class T, class Enable = bool> struct asm_vpmovsxbw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','s','x','b','w', str...>, hold<T...>> {
    using value = typename asm_vpmovsxbw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpmovsxbw<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x20>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovsxbw<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x20>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovsxbw ANY [RM] r  [66] 20 

template<typename ...T, typename ...Y>
struct asm_vpmovsxbw<hold<zip<reg256>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x20>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovsxbw<hold<zip<reg256>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x20>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovsxdq ANY [RM] r  [66] 25 
template<class T, class Enable = bool> struct asm_vpmovsxdq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','s','x','d','q', str...>, hold<T...>> {
    using value = typename asm_vpmovsxdq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpmovsxdq<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x25>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovsxdq<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x25>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovsxdq ANY [RM] r  [66] 25 

template<typename ...T, typename ...Y>
struct asm_vpmovsxdq<hold<zip<reg256>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x25>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovsxdq<hold<zip<reg256>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x25>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovsxwd ANY [RM] r  [66] 23 
template<class T, class Enable = bool> struct asm_vpmovsxwd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','s','x','w','d', str...>, hold<T...>> {
    using value = typename asm_vpmovsxwd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpmovsxwd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x23>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovsxwd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x23>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovsxwd ANY [RM] r  [66] 23 

template<typename ...T, typename ...Y>
struct asm_vpmovsxwd<hold<zip<reg256>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x23>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovsxwd<hold<zip<reg256>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x23>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovsxwq ANY [RM] r  [66] 24 
template<class T, class Enable = bool> struct asm_vpmovsxwq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','s','x','w','q', str...>, hold<T...>> {
    using value = typename asm_vpmovsxwq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpmovsxwq<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x24>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovsxwq<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x24>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovsxwq ANY [RM] r  [66] 24 

template<typename ...T, typename ...Y>
struct asm_vpmovsxwq<hold<zip<reg256>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x24>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovsxwq<hold<zip<reg256>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x24>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovzxbd ANY [RM] r  [66] 31 
template<class T, class Enable = bool> struct asm_vpmovzxbd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','z','x','b','d', str...>, hold<T...>> {
    using value = typename asm_vpmovzxbd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpmovzxbd<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x31>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovzxbd<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x31>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovzxbd ANY [RM] r  [66] 31 

template<typename ...T, typename ...Y>
struct asm_vpmovzxbd<hold<zip<reg256>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x31>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovzxbd<hold<zip<reg256>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x31>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovzxbq ANY [RM] r  [66] 32 
template<class T, class Enable = bool> struct asm_vpmovzxbq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','z','x','b','q', str...>, hold<T...>> {
    using value = typename asm_vpmovzxbq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpmovzxbq<hold<zip<reg128>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x32>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovzxbq<hold<zip<reg128>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x32>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovzxbq ANY [RM] r  [66] 32 

template<typename ...T, typename ...Y>
struct asm_vpmovzxbq<hold<zip<reg256>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x32>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovzxbq<hold<zip<reg256>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x32>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovzxbw ANY [RM] r  [66] 30 
template<class T, class Enable = bool> struct asm_vpmovzxbw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','z','x','b','w', str...>, hold<T...>> {
    using value = typename asm_vpmovzxbw<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpmovzxbw<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x30>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovzxbw<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x30>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovzxbw ANY [RM] r  [66] 30 

template<typename ...T, typename ...Y>
struct asm_vpmovzxbw<hold<zip<reg256>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x30>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovzxbw<hold<zip<reg256>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x30>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovzxdq ANY [RM] r  [66] 35 
template<class T, class Enable = bool> struct asm_vpmovzxdq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','z','x','d','q', str...>, hold<T...>> {
    using value = typename asm_vpmovzxdq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpmovzxdq<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x35>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovzxdq<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x35>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovzxdq ANY [RM] r  [66] 35 

template<typename ...T, typename ...Y>
struct asm_vpmovzxdq<hold<zip<reg256>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x35>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovzxdq<hold<zip<reg256>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x35>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovzxwd ANY [RM] r  [66] 33 
template<class T, class Enable = bool> struct asm_vpmovzxwd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','z','x','w','d', str...>, hold<T...>> {
    using value = typename asm_vpmovzxwd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpmovzxwd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x33>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovzxwd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x33>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovzxwd ANY [RM] r  [66] 33 

template<typename ...T, typename ...Y>
struct asm_vpmovzxwd<hold<zip<reg256>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x33>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovzxwd<hold<zip<reg256>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x33>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovzxwq ANY [RM] r  [66] 34 
template<class T, class Enable = bool> struct asm_vpmovzxwq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','z','x','w','q', str...>, hold<T...>> {
    using value = typename asm_vpmovzxwq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vpmovzxwq<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x34>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovzxwq<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x34>, mrm_v<hold<T...>, Y...>>;
};

//  vpmovzxwq ANY [RM] r  [66] 34 

template<typename ...T, typename ...Y>
struct asm_vpmovzxwq<hold<zip<reg256>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x34>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vpmovzxwq<hold<zip<reg256>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x34>, mrm_v<hold<T...>, Y...>>;
};

//  vpmuldq ANY [RVM] r  [66] 28 
template<class T, class Enable = bool> struct asm_vpmuldq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','u','l','d','q', str...>, hold<T...>> {
    using value = typename asm_vpmuldq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmuldq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x28>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmuldq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x28>, mrm_v<hold<T...>, Z...>>;
};

//  vpmuldq ANY [RVM] r  [66] 28 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmuldq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x28>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmuldq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x28>, mrm_v<hold<T...>, Z...>>;
};

//  vpmulhrsw ANY [RVM] r  [66] 0B 
template<class T, class Enable = bool> struct asm_vpmulhrsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','u','l','h','r','s','w', str...>, hold<T...>> {
    using value = typename asm_vpmulhrsw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmulhrsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0B>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmulhrsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0B>, mrm_v<hold<T...>, Z...>>;
};

//  vpmulhrsw ANY [RVM] r  [66] 0B 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmulhrsw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0B>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmulhrsw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0B>, mrm_v<hold<T...>, Z...>>;
};

//  vpmulhuw ANY [RVM] r  [66] E4 
template<class T, class Enable = bool> struct asm_vpmulhuw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','u','l','h','u','w', str...>, hold<T...>> {
    using value = typename asm_vpmulhuw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmulhuw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE4>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmulhuw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE4>, mrm_v<hold<T...>, Z...>>;
};

//  vpmulhuw ANY [RVM] r  [66] E4 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmulhuw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE4>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmulhuw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE4>, mrm_v<hold<T...>, Z...>>;
};

//  vpmulhw ANY [RVM] r  [66] E5 
template<class T, class Enable = bool> struct asm_vpmulhw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','u','l','h','w', str...>, hold<T...>> {
    using value = typename asm_vpmulhw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmulhw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE5>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmulhw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE5>, mrm_v<hold<T...>, Z...>>;
};

//  vpmulhw ANY [RVM] r  [66] E5 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmulhw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE5>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmulhw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE5>, mrm_v<hold<T...>, Z...>>;
};

//  vpmulld ANY [RVM] r  [66] 40 
template<class T, class Enable = bool> struct asm_vpmulld {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','u','l','l','d', str...>, hold<T...>> {
    using value = typename asm_vpmulld<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmulld<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x40>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmulld<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x40>, mrm_v<hold<T...>, Z...>>;
};

//  vpmulld ANY [RVM] r  [66] 40 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmulld<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x40>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmulld<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x40>, mrm_v<hold<T...>, Z...>>;
};

//  vpmullw ANY [RVM] r  [66] D5 
template<class T, class Enable = bool> struct asm_vpmullw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','u','l','l','w', str...>, hold<T...>> {
    using value = typename asm_vpmullw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmullw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD5>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmullw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD5>, mrm_v<hold<T...>, Z...>>;
};

//  vpmullw ANY [RVM] r  [66] D5 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmullw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD5>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmullw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD5>, mrm_v<hold<T...>, Z...>>;
};

//  vpmuludq ANY [RVM] r  [66] F4 
template<class T, class Enable = bool> struct asm_vpmuludq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','u','l','u','d','q', str...>, hold<T...>> {
    using value = typename asm_vpmuludq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmuludq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF4>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmuludq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF4>, mrm_v<hold<T...>, Z...>>;
};

//  vpmuludq ANY [RVM] r  [66] F4 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmuludq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF4>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpmuludq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF4>, mrm_v<hold<T...>, Z...>>;
};

//  vpor ANY [RVM] r  [66] EB 
template<class T, class Enable = bool> struct asm_vpor {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','o','r', str...>, hold<T...>> {
    using value = typename asm_vpor<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpor<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEB>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpor<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEB>, mrm_v<hold<T...>, Z...>>;
};

//  vpor ANY [RVM] r  [66] EB 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpor<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEB>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpor<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEB>, mrm_v<hold<T...>, Z...>>;
};

//  vpperm ANY [RVSM] r  [] A3 
template<class T, class Enable = bool> struct asm_vpperm {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','p','e','r','m', str...>, hold<T...>> {
    using value = typename asm_vpperm<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpperm<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<8>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xA3>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>;
};

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpperm<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>>, bool> { 
 using value = expseq_v<typename mrm<O...>::_67h, typename XOP<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<8>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xA3>, mrm_v<hold<O...>, O...>, byte_seq<reg_n<Z...>::value << 4>>;
};

//  vpperm ANY [RVMS] r  [] A3 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
struct asm_vpperm<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xA3>, mrm_v<hold<T...>, Z...>, byte_seq<reg_n<O...>::value << 4>>;
};

//  vprotb ANY [RVM] r  [] 90 
template<class T, class Enable = bool> struct asm_vprotb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','r','o','t','b', str...>, hold<T...>> {
    using value = typename asm_vprotb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vprotb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x90>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vprotb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x90>, mrm_v<hold<T...>, Z...>>;
};

//  vprotb ANY [RMI] r  [] C0 

template<typename ...T, typename ...Y, class Z>
struct asm_vprotb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<8>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC0>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vprotb<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<8>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC0>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vprotb ANY [RMV] r  [] 90 

//  vprotd ANY [RVM] r  [] 92 
template<class T, class Enable = bool> struct asm_vprotd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','r','o','t','d', str...>, hold<T...>> {
    using value = typename asm_vprotd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vprotd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x92>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vprotd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x92>, mrm_v<hold<T...>, Z...>>;
};

//  vprotd ANY [RMI] r  [] C2 

template<typename ...T, typename ...Y, class Z>
struct asm_vprotd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<8>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC2>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vprotd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<8>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC2>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vprotd ANY [RMV] r  [] 92 

//  vprotq ANY [RVM] r  [] 93 
template<class T, class Enable = bool> struct asm_vprotq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','r','o','t','q', str...>, hold<T...>> {
    using value = typename asm_vprotq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vprotq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x93>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vprotq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x93>, mrm_v<hold<T...>, Z...>>;
};

//  vprotq ANY [RMI] r  [] C3 

template<typename ...T, typename ...Y, class Z>
struct asm_vprotq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<8>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC3>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vprotq<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<8>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC3>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vprotq ANY [RMV] r  [] 93 

//  vprotw ANY [RVM] r  [] 91 
template<class T, class Enable = bool> struct asm_vprotw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','r','o','t','w', str...>, hold<T...>> {
    using value = typename asm_vprotw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vprotw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x91>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vprotw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x91>, mrm_v<hold<T...>, Z...>>;
};

//  vprotw ANY [RMI] r  [] C1 

template<typename ...T, typename ...Y, class Z>
struct asm_vprotw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<8>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC1>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vprotw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<8>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC1>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vprotw ANY [RMV] r  [] 91 

//  vpsadbw ANY [RVM] r  [66] F6 
template<class T, class Enable = bool> struct asm_vpsadbw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','a','d','b','w', str...>, hold<T...>> {
    using value = typename asm_vpsadbw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsadbw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF6>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsadbw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF6>, mrm_v<hold<T...>, Z...>>;
};

//  vpsadbw ANY [RVM] r  [66] F6 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsadbw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF6>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsadbw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF6>, mrm_v<hold<T...>, Z...>>;
};

//  vpshab ANY [RVM] r  [] 98 
template<class T, class Enable = bool> struct asm_vpshab {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','a','b', str...>, hold<T...>> {
    using value = typename asm_vpshab<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshab<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x98>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshab<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x98>, mrm_v<hold<T...>, Z...>>;
};

//  vpshab ANY [RMV] r  [] 98 

//  vpshad ANY [RVM] r  [] 9A 
template<class T, class Enable = bool> struct asm_vpshad {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','a','d', str...>, hold<T...>> {
    using value = typename asm_vpshad<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshad<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x9A>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshad<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x9A>, mrm_v<hold<T...>, Z...>>;
};

//  vpshad ANY [RMV] r  [] 9A 

//  vpshaq ANY [RVM] r  [] 9B 
template<class T, class Enable = bool> struct asm_vpshaq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','a','q', str...>, hold<T...>> {
    using value = typename asm_vpshaq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshaq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x9B>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshaq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x9B>, mrm_v<hold<T...>, Z...>>;
};

//  vpshaq ANY [RMV] r  [] 9B 

//  vpshaw ANY [RVM] r  [] 99 
template<class T, class Enable = bool> struct asm_vpshaw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','a','w', str...>, hold<T...>> {
    using value = typename asm_vpshaw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshaw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x99>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshaw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x99>, mrm_v<hold<T...>, Z...>>;
};

//  vpshaw ANY [RMV] r  [] 99 

//  vpshlb ANY [RVM] r  [] 94 
template<class T, class Enable = bool> struct asm_vpshlb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','l','b', str...>, hold<T...>> {
    using value = typename asm_vpshlb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshlb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x94>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshlb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x94>, mrm_v<hold<T...>, Z...>>;
};

//  vpshlb ANY [RMV] r  [] 94 

//  vpshld ANY [RVM] r  [] 96 
template<class T, class Enable = bool> struct asm_vpshld {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','l','d', str...>, hold<T...>> {
    using value = typename asm_vpshld<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshld<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x96>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshld<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x96>, mrm_v<hold<T...>, Z...>>;
};

//  vpshld ANY [RMV] r  [] 96 

//  vpshlq ANY [RVM] r  [] 97 
template<class T, class Enable = bool> struct asm_vpshlq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','l','q', str...>, hold<T...>> {
    using value = typename asm_vpshlq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshlq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x97>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshlq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x97>, mrm_v<hold<T...>, Z...>>;
};

//  vpshlq ANY [RMV] r  [] 97 

//  vpshlw ANY [RVM] r  [] 95 
template<class T, class Enable = bool> struct asm_vpshlw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','l','w', str...>, hold<T...>> {
    using value = typename asm_vpshlw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshlw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x95>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshlw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x95>, mrm_v<hold<T...>, Z...>>;
};

//  vpshlw ANY [RMV] r  [] 95 

//  vpshufb ANY [RVM] r  [66] 00 
template<class T, class Enable = bool> struct asm_vpshufb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','u','f','b', str...>, hold<T...>> {
    using value = typename asm_vpshufb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshufb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x00>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshufb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x00>, mrm_v<hold<T...>, Z...>>;
};

//  vpshufb ANY [RVM] r  [66] 00 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshufb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x00>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpshufb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x00>, mrm_v<hold<T...>, Z...>>;
};

//  vpshufd ANY [RMI] r  [66] 70 
template<class T, class Enable = bool> struct asm_vpshufd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','u','f','d', str...>, hold<T...>> {
    using value = typename asm_vpshufd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpshufd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vpshufd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x70>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vpshufd ANY [RMI] r  [66] 70 

template<typename ...T, typename ...Y, class Z>
struct asm_vpshufd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vpshufd<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x70>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vpshufhw ANY [RMI] r  [F3] 70 
template<class T, class Enable = bool> struct asm_vpshufhw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','u','f','h','w', str...>, hold<T...>> {
    using value = typename asm_vpshufhw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpshufhw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vpshufhw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x70>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vpshufhw ANY [RMI] r  [F3] 70 

template<typename ...T, typename ...Y, class Z>
struct asm_vpshufhw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vpshufhw<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x70>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vpshuflw ANY [RMI] r  [F2] 70 
template<class T, class Enable = bool> struct asm_vpshuflw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','u','f','l','w', str...>, hold<T...>> {
    using value = typename asm_vpshuflw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpshuflw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vpshuflw<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x70>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vpshuflw ANY [RMI] r  [F2] 70 

template<typename ...T, typename ...Y, class Z>
struct asm_vpshuflw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vpshuflw<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0x70>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vpsignb ANY [RVM] r  [66] 08 
template<class T, class Enable = bool> struct asm_vpsignb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','i','g','n','b', str...>, hold<T...>> {
    using value = typename asm_vpsignb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsignb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x08>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsignb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x08>, mrm_v<hold<T...>, Z...>>;
};

//  vpsignb ANY [RVM] r  [66] 08 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsignb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x08>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsignb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x08>, mrm_v<hold<T...>, Z...>>;
};

//  vpsignd ANY [RVM] r  [66] 0A 
template<class T, class Enable = bool> struct asm_vpsignd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','i','g','n','d', str...>, hold<T...>> {
    using value = typename asm_vpsignd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsignd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0A>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsignd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0A>, mrm_v<hold<T...>, Z...>>;
};

//  vpsignd ANY [RVM] r  [66] 0A 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsignd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0A>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsignd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0A>, mrm_v<hold<T...>, Z...>>;
};

//  vpsignw ANY [RVM] r  [66] 09 
template<class T, class Enable = bool> struct asm_vpsignw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','i','g','n','w', str...>, hold<T...>> {
    using value = typename asm_vpsignw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsignw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x09>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsignw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x09>, mrm_v<hold<T...>, Z...>>;
};

//  vpsignw ANY [RVM] r  [66] 09 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsignw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x09>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsignw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x09>, mrm_v<hold<T...>, Z...>>;
};

//  vpslld ANY [VMI] 6  [66] 72 
template<class T, class Enable = bool> struct asm_vpslld {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','l','l','d', str...>, hold<T...>> {
    using value = typename asm_vpslld<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpslld<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<6>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x72>, typename modrm<hold<Y...>, hold<reg<6>>>::value, typename u8_8<Z>::value>;
};

//  vpslld ANY [RVM] r  [66] F2 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpslld<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF2>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpslld<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF2>, mrm_v<hold<T...>, Z...>>;
};

//  vpslld ANY [VMI] 6  [66] 72 

template<typename ...T, typename ...Y, class Z>
struct asm_vpslld<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<6>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x72>, typename modrm<hold<Y...>, hold<reg<6>>>::value, typename u8_8<Z>::value>;
};

//  vpslld ANY [RVM] r  [66] F2 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpslld<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF2>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpslld<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF2>, mrm_v<hold<T...>, Z...>>;
};

//  vpslldq ANY [VMI] 7  [66] 73 
template<class T, class Enable = bool> struct asm_vpslldq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','l','l','d','q', str...>, hold<T...>> {
    using value = typename asm_vpslldq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpslldq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<7>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x73>, typename modrm<hold<Y...>, hold<reg<7>>>::value, typename u8_8<Z>::value>;
};

//  vpslldq ANY [VMI] 7  [66] 73 

template<typename ...T, typename ...Y, class Z>
struct asm_vpslldq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<7>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x73>, typename modrm<hold<Y...>, hold<reg<7>>>::value, typename u8_8<Z>::value>;
};

//  vpsllq ANY [VMI] 6  [66] 73 
template<class T, class Enable = bool> struct asm_vpsllq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','l','l','q', str...>, hold<T...>> {
    using value = typename asm_vpsllq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpsllq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<6>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x73>, typename modrm<hold<Y...>, hold<reg<6>>>::value, typename u8_8<Z>::value>;
};

//  vpsllq ANY [RVM] r  [66] F3 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsllq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF3>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsllq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF3>, mrm_v<hold<T...>, Z...>>;
};

//  vpsllq ANY [VMI] 6  [66] 73 

template<typename ...T, typename ...Y, class Z>
struct asm_vpsllq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<6>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x73>, typename modrm<hold<Y...>, hold<reg<6>>>::value, typename u8_8<Z>::value>;
};

//  vpsllq ANY [RVM] r  [66] F3 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsllq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF3>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsllq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF3>, mrm_v<hold<T...>, Z...>>;
};

//  vpsllvd ANY [RVM] r  [66] 47 
template<class T, class Enable = bool> struct asm_vpsllvd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','l','l','v','d', str...>, hold<T...>> {
    using value = typename asm_vpsllvd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsllvd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x47>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsllvd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x47>, mrm_v<hold<T...>, Z...>>;
};

//  vpsllvd ANY [RVM] r  [66] 47 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsllvd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x47>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsllvd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x47>, mrm_v<hold<T...>, Z...>>;
};

//  vpsllvq ANY [RVM] r  [66] 47 
template<class T, class Enable = bool> struct asm_vpsllvq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','l','l','v','q', str...>, hold<T...>> {
    using value = typename asm_vpsllvq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsllvq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x47>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsllvq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x47>, mrm_v<hold<T...>, Z...>>;
};

//  vpsllvq ANY [RVM] r  [66] 47 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsllvq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x47>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsllvq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x47>, mrm_v<hold<T...>, Z...>>;
};

//  vpsllw ANY [VMI] 6  [66] 71 
template<class T, class Enable = bool> struct asm_vpsllw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','l','l','w', str...>, hold<T...>> {
    using value = typename asm_vpsllw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpsllw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<6>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x71>, typename modrm<hold<Y...>, hold<reg<6>>>::value, typename u8_8<Z>::value>;
};

//  vpsllw ANY [RVM] r  [66] F1 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsllw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF1>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsllw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF1>, mrm_v<hold<T...>, Z...>>;
};

//  vpsllw ANY [VMI] 6  [66] 71 

template<typename ...T, typename ...Y, class Z>
struct asm_vpsllw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<6>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x71>, typename modrm<hold<Y...>, hold<reg<6>>>::value, typename u8_8<Z>::value>;
};

//  vpsllw ANY [RVM] r  [66] F1 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsllw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF1>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsllw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF1>, mrm_v<hold<T...>, Z...>>;
};

//  vpsrad ANY [VMI] 4  [66] 72 
template<class T, class Enable = bool> struct asm_vpsrad {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','r','a','d', str...>, hold<T...>> {
    using value = typename asm_vpsrad<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpsrad<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<4>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x72>, typename modrm<hold<Y...>, hold<reg<4>>>::value, typename u8_8<Z>::value>;
};

//  vpsrad ANY [RVM] r  [66] E2 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrad<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE2>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrad<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE2>, mrm_v<hold<T...>, Z...>>;
};

//  vpsrad ANY [VMI] 4  [66] 72 

template<typename ...T, typename ...Y, class Z>
struct asm_vpsrad<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<4>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x72>, typename modrm<hold<Y...>, hold<reg<4>>>::value, typename u8_8<Z>::value>;
};

//  vpsrad ANY [RVM] r  [66] E2 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrad<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE2>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrad<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE2>, mrm_v<hold<T...>, Z...>>;
};

//  vpsravd ANY [RVM] r  [66] 46 
template<class T, class Enable = bool> struct asm_vpsravd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','r','a','v','d', str...>, hold<T...>> {
    using value = typename asm_vpsravd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsravd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x46>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsravd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x46>, mrm_v<hold<T...>, Z...>>;
};

//  vpsravd ANY [RVM] r  [66] 46 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsravd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x46>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsravd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x46>, mrm_v<hold<T...>, Z...>>;
};

//  vpsraw ANY [VMI] 4  [66] 71 
template<class T, class Enable = bool> struct asm_vpsraw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','r','a','w', str...>, hold<T...>> {
    using value = typename asm_vpsraw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpsraw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<4>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x71>, typename modrm<hold<Y...>, hold<reg<4>>>::value, typename u8_8<Z>::value>;
};

//  vpsraw ANY [RVM] r  [66] E1 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsraw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE1>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsraw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE1>, mrm_v<hold<T...>, Z...>>;
};

//  vpsraw ANY [VMI] 4  [66] 71 

template<typename ...T, typename ...Y, class Z>
struct asm_vpsraw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<4>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x71>, typename modrm<hold<Y...>, hold<reg<4>>>::value, typename u8_8<Z>::value>;
};

//  vpsraw ANY [RVM] r  [66] E1 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsraw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE1>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsraw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE1>, mrm_v<hold<T...>, Z...>>;
};

//  vpsrld ANY [VMI] 2  [66] 72 
template<class T, class Enable = bool> struct asm_vpsrld {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','r','l','d', str...>, hold<T...>> {
    using value = typename asm_vpsrld<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpsrld<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<2>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x72>, typename modrm<hold<Y...>, hold<reg<2>>>::value, typename u8_8<Z>::value>;
};

//  vpsrld ANY [RVM] r  [66] D2 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrld<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD2>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrld<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD2>, mrm_v<hold<T...>, Z...>>;
};

//  vpsrld ANY [VMI] 2  [66] 72 

template<typename ...T, typename ...Y, class Z>
struct asm_vpsrld<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<2>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x72>, typename modrm<hold<Y...>, hold<reg<2>>>::value, typename u8_8<Z>::value>;
};

//  vpsrld ANY [RVM] r  [66] D2 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrld<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD2>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrld<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD2>, mrm_v<hold<T...>, Z...>>;
};

//  vpsrldq ANY [VMI] 3  [66] 73 
template<class T, class Enable = bool> struct asm_vpsrldq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','r','l','d','q', str...>, hold<T...>> {
    using value = typename asm_vpsrldq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpsrldq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<3>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x73>, typename modrm<hold<Y...>, hold<reg<3>>>::value, typename u8_8<Z>::value>;
};

//  vpsrldq ANY [VMI] 3  [66] 73 

template<typename ...T, typename ...Y, class Z>
struct asm_vpsrldq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<3>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x73>, typename modrm<hold<Y...>, hold<reg<3>>>::value, typename u8_8<Z>::value>;
};

//  vpsrlq ANY [VMI] 2  [66] 73 
template<class T, class Enable = bool> struct asm_vpsrlq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','r','l','q', str...>, hold<T...>> {
    using value = typename asm_vpsrlq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpsrlq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<2>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x73>, typename modrm<hold<Y...>, hold<reg<2>>>::value, typename u8_8<Z>::value>;
};

//  vpsrlq ANY [RVM] r  [66] D3 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrlq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD3>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrlq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD3>, mrm_v<hold<T...>, Z...>>;
};

//  vpsrlq ANY [VMI] 2  [66] 73 

template<typename ...T, typename ...Y, class Z>
struct asm_vpsrlq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<2>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x73>, typename modrm<hold<Y...>, hold<reg<2>>>::value, typename u8_8<Z>::value>;
};

//  vpsrlq ANY [RVM] r  [66] D3 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrlq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD3>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrlq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD3>, mrm_v<hold<T...>, Z...>>;
};

//  vpsrlvd ANY [RVM] r  [66] 45 
template<class T, class Enable = bool> struct asm_vpsrlvd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','r','l','v','d', str...>, hold<T...>> {
    using value = typename asm_vpsrlvd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrlvd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x45>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrlvd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x45>, mrm_v<hold<T...>, Z...>>;
};

//  vpsrlvd ANY [RVM] r  [66] 45 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrlvd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x45>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrlvd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x45>, mrm_v<hold<T...>, Z...>>;
};

//  vpsrlvq ANY [RVM] r  [66] 45 
template<class T, class Enable = bool> struct asm_vpsrlvq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','r','l','v','q', str...>, hold<T...>> {
    using value = typename asm_vpsrlvq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrlvq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x45>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrlvq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x45>, mrm_v<hold<T...>, Z...>>;
};

//  vpsrlvq ANY [RVM] r  [66] 45 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrlvq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x45>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrlvq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x45>, mrm_v<hold<T...>, Z...>>;
};

//  vpsrlw ANY [VMI] 2  [66] 71 
template<class T, class Enable = bool> struct asm_vpsrlw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','r','l','w', str...>, hold<T...>> {
    using value = typename asm_vpsrlw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vpsrlw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<2>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x71>, typename modrm<hold<Y...>, hold<reg<2>>>::value, typename u8_8<Z>::value>;
};

//  vpsrlw ANY [RVM] r  [66] D1 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrlw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD1>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrlw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD1>, mrm_v<hold<T...>, Z...>>;
};

//  vpsrlw ANY [VMI] 2  [66] 71 

template<typename ...T, typename ...Y, class Z>
struct asm_vpsrlw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::value> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<2>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x71>, typename modrm<hold<Y...>, hold<reg<2>>>::value, typename u8_8<Z>::value>;
};

//  vpsrlw ANY [RVM] r  [66] D1 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrlw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD1>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsrlw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD1>, mrm_v<hold<T...>, Z...>>;
};

//  vpsubb ANY [RVM] r  [66] F8 
template<class T, class Enable = bool> struct asm_vpsubb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','u','b','b', str...>, hold<T...>> {
    using value = typename asm_vpsubb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF8>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF8>, mrm_v<hold<T...>, Z...>>;
};

//  vpsubb ANY [RVM] r  [66] F8 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF8>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF8>, mrm_v<hold<T...>, Z...>>;
};

//  vpsubd ANY [RVM] r  [66] FA 
template<class T, class Enable = bool> struct asm_vpsubd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','u','b','d', str...>, hold<T...>> {
    using value = typename asm_vpsubd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFA>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFA>, mrm_v<hold<T...>, Z...>>;
};

//  vpsubd ANY [RVM] r  [66] FA 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFA>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFA>, mrm_v<hold<T...>, Z...>>;
};

//  vpsubq ANY [RVM] r  [66] FB 
template<class T, class Enable = bool> struct asm_vpsubq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','u','b','q', str...>, hold<T...>> {
    using value = typename asm_vpsubq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFB>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFB>, mrm_v<hold<T...>, Z...>>;
};

//  vpsubq ANY [RVM] r  [66] FB 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFB>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFB>, mrm_v<hold<T...>, Z...>>;
};

//  vpsubsb ANY [RVM] r  [66] E8 
template<class T, class Enable = bool> struct asm_vpsubsb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','u','b','s','b', str...>, hold<T...>> {
    using value = typename asm_vpsubsb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubsb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE8>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubsb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE8>, mrm_v<hold<T...>, Z...>>;
};

//  vpsubsb ANY [RVM] r  [66] E8 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubsb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE8>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubsb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE8>, mrm_v<hold<T...>, Z...>>;
};

//  vpsubsw ANY [RVM] r  [66] E9 
template<class T, class Enable = bool> struct asm_vpsubsw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','u','b','s','w', str...>, hold<T...>> {
    using value = typename asm_vpsubsw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE9>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubsw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE9>, mrm_v<hold<T...>, Z...>>;
};

//  vpsubsw ANY [RVM] r  [66] E9 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubsw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE9>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubsw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE9>, mrm_v<hold<T...>, Z...>>;
};

//  vpsubusb ANY [RVM] r  [66] D8 
template<class T, class Enable = bool> struct asm_vpsubusb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','u','b','u','s','b', str...>, hold<T...>> {
    using value = typename asm_vpsubusb<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubusb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD8>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubusb<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD8>, mrm_v<hold<T...>, Z...>>;
};

//  vpsubusb ANY [RVM] r  [66] D8 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubusb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD8>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubusb<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD8>, mrm_v<hold<T...>, Z...>>;
};

//  vpsubusw ANY [RVM] r  [66] D9 
template<class T, class Enable = bool> struct asm_vpsubusw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','u','b','u','s','w', str...>, hold<T...>> {
    using value = typename asm_vpsubusw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubusw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD9>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubusw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD9>, mrm_v<hold<T...>, Z...>>;
};

//  vpsubusw ANY [RVM] r  [66] D9 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubusw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD9>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubusw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD9>, mrm_v<hold<T...>, Z...>>;
};

//  vpsubw ANY [RVM] r  [66] F9 
template<class T, class Enable = bool> struct asm_vpsubw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','u','b','w', str...>, hold<T...>> {
    using value = typename asm_vpsubw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF9>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF9>, mrm_v<hold<T...>, Z...>>;
};

//  vpsubw ANY [RVM] r  [66] F9 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF9>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpsubw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF9>, mrm_v<hold<T...>, Z...>>;
};

//  vptest ANY [RM] r  [66] 17 
template<class T, class Enable = bool> struct asm_vptest {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','t','e','s','t', str...>, hold<T...>> {
    using value = typename asm_vptest<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vptest<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x17>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vptest<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x17>, mrm_v<hold<T...>, Y...>>;
};

//  vptest ANY [RM] r  [66] 17 

template<typename ...T, typename ...Y>
struct asm_vptest<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x17>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vptest<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x17>, mrm_v<hold<T...>, Y...>>;
};

//  vpunpckhbw ANY [RVM] r  [66] 68 
template<class T, class Enable = bool> struct asm_vpunpckhbw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','u','n','p','c','k','h','b','w', str...>, hold<T...>> {
    using value = typename asm_vpunpckhbw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckhbw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x68>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckhbw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x68>, mrm_v<hold<T...>, Z...>>;
};

//  vpunpckhbw ANY [RVM] r  [66] 68 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckhbw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x68>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckhbw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x68>, mrm_v<hold<T...>, Z...>>;
};

//  vpunpckhdq ANY [RVM] r  [66] 6A 
template<class T, class Enable = bool> struct asm_vpunpckhdq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','u','n','p','c','k','h','d','q', str...>, hold<T...>> {
    using value = typename asm_vpunpckhdq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckhdq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6A>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckhdq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6A>, mrm_v<hold<T...>, Z...>>;
};

//  vpunpckhdq ANY [RVM] r  [66] 6A 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckhdq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6A>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckhdq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6A>, mrm_v<hold<T...>, Z...>>;
};

//  vpunpckhqdq ANY [RVM] r  [66] 6D 
template<class T, class Enable = bool> struct asm_vpunpckhqdq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','u','n','p','c','k','h','q','d','q', str...>, hold<T...>> {
    using value = typename asm_vpunpckhqdq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckhqdq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckhqdq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6D>, mrm_v<hold<T...>, Z...>>;
};

//  vpunpckhqdq ANY [RVM] r  [66] 6D 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckhqdq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6D>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckhqdq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6D>, mrm_v<hold<T...>, Z...>>;
};

//  vpunpckhwd ANY [RVM] r  [66] 69 
template<class T, class Enable = bool> struct asm_vpunpckhwd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','u','n','p','c','k','h','w','d', str...>, hold<T...>> {
    using value = typename asm_vpunpckhwd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckhwd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x69>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckhwd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x69>, mrm_v<hold<T...>, Z...>>;
};

//  vpunpckhwd ANY [RVM] r  [66] 69 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckhwd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x69>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckhwd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x69>, mrm_v<hold<T...>, Z...>>;
};

//  vpunpcklbw ANY [RVM] r  [66] 60 
template<class T, class Enable = bool> struct asm_vpunpcklbw {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','u','n','p','c','k','l','b','w', str...>, hold<T...>> {
    using value = typename asm_vpunpcklbw<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpcklbw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x60>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpcklbw<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x60>, mrm_v<hold<T...>, Z...>>;
};

//  vpunpcklbw ANY [RVM] r  [66] 60 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpcklbw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x60>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpcklbw<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x60>, mrm_v<hold<T...>, Z...>>;
};

//  vpunpckldq ANY [RVM] r  [66] 62 
template<class T, class Enable = bool> struct asm_vpunpckldq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','u','n','p','c','k','l','d','q', str...>, hold<T...>> {
    using value = typename asm_vpunpckldq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckldq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x62>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckldq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x62>, mrm_v<hold<T...>, Z...>>;
};

//  vpunpckldq ANY [RVM] r  [66] 62 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckldq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x62>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpckldq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x62>, mrm_v<hold<T...>, Z...>>;
};

//  vpunpcklqdq ANY [RVM] r  [66] 6C 
template<class T, class Enable = bool> struct asm_vpunpcklqdq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','u','n','p','c','k','l','q','d','q', str...>, hold<T...>> {
    using value = typename asm_vpunpcklqdq<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpcklqdq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpcklqdq<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6C>, mrm_v<hold<T...>, Z...>>;
};

//  vpunpcklqdq ANY [RVM] r  [66] 6C 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpcklqdq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpcklqdq<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6C>, mrm_v<hold<T...>, Z...>>;
};

//  vpunpcklwd ANY [RVM] r  [66] 61 
template<class T, class Enable = bool> struct asm_vpunpcklwd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','u','n','p','c','k','l','w','d', str...>, hold<T...>> {
    using value = typename asm_vpunpcklwd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpcklwd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x61>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpcklwd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x61>, mrm_v<hold<T...>, Z...>>;
};

//  vpunpcklwd ANY [RVM] r  [66] 61 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpcklwd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x61>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpunpcklwd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x61>, mrm_v<hold<T...>, Z...>>;
};

//  vpxor ANY [RVM] r  [66] EF 
template<class T, class Enable = bool> struct asm_vpxor {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','x','o','r', str...>, hold<T...>> {
    using value = typename asm_vpxor<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpxor<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEF>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpxor<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEF>, mrm_v<hold<T...>, Z...>>;
};

//  vpxor ANY [RVM] r  [66] EF 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpxor<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEF>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vpxor<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEF>, mrm_v<hold<T...>, Z...>>;
};

//  vrcpps ANY [RM] r  [] 53 
template<class T, class Enable = bool> struct asm_vrcpps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','r','c','p','p','s', str...>, hold<T...>> {
    using value = typename asm_vrcpps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vrcpps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x53>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vrcpps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x53>, mrm_v<hold<T...>, Y...>>;
};

//  vrcpps ANY [RM] r  [] 53 

template<typename ...T, typename ...Y>
struct asm_vrcpps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x53>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vrcpps<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x53>, mrm_v<hold<T...>, Y...>>;
};

//  vrcpss ANY [RVM] r  [F3] 53 
template<class T, class Enable = bool> struct asm_vrcpss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','r','c','p','s','s', str...>, hold<T...>> {
    using value = typename asm_vrcpss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vrcpss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x53>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vrcpss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x53>, mrm_v<hold<T...>, Z...>>;
};

//  vroundpd ANY [RMI] r  [66] 09 
template<class T, class Enable = bool> struct asm_vroundpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','r','o','u','n','d','p','d', str...>, hold<T...>> {
    using value = typename asm_vroundpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vroundpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x09>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vroundpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x09>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vroundpd ANY [RMI] r  [66] 09 

template<typename ...T, typename ...Y, class Z>
struct asm_vroundpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x09>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vroundpd<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x09>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vroundps ANY [RMI] r  [66] 08 
template<class T, class Enable = bool> struct asm_vroundps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','r','o','u','n','d','p','s', str...>, hold<T...>> {
    using value = typename asm_vroundps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, class Z>
struct asm_vroundps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x08>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vroundps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x08>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vroundps ANY [RMI] r  [66] 08 

template<typename ...T, typename ...Y, class Z>
struct asm_vroundps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, Z>, typename u8_8<Z>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x08>, typename modrm<hold<Y...>, hold<T...>>::value, typename u8_8<Z>::value>;
};

template<typename ...T, typename ...Y, class Z>
struct asm_vroundps<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>, Z>, typename u8_8<Z>::type> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x08>, mrm_v<hold<T...>, Y...>, typename u8_8<Z>::value>;
};

//  vroundsd ANY [RVMI] r  [66] 0B 
template<class T, class Enable = bool> struct asm_vroundsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','r','o','u','n','d','s','d', str...>, hold<T...>> {
    using value = typename asm_vroundsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vroundsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x0B>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vroundsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x0B>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vroundss ANY [RVMI] r  [66] 0A 
template<class T, class Enable = bool> struct asm_vroundss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','r','o','u','n','d','s','s', str...>, hold<T...>> {
    using value = typename asm_vroundss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vroundss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x0A>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vroundss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x0A>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vrsqrtps ANY [RM] r  [] 52 
template<class T, class Enable = bool> struct asm_vrsqrtps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','r','s','q','r','t','p','s', str...>, hold<T...>> {
    using value = typename asm_vrsqrtps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vrsqrtps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x52>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vrsqrtps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x52>, mrm_v<hold<T...>, Y...>>;
};

//  vrsqrtps ANY [RM] r  [] 52 

template<typename ...T, typename ...Y>
struct asm_vrsqrtps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x52>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vrsqrtps<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x52>, mrm_v<hold<T...>, Y...>>;
};

//  vrsqrtss ANY [RVM] r  [F3] 52 
template<class T, class Enable = bool> struct asm_vrsqrtss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','r','s','q','r','t','s','s', str...>, hold<T...>> {
    using value = typename asm_vrsqrtss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vrsqrtss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x52>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vrsqrtss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x52>, mrm_v<hold<T...>, Z...>>;
};

//  vshufpd ANY [RVMI] r  [66] C6 
template<class T, class Enable = bool> struct asm_vshufpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','h','u','f','p','d', str...>, hold<T...>> {
    using value = typename asm_vshufpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vshufpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xC6>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vshufpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xC6>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vshufpd ANY [RVMI] r  [66] C6 

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vshufpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xC6>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vshufpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xC6>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vshufps ANY [RVMI] r  [] C6 
template<class T, class Enable = bool> struct asm_vshufps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','h','u','f','p','s', str...>, hold<T...>> {
    using value = typename asm_vshufps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vshufps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xC6>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vshufps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xC6>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vshufps ANY [RVMI] r  [] C6 

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vshufps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, O>, typename u8_8<O>::type> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0xC6>, typename modrm<hold<Z...>, hold<T...>>::value, typename u8_8<O>::value>;
};

template<typename ...T, typename ...Y, typename ...Z, class O>
struct asm_vshufps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, O>, typename u8_8<O>::type> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0xC6>, mrm_v<hold<T...>, Z...>, typename u8_8<O>::value>;
};

//  vsqrtpd ANY [RM] r  [66] 51 
template<class T, class Enable = bool> struct asm_vsqrtpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','q','r','t','p','d', str...>, hold<T...>> {
    using value = typename asm_vsqrtpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vsqrtpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x51>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vsqrtpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x51>, mrm_v<hold<T...>, Y...>>;
};

//  vsqrtpd ANY [RM] r  [66] 51 

template<typename ...T, typename ...Y>
struct asm_vsqrtpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x51>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vsqrtpd<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x51>, mrm_v<hold<T...>, Y...>>;
};

//  vsqrtps ANY [RM] r  [] 51 
template<class T, class Enable = bool> struct asm_vsqrtps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','q','r','t','p','s', str...>, hold<T...>> {
    using value = typename asm_vsqrtps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vsqrtps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x51>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vsqrtps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x51>, mrm_v<hold<T...>, Y...>>;
};

//  vsqrtps ANY [RM] r  [] 51 

template<typename ...T, typename ...Y>
struct asm_vsqrtps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x51>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vsqrtps<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x51>, mrm_v<hold<T...>, Y...>>;
};

//  vsqrtsd ANY [RVM] r  [F2] 51 
template<class T, class Enable = bool> struct asm_vsqrtsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','q','r','t','s','d', str...>, hold<T...>> {
    using value = typename asm_vsqrtsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vsqrtsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x51>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vsqrtsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x51>, mrm_v<hold<T...>, Z...>>;
};

//  vsqrtss ANY [RVM] r  [F3] 51 
template<class T, class Enable = bool> struct asm_vsqrtss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','q','r','t','s','s', str...>, hold<T...>> {
    using value = typename asm_vsqrtss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vsqrtss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x51>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vsqrtss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x51>, mrm_v<hold<T...>, Z...>>;
};

//  vstmxcsr ANY [M] 3  [] AE 
template<class T, class Enable = bool> struct asm_vstmxcsr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','t','m','x','c','s','r', str...>, hold<T...>> {
    using value = typename asm_vstmxcsr<hold<T...>>::value;
};
template<typename ...T>
struct asm_vstmxcsr<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<reg<3>>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

template<typename ...T>
struct asm_vstmxcsr<hold<ptr<reg32, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename VEX<disp8<is_ext_v<hold<reg<3>>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xAE>, mrm_v<hold<reg<3>>, T...>>;
};

//  vsubpd ANY [RVM] r  [66] 5C 
template<class T, class Enable = bool> struct asm_vsubpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','u','b','p','d', str...>, hold<T...>> {
    using value = typename asm_vsubpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vsubpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vsubpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5C>, mrm_v<hold<T...>, Z...>>;
};

//  vsubpd ANY [RVM] r  [66] 5C 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vsubpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vsubpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5C>, mrm_v<hold<T...>, Z...>>;
};

//  vsubps ANY [RVM] r  [] 5C 
template<class T, class Enable = bool> struct asm_vsubps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','u','b','p','s', str...>, hold<T...>> {
    using value = typename asm_vsubps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vsubps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x5C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vsubps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x5C>, mrm_v<hold<T...>, Z...>>;
};

//  vsubps ANY [RVM] r  [] 5C 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vsubps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x5C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vsubps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x5C>, mrm_v<hold<T...>, Z...>>;
};

//  vsubsd ANY [RVM] r  [F2] 5C 
template<class T, class Enable = bool> struct asm_vsubsd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','u','b','s','d', str...>, hold<T...>> {
    using value = typename asm_vsubsd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vsubsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vsubsd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5C>, mrm_v<hold<T...>, Z...>>;
};

//  vsubss ANY [RVM] r  [F3] 5C 
template<class T, class Enable = bool> struct asm_vsubss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','u','b','s','s', str...>, hold<T...>> {
    using value = typename asm_vsubss<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vsubss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5C>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vsubss<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5C>, mrm_v<hold<T...>, Z...>>;
};

//  vtestpd ANY [RM] r  [66] 0F 
template<class T, class Enable = bool> struct asm_vtestpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','t','e','s','t','p','d', str...>, hold<T...>> {
    using value = typename asm_vtestpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vtestpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vtestpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0F>, mrm_v<hold<T...>, Y...>>;
};

//  vtestpd ANY [RM] r  [66] 0F 

template<typename ...T, typename ...Y>
struct asm_vtestpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0F>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vtestpd<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0F>, mrm_v<hold<T...>, Y...>>;
};

//  vtestps ANY [RM] r  [66] 0E 
template<class T, class Enable = bool> struct asm_vtestps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','t','e','s','t','p','s', str...>, hold<T...>> {
    using value = typename asm_vtestps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vtestps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vtestps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0E>, mrm_v<hold<T...>, Y...>>;
};

//  vtestps ANY [RM] r  [66] 0E 

template<typename ...T, typename ...Y>
struct asm_vtestps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vtestps<hold<zip<reg256>::with<T...>, ptr<reg256, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0E>, mrm_v<hold<T...>, Y...>>;
};

//  vucomisd ANY [RM] r  [66] 2E 
template<class T, class Enable = bool> struct asm_vucomisd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','u','c','o','m','i','s','d', str...>, hold<T...>> {
    using value = typename asm_vucomisd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vucomisd<hold<zip<reg128>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x2E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vucomisd<hold<zip<reg128>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x2E>, mrm_v<hold<T...>, Y...>>;
};

//  vucomiss ANY [RM] r  [] 2E 
template<class T, class Enable = bool> struct asm_vucomiss {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','u','c','o','m','i','s','s', str...>, hold<T...>> {
    using value = typename asm_vucomiss<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_vucomiss<hold<zip<reg128>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0>>::value, byte_seq<0x2E>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_vucomiss<hold<zip<reg128>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0>>::value, byte_seq<0x2E>, mrm_v<hold<T...>, Y...>>;
};

//  vunpckhpd ANY [RVM] r  [66] 15 
template<class T, class Enable = bool> struct asm_vunpckhpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','u','n','p','c','k','h','p','d', str...>, hold<T...>> {
    using value = typename asm_vunpckhpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vunpckhpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x15>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vunpckhpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x15>, mrm_v<hold<T...>, Z...>>;
};

//  vunpckhpd ANY [RVM] r  [66] 15 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vunpckhpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x15>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vunpckhpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x15>, mrm_v<hold<T...>, Z...>>;
};

//  vunpckhps ANY [RVM] r  [] 15 
template<class T, class Enable = bool> struct asm_vunpckhps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','u','n','p','c','k','h','p','s', str...>, hold<T...>> {
    using value = typename asm_vunpckhps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vunpckhps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x15>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vunpckhps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x15>, mrm_v<hold<T...>, Z...>>;
};

//  vunpckhps ANY [RVM] r  [] 15 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vunpckhps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x15>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vunpckhps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x15>, mrm_v<hold<T...>, Z...>>;
};

//  vunpcklpd ANY [RVM] r  [66] 14 
template<class T, class Enable = bool> struct asm_vunpcklpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','u','n','p','c','k','l','p','d', str...>, hold<T...>> {
    using value = typename asm_vunpcklpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vunpcklpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x14>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vunpcklpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x14>, mrm_v<hold<T...>, Z...>>;
};

//  vunpcklpd ANY [RVM] r  [66] 14 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vunpcklpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x14>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vunpcklpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x14>, mrm_v<hold<T...>, Z...>>;
};

//  vunpcklps ANY [RVM] r  [] 14 
template<class T, class Enable = bool> struct asm_vunpcklps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','u','n','p','c','k','l','p','s', str...>, hold<T...>> {
    using value = typename asm_vunpcklps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vunpcklps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x14>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vunpcklps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x14>, mrm_v<hold<T...>, Z...>>;
};

//  vunpcklps ANY [RVM] r  [] 14 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vunpcklps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x14>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vunpcklps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x14>, mrm_v<hold<T...>, Z...>>;
};

//  vxorpd ANY [RVM] r  [66] 57 
template<class T, class Enable = bool> struct asm_vxorpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','x','o','r','p','d', str...>, hold<T...>> {
    using value = typename asm_vxorpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vxorpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x57>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vxorpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x57>, mrm_v<hold<T...>, Z...>>;
};

//  vxorpd ANY [RVM] r  [66] 57 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vxorpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x57>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vxorpd<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x57>, mrm_v<hold<T...>, Z...>>;
};

//  vxorps ANY [RVM] r  [] 57 
template<class T, class Enable = bool> struct asm_vxorps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','x','o','r','p','s', str...>, hold<T...>> {
    using value = typename asm_vxorps<hold<T...>>::value;
};
template<typename ...T, typename ...Y, typename ...Z>
struct asm_vxorps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x57>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vxorps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x57>, mrm_v<hold<T...>, Z...>>;
};

//  vxorps ANY [RVM] r  [] 57 

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vxorps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>>, bool> {
  using value = expseq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x57>, typename modrm<hold<Z...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y, typename ...Z>
struct asm_vxorps<hold<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>>, bool> { 
 using value = expseq_v<typename mrm<Z...>::_67h, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x57>, mrm_v<hold<T...>, Z...>>;
};

//  vzeroall ANY [NONE]   [] 77 
template<class T, class Enable = bool> struct asm_vzeroall {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','z','e','r','o','a','l','l', str...>, hold<T...>> {
    using value = typename asm_vzeroall<hold<T...>>::value;
};
template <> struct asm_vzeroall<hold<>, bool> { using value = expseq_v<typename VEX<disp8<0>, hold<reg<0>>, disp16<256>, disp8<0>>::value, byte_seq<0x77>>; };
//  vzeroupper ANY [NONE]   [] 77 
template<class T, class Enable = bool> struct asm_vzeroupper {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','z','e','r','o','u','p','p','e','r', str...>, hold<T...>> {
    using value = typename asm_vzeroupper<hold<T...>>::value;
};
template <> struct asm_vzeroupper<hold<>, bool> { using value = expseq_v<typename VEX<disp8<0>, hold<reg<0>>, disp16<128>, disp8<0>>::value, byte_seq<0x77>>; };
//  wait ANY [NONE]   [] 9B 
template<class T, class Enable = bool> struct asm_wait {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','a','i','t', str...>, hold<T...>> {
    using value = typename asm_wait<hold<T...>>::value;
};
template <> struct asm_wait<hold<>, bool> { using value = expseq_v<byte_seq<0x9B>>; };
//  wbinvd ANY [NONE]   [] 09 
template<class T, class Enable = bool> struct asm_wbinvd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','b','i','n','v','d', str...>, hold<T...>> {
    using value = typename asm_wbinvd<hold<T...>>::value;
};
template <> struct asm_wbinvd<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x09>>; };
//  wbnoinvd ANY [NONE]   [F3] 09 
template<class T, class Enable = bool> struct asm_wbnoinvd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','b','n','o','i','n','v','d', str...>, hold<T...>> {
    using value = typename asm_wbnoinvd<hold<T...>>::value;
};
template <> struct asm_wbnoinvd<hold<>, bool> { using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, byte_seq<0x09>>; };
//  wrfsbase X64 [M] 2  [F3] AE 
template<class T, class Enable = bool> struct asm_wrfsbase {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','r','f','s','b','a','s','e', str...>, hold<T...>> {
    using value = typename asm_wrfsbase<hold<T...>>::value;
};
template<typename ...T>
struct asm_wrfsbase<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

//  wrfsbase X64 [M] 2  [F3] AE 

template<typename ...T>
struct asm_wrfsbase<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<2>>>::value>;
};

//  wrgsbase X64 [M] 3  [F3] AE 
template<class T, class Enable = bool> struct asm_wrgsbase {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','r','g','s','b','a','s','e', str...>, hold<T...>> {
    using value = typename asm_wrgsbase<hold<T...>>::value;
};
template<typename ...T>
struct asm_wrgsbase<hold<zip<reg32>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

//  wrgsbase X64 [M] 3  [F3] AE 

template<typename ...T>
struct asm_wrgsbase<hold<zip<reg64>::with<T...>>, bool> {
  using value = expseq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<3>>>::value>;
};

//  wrmsr ANY [NONE]   [] 30 
template<class T, class Enable = bool> struct asm_wrmsr {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','r','m','s','r', str...>, hold<T...>> {
    using value = typename asm_wrmsr<hold<T...>>::value;
};
template <>
struct asm_wrmsr<hold<>, bool> { using value = expseq_v<byte_seq<0x0F>, byte_seq<0x30>>; };
//  wrssd ANY [MR] r  [] F6 
template<class T, class Enable = bool> struct asm_wrssd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','r','s','s','d', str...>, hold<T...>> {
    using value = typename asm_wrssd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_wrssd<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_wrssd<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF6>, mrm_v<hold<Y...>, T...>>;
};

//  wrssq X64 [MR] r  [] F6 
template<class T, class Enable = bool> struct asm_wrssq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','r','s','s','q', str...>, hold<T...>> {
    using value = typename asm_wrssq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_wrssq<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_wrssq<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF6>, mrm_v<hold<Y...>, T...>>;
};

//  wrussd ANY [MR] r  [66] F5 
template<class T, class Enable = bool> struct asm_wrussd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','r','u','s','s','d', str...>, hold<T...>> {
    using value = typename asm_wrussd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_wrussd<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF5>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_wrussd<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF5>, mrm_v<hold<Y...>, T...>>;
};

//  wrussq X64 [MR] r  [66] F5 
template<class T, class Enable = bool> struct asm_wrussq {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','r','u','s','s','q', str...>, hold<T...>> {
    using value = typename asm_wrussq<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_wrussq<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF5>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_wrussq<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF5>, mrm_v<hold<Y...>, T...>>;
};

//  xabort ANY [I] 7  [] C6 
template<class T, class Enable = bool> struct asm_xabort {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','a','b','o','r','t', str...>, hold<T...>> {
    using value = typename asm_xabort<hold<T...>>::value;
};
template <class T> 
struct asm_xabort<hold<T>, typename u8_8<T>::type> {
  using value = expseq_v<byte_seq<0xC6>, typename u8_8<T>::value>;
};
//  xadd ANY [MR] r  [] C0 
template<class T, class Enable = bool> struct asm_xadd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','a','d','d', str...>, hold<T...>> {
    using value = typename asm_xadd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_xadd<hold<zip<reg8>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC0>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_xadd<hold<ptr<reg8, T...>, zip<reg8>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC0>, mrm_v<hold<Y...>, T...>>;
};

//  xadd ANY [MR] r  [66] C1 

template<typename ...T, typename ...Y>
struct asm_xadd<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC1>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_xadd<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<Y...>, T...>>;
};

//  xadd ANY [MR] r  [] C1 

template<typename ...T, typename ...Y>
struct asm_xadd<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC1>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_xadd<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<Y...>, T...>>;
};

//  xadd X64 [MR] r  [] C1 

template<typename ...T, typename ...Y>
struct asm_xadd<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC1>, typename modrm<hold<T...>, hold<Y...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_xadd<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, mrm_v<hold<Y...>, T...>>;
};

//  xbegin ANY [NONE] 7  [66] C7 
template<class T, class Enable = bool> struct asm_xbegin {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','b','e','g','i','n', str...>, hold<T...>> {
    using value = typename asm_xbegin<hold<T...>>::value;
};
template <uint16_t T>
struct asm_xbegin<hold<disp16<T>>, bool> { using value = expseq_v<byte_seq<0x66>, byte_seq<0xC7>, typename disp16<T>::value>; };
//  xchg ANY [O]   [66] 90 
template<class T, class Enable = bool> struct asm_xchg {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','c','h','g', str...>, hold<T...>> {
    using value = typename asm_xchg<hold<T...>>::value;
};
//  xchg ANY [O]   [] 90 

//  xchg X64 [O]   [] 90 

//  xchg ANY [O]   [66] 90 

//  xchg ANY [O]   [] 90 

//  xchg X64 [O]   [] 90 

//  xchg ANY [MR] r  [] 86 

template<typename ...T, typename ...Y>
struct asm_xchg<hold<ptr<reg8, T...>, zip<reg8>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x86>, mrm_v<hold<Y...>, T...>>;
};

//  xchg ANY [MR] r  [66] 87 

template<typename ...T, typename ...Y>
struct asm_xchg<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x87>, mrm_v<hold<Y...>, T...>>;
};

//  xchg ANY [MR] r  [] 87 

template<typename ...T, typename ...Y>
struct asm_xchg<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x87>, mrm_v<hold<Y...>, T...>>;
};

//  xchg X64 [MR] r  [] 87 

template<typename ...T, typename ...Y>
struct asm_xchg<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x87>, mrm_v<hold<Y...>, T...>>;
};

//  xchg ANY [RM] r  [] 86 

template<typename ...T, typename ...Y>
struct asm_xchg<hold<zip<reg8>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x86>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_xchg<hold<zip<reg8>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x86>, mrm_v<hold<T...>, Y...>>;
};

//  xchg ANY [RM] r  [66] 87 

template<typename ...T, typename ...Y>
struct asm_xchg<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x87>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_xchg<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x87>, mrm_v<hold<T...>, Y...>>;
};

//  xchg ANY [RM] r  [] 87 

template<typename ...T, typename ...Y>
struct asm_xchg<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x87>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_xchg<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x87>, mrm_v<hold<T...>, Y...>>;
};

//  xchg X64 [RM] r  [] 87 

template<typename ...T, typename ...Y>
struct asm_xchg<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x87>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_xchg<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x87>, mrm_v<hold<T...>, Y...>>;
};

//  xend ANY [NONE]   [] D5 
template<class T, class Enable = bool> struct asm_xend {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','e','n','d', str...>, hold<T...>> {
    using value = typename asm_xend<hold<T...>>::value;
};
template <> struct asm_xend<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xD5>>; };
//  xgetbv ANY [NONE]   [] D0 
template<class T, class Enable = bool> struct asm_xgetbv {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','g','e','t','b','v', str...>, hold<T...>> {
    using value = typename asm_xgetbv<hold<T...>>::value;
};
template <>
struct asm_xgetbv<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xD0>>; };
//  xlatb ANY [NONE]   [] D7 
template<class T, class Enable = bool> struct asm_xlatb {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','l','a','t','b', str...>, hold<T...>> {
    using value = typename asm_xlatb<hold<T...>>::value;
};
template <> struct asm_xlatb<hold<>, bool> { using value = expseq_v<byte_seq<0xD7>>; };
//  xor ANY [I]   [] 34 
template<class T, class Enable = bool> struct asm_xor {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','o','r', str...>, hold<T...>> {
    using value = typename asm_xor<hold<T...>>::value;
};
template <class Y> 
struct asm_xor<hold<al, Y>, typename u8_8<Y>::type>{
  using value = expseq_v<byte_seq<0x34>, typename u8_8<Y>::value>;
};
//  xor ANY [I]   [66] 35 

template <class Y> 
struct asm_xor<hold<ax, Y>, typename u16_8<Y>::type>{
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x35>, typename u16_8<Y>::value>;
};
//  xor ANY [I]   [] 35 

template <class Y> 
struct asm_xor<hold<eax, Y>, typename u32_8<Y>::type>{
  using value = expseq_v<byte_seq<0x35>, typename u32_8<Y>::value>;
};
//  xor X64 [I]   [] 35 

template <class Y> 
struct asm_xor<hold<rax, Y>, typename i32_8<Y>::type>{
  using value = expseq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x35>, typename i32_8<Y>::value>;
};
//  xor ANY [MI] 6  [] 80 

template<typename ...T, class Y>
struct asm_xor<hold<ptr<reg8, T...>, Y>, typename u8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x80>, mrm_v<hold<reg<6>>, T...>, typename u8_8<Y>::value>;
};

//  xor ANY [MI] 6  [66] 81 

template<typename ...T, class Y>
struct asm_xor<hold<ptr<reg16, T...>, Y>, typename u16_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<6>>, T...>, typename u16_8<Y>::value>;
};

//  xor ANY [MI] 6  [] 81 

template<typename ...T, class Y>
struct asm_xor<hold<ptr<reg32, T...>, Y>, typename u32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<6>>, T...>, typename u32_8<Y>::value>;
};

//  xor X64 [MI] 6  [] 81 

template<typename ...T, class Y>
struct asm_xor<hold<ptr<reg64, T...>, Y>, typename i32_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, mrm_v<hold<reg<6>>, T...>, typename i32_8<Y>::value>;
};

//  xor ANY [MI] 6  [66] 83 

template<typename ...T, class Y>
struct asm_xor<hold<ptr<reg16, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<6>>, T...>, typename i8_8<Y>::value>;
};

//  xor ANY [MI] 6  [] 83 

template<typename ...T, class Y>
struct asm_xor<hold<ptr<reg32, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<6>>, T...>, typename i8_8<Y>::value>;
};

//  xor X64 [MI] 6  [] 83 

template<typename ...T, class Y>
struct asm_xor<hold<ptr<reg64, T...>, Y>, typename i8_8<Y>::type> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, mrm_v<hold<reg<6>>, T...>, typename i8_8<Y>::value>;
};

//  xor ANY [MR] r  [] 30 

template<typename ...T, typename ...Y>
struct asm_xor<hold<ptr<reg8, T...>, zip<reg8>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x30>, mrm_v<hold<Y...>, T...>>;
};

//  xor ANY [MR] r  [66] 31 

template<typename ...T, typename ...Y>
struct asm_xor<hold<ptr<reg16, T...>, zip<reg16>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x31>, mrm_v<hold<Y...>, T...>>;
};

//  xor ANY [MR] r  [] 31 

template<typename ...T, typename ...Y>
struct asm_xor<hold<ptr<reg32, T...>, zip<reg32>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x31>, mrm_v<hold<Y...>, T...>>;
};

//  xor X64 [MR] r  [] 31 

template<typename ...T, typename ...Y>
struct asm_xor<hold<ptr<reg64, T...>, zip<reg64>::with<Y...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x31>, mrm_v<hold<Y...>, T...>>;
};

//  xor ANY [RM] r  [] 32 

template<typename ...T, typename ...Y>
struct asm_xor<hold<zip<reg8>::with<T...>, zip<reg8>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x32>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_xor<hold<zip<reg8>::with<T...>, ptr<reg8, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x32>, mrm_v<hold<T...>, Y...>>;
};

//  xor ANY [RM] r  [66] 33 

template<typename ...T, typename ...Y>
struct asm_xor<hold<zip<reg16>::with<T...>, zip<reg16>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x33>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_xor<hold<zip<reg16>::with<T...>, ptr<reg16, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x33>, mrm_v<hold<T...>, Y...>>;
};

//  xor ANY [RM] r  [] 33 

template<typename ...T, typename ...Y>
struct asm_xor<hold<zip<reg32>::with<T...>, zip<reg32>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x33>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_xor<hold<zip<reg32>::with<T...>, ptr<reg32, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x33>, mrm_v<hold<T...>, Y...>>;
};

//  xor X64 [RM] r  [] 33 

template<typename ...T, typename ...Y>
struct asm_xor<hold<zip<reg64>::with<T...>, zip<reg64>::with<Y...>>, bool> {
  using value = expseq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x33>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_xor<hold<zip<reg64>::with<T...>, ptr<reg64, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x33>, mrm_v<hold<T...>, Y...>>;
};

//  xorpd ANY [RM] r  [66] 57 
template<class T, class Enable = bool> struct asm_xorpd {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','o','r','p','d', str...>, hold<T...>> {
    using value = typename asm_xorpd<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_xorpd<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x57>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_xorpd<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x57>, mrm_v<hold<T...>, Y...>>;
};

//  xorps ANY [RM] r  [] 57 
template<class T, class Enable = bool> struct asm_xorps {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','o','r','p','s', str...>, hold<T...>> {
    using value = typename asm_xorps<hold<T...>>::value;
};
template<typename ...T, typename ...Y>
struct asm_xorps<hold<zip<reg128>::with<T...>, zip<reg128>::with<Y...>>, bool> {
  using value = expseq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x57>, typename modrm<hold<Y...>, hold<T...>>::value>;
};

template<typename ...T, typename ...Y>
struct asm_xorps<hold<zip<reg128>::with<T...>, ptr<reg128, Y...>>, bool> { 
 using value = expseq_v<typename mrm<Y...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x57>, mrm_v<hold<T...>, Y...>>;
};

//  xresldtrk ANY [NONE]   [F2] E9 
template<class T, class Enable = bool> struct asm_xresldtrk {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','r','e','s','l','d','t','r','k', str...>, hold<T...>> {
    using value = typename asm_xresldtrk<hold<T...>>::value;
};
template <> struct asm_xresldtrk<hold<>, bool> { using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x01>, byte_seq<0xE9>>; };
//  xrstor ANY [M] 5  [] AE 
template<class T, class Enable = bool> struct asm_xrstor {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','r','s','t','o','r', str...>, hold<T...>> {
    using value = typename asm_xrstor<hold<T...>>::value;
};
template<typename ...T>
struct asm_xrstor<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, mrm_v<hold<reg<5>>, T...>>;
};

//  xrstor64 X64 [M] 5  [] AE 
template<class T, class Enable = bool> struct asm_xrstor64 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','r','s','t','o','r','6','4', str...>, hold<T...>> {
    using value = typename asm_xrstor64<hold<T...>>::value;
};
template<typename ...T>
struct asm_xrstor64<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, mrm_v<hold<reg<5>>, T...>>;
};

//  xrstors ANY [M] 3  [] C7 
template<class T, class Enable = bool> struct asm_xrstors {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','r','s','t','o','r','s', str...>, hold<T...>> {
    using value = typename asm_xrstors<hold<T...>>::value;
};
template<typename ...T>
struct asm_xrstors<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, mrm_v<hold<reg<3>>, T...>>;
};

//  xrstors64 X64 [M] 3  [] C7 
template<class T, class Enable = bool> struct asm_xrstors64 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','r','s','t','o','r','s','6','4', str...>, hold<T...>> {
    using value = typename asm_xrstors64<hold<T...>>::value;
};
template<typename ...T>
struct asm_xrstors64<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, mrm_v<hold<reg<3>>, T...>>;
};

//  xsave ANY [M] 4  [] AE 
template<class T, class Enable = bool> struct asm_xsave {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','a','v','e', str...>, hold<T...>> {
    using value = typename asm_xsave<hold<T...>>::value;
};
template<typename ...T>
struct asm_xsave<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, mrm_v<hold<reg<4>>, T...>>;
};

//  xsave64 X64 [M] 4  [] AE 
template<class T, class Enable = bool> struct asm_xsave64 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','a','v','e','6','4', str...>, hold<T...>> {
    using value = typename asm_xsave64<hold<T...>>::value;
};
template<typename ...T>
struct asm_xsave64<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, mrm_v<hold<reg<4>>, T...>>;
};

//  xsavec ANY [M] 4  [] C7 
template<class T, class Enable = bool> struct asm_xsavec {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','a','v','e','c', str...>, hold<T...>> {
    using value = typename asm_xsavec<hold<T...>>::value;
};
template<typename ...T>
struct asm_xsavec<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, mrm_v<hold<reg<4>>, T...>>;
};

//  xsavec64 X64 [M] 4  [] C7 
template<class T, class Enable = bool> struct asm_xsavec64 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','a','v','e','c','6','4', str...>, hold<T...>> {
    using value = typename asm_xsavec64<hold<T...>>::value;
};
template<typename ...T>
struct asm_xsavec64<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, mrm_v<hold<reg<4>>, T...>>;
};

//  xsaveopt ANY [M] 6  [] AE 
template<class T, class Enable = bool> struct asm_xsaveopt {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','a','v','e','o','p','t', str...>, hold<T...>> {
    using value = typename asm_xsaveopt<hold<T...>>::value;
};
template<typename ...T>
struct asm_xsaveopt<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, mrm_v<hold<reg<6>>, T...>>;
};

//  xsaveopt64 X64 [M] 6  [] AE 
template<class T, class Enable = bool> struct asm_xsaveopt64 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','a','v','e','o','p','t','6','4', str...>, hold<T...>> {
    using value = typename asm_xsaveopt64<hold<T...>>::value;
};
template<typename ...T>
struct asm_xsaveopt64<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, mrm_v<hold<reg<6>>, T...>>;
};

//  xsaves ANY [M] 5  [] C7 
template<class T, class Enable = bool> struct asm_xsaves {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','a','v','e','s', str...>, hold<T...>> {
    using value = typename asm_xsaves<hold<T...>>::value;
};
template<typename ...T>
struct asm_xsaves<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, mrm_v<hold<reg<5>>, T...>>;
};

//  xsaves64 X64 [M] 5  [] C7 
template<class T, class Enable = bool> struct asm_xsaves64 {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','a','v','e','s','6','4', str...>, hold<T...>> {
    using value = typename asm_xsaves64<hold<T...>>::value;
};
template<typename ...T>
struct asm_xsaves64<hold<ptr<reg64, T...>>, bool> { 
 using value = expseq_v<typename mrm<T...>::_67h, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, mrm_v<hold<reg<5>>, T...>>;
};

//  xsetbv ANY [NONE]   [] D1 
template<class T, class Enable = bool> struct asm_xsetbv {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','e','t','b','v', str...>, hold<T...>> {
    using value = typename asm_xsetbv<hold<T...>>::value;
};
template <>
struct asm_xsetbv<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xD1>>; };
//  xsusldtrk ANY [NONE]   [F2] E8 
template<class T, class Enable = bool> struct asm_xsusldtrk {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','u','s','l','d','t','r','k', str...>, hold<T...>> {
    using value = typename asm_xsusldtrk<hold<T...>>::value;
};
template <> struct asm_xsusldtrk<hold<>, bool> { using value = expseq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x01>, byte_seq<0xE8>>; };
//  xtest ANY [NONE]   [] D6 
template<class T, class Enable = bool> struct asm_xtest {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','t','e','s','t', str...>, hold<T...>> {
    using value = typename asm_xtest<hold<T...>>::value;
};
template <> struct asm_xtest<hold<>, bool> { using value = expseq_v<byte_seq<0x0F, 0x01>, byte_seq<0xD6>>; };

}
