#include "asm.hpp"
//  aaa X86 [NONE]   [] 37 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_aaa = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','a','a', str...>, hold<T...>> {
    static constexpr auto value = asm_aaa<T...>;
};
template <>
constexpr auto asm_aaa<> = seq_to_arr<expand_byte_seq_v< byte_seq<0x37>>>::value;
//  aad X86 [I]   [] D5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_aad = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','a','d', str...>, hold<T...>> {
    static constexpr auto value = asm_aad<T...>;
};
template <uint8_t Y> 
constexpr auto asm_aad<ax, disp8<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0xD5>, typename disp8<Y>::value>>::value;
//  aam X86 [I]   [] D4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_aam = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','a','m', str...>, hold<T...>> {
    static constexpr auto value = asm_aam<T...>;
};
template <uint8_t Y> 
constexpr auto asm_aam<ax, disp8<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0xD4>, typename disp8<Y>::value>>::value;
//  aas X86 [NONE]   [] 3F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_aas = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','a','s', str...>, hold<T...>> {
    static constexpr auto value = asm_aas<T...>;
};
template <>
constexpr auto asm_aas<> = seq_to_arr<expand_byte_seq_v< byte_seq<0x3F>>>::value;
//  adc ANY [I]   [] 14 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_adc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','c', str...>, hold<T...>> {
    static constexpr auto value = asm_adc<T...>;
};
template <uint8_t Y> 
constexpr auto asm_adc<al, disp8<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x14>, typename disp8<Y>::value>>::value;
//  adc ANY [I]   [66] 15 

template <uint16_t Y> 
constexpr auto asm_adc<ax, disp16<Y>> =
    seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0x15>, typename disp16<Y>::value>>::value;
//  adc ANY [I]   [] 15 

template <uint32_t Y> 
constexpr auto asm_adc<eax, disp32<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x15>, typename disp32<Y>::value>>::value;
//  adc X64 [I]   [] 15 

template <uint32_t Y> 
constexpr auto asm_adc<rax, id<Y>> =
    seq_to_arr<expand_byte_seq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x15>, typename id<Y>::value>>::value;
//  adc ANY [MI] 2  [] 80 

template<typename ...T, uint8_t Y>
constexpr auto asm_adc<ptr<reg8, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x80>, typename mrm<T...>::template value<hold<reg<2>>>, typename disp8<Y>::value>>::value;

//  adc ANY [MI] 2  [66] 81 

template<typename ...T, uint16_t Y>
constexpr auto asm_adc<ptr<reg16, T...>, disp16<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<2>>>, typename disp16<Y>::value>>::value;

//  adc ANY [MI] 2  [] 81 

template<typename ...T, uint32_t Y>
constexpr auto asm_adc<ptr<reg32, T...>, disp32<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<2>>>, typename disp32<Y>::value>>::value;

//  adc X64 [MI] 2  [] 81 

template<typename ...T, uint32_t Y>
constexpr auto asm_adc<ptr<reg64, T...>, id<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<2>>>, typename id<Y>::value>>::value;

//  adc ANY [MI] 2  [66] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_adc<ptr<reg16, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<2>>>, typename ib<Y>::value>>::value;

//  adc ANY [MI] 2  [] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_adc<ptr<reg32, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<2>>>, typename ib<Y>::value>>::value;

//  adc X64 [MI] 2  [] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_adc<ptr<reg64, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<2>>>, typename ib<Y>::value>>::value;

//  adc ANY [MR] r  [] 10 

template<typename ...T, typename ...Y>
constexpr auto asm_adc<ptr<reg8, T...>, zip<reg8>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x10>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  adc ANY [MR] r  [66] 11 

template<typename ...T, typename ...Y>
constexpr auto asm_adc<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x11>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  adc ANY [MR] r  [] 11 

template<typename ...T, typename ...Y>
constexpr auto asm_adc<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x11>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  adc X64 [MR] r  [] 11 

template<typename ...T, typename ...Y>
constexpr auto asm_adc<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x11>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  adc ANY [RM] r  [] 12 

template<typename ...T, typename ...Y>
constexpr auto asm_adc<zip<reg8>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_adc<zip<reg8>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x12>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  adc ANY [RM] r  [66] 13 

template<typename ...T, typename ...Y>
constexpr auto asm_adc<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x13>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_adc<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x13>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  adc ANY [RM] r  [] 13 

template<typename ...T, typename ...Y>
constexpr auto asm_adc<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x13>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_adc<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x13>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  adc X64 [RM] r  [] 13 

template<typename ...T, typename ...Y>
constexpr auto asm_adc<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x13>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_adc<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x13>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  adcx ANY [RM] r  [66] F6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_adcx = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','c','x', str...>, hold<T...>> {
    static constexpr auto value = asm_adcx<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_adcx<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_adcx<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  adcx X64 [RM] r  [66] F6 

template<typename ...T, typename ...Y>
constexpr auto asm_adcx<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_adcx<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  add ANY [I]   [] 04 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_add = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','d', str...>, hold<T...>> {
    static constexpr auto value = asm_add<T...>;
};
template <uint8_t Y> 
constexpr auto asm_add<al, disp8<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x04>, typename disp8<Y>::value>>::value;
//  add ANY [I]   [66] 05 

template <uint16_t Y> 
constexpr auto asm_add<ax, disp16<Y>> =
    seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0x05>, typename disp16<Y>::value>>::value;
//  add ANY [I]   [] 05 

template <uint32_t Y> 
constexpr auto asm_add<eax, disp32<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x05>, typename disp32<Y>::value>>::value;
//  add X64 [I]   [] 05 

template <uint32_t Y> 
constexpr auto asm_add<rax, id<Y>> =
    seq_to_arr<expand_byte_seq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x05>, typename id<Y>::value>>::value;
//  add ANY [MI] 0  [] 80 

template<typename ...T, uint8_t Y>
constexpr auto asm_add<ptr<reg8, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x80>, typename mrm<T...>::template value<hold<reg<0>>>, typename disp8<Y>::value>>::value;

//  add ANY [MI] 0  [66] 81 

template<typename ...T, uint16_t Y>
constexpr auto asm_add<ptr<reg16, T...>, disp16<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<0>>>, typename disp16<Y>::value>>::value;

//  add ANY [MI] 0  [] 81 

template<typename ...T, uint32_t Y>
constexpr auto asm_add<ptr<reg32, T...>, disp32<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<0>>>, typename disp32<Y>::value>>::value;

//  add X64 [MI] 0  [] 81 

template<typename ...T, uint32_t Y>
constexpr auto asm_add<ptr<reg64, T...>, id<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<0>>>, typename id<Y>::value>>::value;

//  add ANY [MI] 0  [66] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_add<ptr<reg16, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<0>>>, typename ib<Y>::value>>::value;

//  add ANY [MI] 0  [] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_add<ptr<reg32, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<0>>>, typename ib<Y>::value>>::value;

//  add X64 [MI] 0  [] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_add<ptr<reg64, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<0>>>, typename ib<Y>::value>>::value;

//  add ANY [MR] r  [] 00 

template<typename ...T, typename ...Y>
constexpr auto asm_add<ptr<reg8, T...>, zip<reg8>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x00>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  add ANY [MR] r  [66] 01 

template<typename ...T, typename ...Y>
constexpr auto asm_add<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  add ANY [MR] r  [] 01 

template<typename ...T, typename ...Y>
constexpr auto asm_add<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  add X64 [MR] r  [] 01 

template<typename ...T, typename ...Y>
constexpr auto asm_add<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  add ANY [RM] r  [] 02 

template<typename ...T, typename ...Y>
constexpr auto asm_add<zip<reg8>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x02>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_add<zip<reg8>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x02>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  add ANY [RM] r  [66] 03 

template<typename ...T, typename ...Y>
constexpr auto asm_add<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x03>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_add<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x03>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  add ANY [RM] r  [] 03 

template<typename ...T, typename ...Y>
constexpr auto asm_add<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x03>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_add<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x03>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  add X64 [RM] r  [] 03 

template<typename ...T, typename ...Y>
constexpr auto asm_add<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x03>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_add<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x03>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  addpd ANY [RM] r  [66] 58 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_addpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','d','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_addpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_addpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x58>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_addpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x58>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  addps ANY [RM] r  [] 58 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_addps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','d','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_addps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_addps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x58>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_addps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x58>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  addsd ANY [RM] r  [F2] 58 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_addsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','d','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_addsd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_addsd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x58>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_addsd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x58>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  addss ANY [RM] r  [F3] 58 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_addss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','d','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_addss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_addss<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x58>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_addss<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x58>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  addsubpd ANY [RM] r  [66] D0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_addsubpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','d','s','u','b','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_addsubpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_addsubpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_addsubpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD0>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  addsubps ANY [RM] r  [F2] D0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_addsubps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','d','s','u','b','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_addsubps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_addsubps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_addsubps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD0>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  adox ANY [RM] r  [F3] F6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_adox = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','d','o','x', str...>, hold<T...>> {
    static constexpr auto value = asm_adox<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_adox<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_adox<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  adox X64 [RM] r  [F3] F6 

template<typename ...T, typename ...Y>
constexpr auto asm_adox<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_adox<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  aesdec ANY [RM] r  [66] DE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_aesdec = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','e','s','d','e','c', str...>, hold<T...>> {
    static constexpr auto value = asm_aesdec<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_aesdec<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_aesdec<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDE>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  aesdeclast ANY [RM] r  [66] DF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_aesdeclast = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','e','s','d','e','c','l','a','s','t', str...>, hold<T...>> {
    static constexpr auto value = asm_aesdeclast<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_aesdeclast<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_aesdeclast<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDF>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  aesenc ANY [RM] r  [66] DC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_aesenc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','e','s','e','n','c', str...>, hold<T...>> {
    static constexpr auto value = asm_aesenc<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_aesenc<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_aesenc<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDC>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  aesenclast ANY [RM] r  [66] DD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_aesenclast = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','e','s','e','n','c','l','a','s','t', str...>, hold<T...>> {
    static constexpr auto value = asm_aesenclast<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_aesenclast<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDD>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_aesenclast<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDD>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  aesimc ANY [RM] r  [66] DB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_aesimc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','e','s','i','m','c', str...>, hold<T...>> {
    static constexpr auto value = asm_aesimc<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_aesimc<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDB>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_aesimc<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDB>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  aeskeygenassist ANY [RMI] r  [66] DF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_aeskeygenassist = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','e','s','k','e','y','g','e','n','a','s','s','i','s','t', str...>, hold<T...>> {
    static constexpr auto value = asm_aeskeygenassist<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_aeskeygenassist<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_aeskeygenassist<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDF>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  and ANY [I]   [] 24 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_and = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','n','d', str...>, hold<T...>> {
    static constexpr auto value = asm_and<T...>;
};
template <uint8_t Y> 
constexpr auto asm_and<al, disp8<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x24>, typename disp8<Y>::value>>::value;
//  and ANY [I]   [66] 25 

template <uint16_t Y> 
constexpr auto asm_and<ax, disp16<Y>> =
    seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0x25>, typename disp16<Y>::value>>::value;
//  and ANY [I]   [] 25 

template <uint32_t Y> 
constexpr auto asm_and<eax, disp32<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x25>, typename disp32<Y>::value>>::value;
//  and X64 [I]   [] 25 

template <uint32_t Y> 
constexpr auto asm_and<rax, disp32<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x25>, typename disp32<Y>::value>>::value;
//  and X64 [I]   [] 25 

template <uint32_t Y> 
constexpr auto asm_and<rax, id<Y>> =
    seq_to_arr<expand_byte_seq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x25>, typename id<Y>::value>>::value;
//  and ANY [MI] 4  [] 80 

template<typename ...T, uint8_t Y>
constexpr auto asm_and<ptr<reg8, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x80>, typename mrm<T...>::template value<hold<reg<4>>>, typename disp8<Y>::value>>::value;

//  and ANY [MI] 4  [66] 81 

template<typename ...T, uint16_t Y>
constexpr auto asm_and<ptr<reg16, T...>, disp16<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<4>>>, typename disp16<Y>::value>>::value;

//  and ANY [MI] 4  [] 81 

template<typename ...T, uint32_t Y>
constexpr auto asm_and<ptr<reg32, T...>, disp32<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<4>>>, typename disp32<Y>::value>>::value;

//  and X64 [MI] 4  [] 81 

//  and X64 [MI] 4  [] 81 

template<typename ...T, uint32_t Y>
constexpr auto asm_and<ptr<reg64, T...>, id<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<4>>>, typename id<Y>::value>>::value;

//  and ANY [MI] 4  [66] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_and<ptr<reg16, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<4>>>, typename disp8<Y>::value>>::value;

//  and ANY [MI] 4  [] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_and<ptr<reg32, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<4>>>, typename disp8<Y>::value>>::value;

//  and X64 [MI] 4  [] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_and<ptr<reg64, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<4>>>, typename disp8<Y>::value>>::value;

//  and ANY [MR] r  [] 20 

template<typename ...T, typename ...Y>
constexpr auto asm_and<ptr<reg8, T...>, zip<reg8>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x20>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  and ANY [MR] r  [66] 21 

template<typename ...T, typename ...Y>
constexpr auto asm_and<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x21>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  and ANY [MR] r  [] 21 

template<typename ...T, typename ...Y>
constexpr auto asm_and<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x21>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  and X64 [MR] r  [] 21 

template<typename ...T, typename ...Y>
constexpr auto asm_and<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x21>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  and ANY [RM] r  [] 22 

template<typename ...T, typename ...Y>
constexpr auto asm_and<zip<reg8>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x22>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_and<zip<reg8>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x22>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  and ANY [RM] r  [66] 23 

template<typename ...T, typename ...Y>
constexpr auto asm_and<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x23>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_and<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x23>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  and ANY [RM] r  [] 23 

template<typename ...T, typename ...Y>
constexpr auto asm_and<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x23>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_and<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x23>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  and X64 [RM] r  [] 23 

template<typename ...T, typename ...Y>
constexpr auto asm_and<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x23>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_and<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x23>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  andn ANY [RVM] r  [] F2 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_andn = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','n','d','n', str...>, hold<T...>> {
    static constexpr auto value = asm_andn<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_andn<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xF2>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_andn<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xF2>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  andn X64 [RVM] r  [] F2 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_andn<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xF2>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_andn<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xF2>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  andnpd ANY [RM] r  [66] 55 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_andnpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','n','d','n','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_andnpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_andnpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x55>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_andnpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x55>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  andnps ANY [RM] r  [] 55 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_andnps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','n','d','n','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_andnps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_andnps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x55>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_andnps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x55>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  andpd ANY [RM] r  [66] 54 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_andpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','n','d','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_andpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_andpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x54>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_andpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x54>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  andps ANY [RM] r  [] 54 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_andps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','n','d','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_andps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_andps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x54>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_andps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x54>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  arpl X86 [MR] r  [] 63 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_arpl = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'a','r','p','l', str...>, hold<T...>> {
    static constexpr auto value = asm_arpl<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_arpl<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x63>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_arpl<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x63>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  bextr ANY [RMV] r  [] F7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_bextr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','e','x','t','r', str...>, hold<T...>> {
    static constexpr auto value = asm_bextr<T...>;
};
//  bextr X64 [RMV] r  [] F7 

//  blcfill ANY [VM] 1  [] 01 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_blcfill = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','c','f','i','l','l', str...>, hold<T...>> {
    static constexpr auto value = asm_blcfill<T...>;
};
//  blcfill X64 [VM] 1  [] 01 

//  blci ANY [VM] 6  [] 02 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_blci = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','c','i', str...>, hold<T...>> {
    static constexpr auto value = asm_blci<T...>;
};
//  blci X64 [VM] 6  [] 02 

//  blcic ANY [VM] 5  [] 01 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_blcic = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','c','i','c', str...>, hold<T...>> {
    static constexpr auto value = asm_blcic<T...>;
};
//  blcic X64 [VM] 5  [] 01 

//  blcmsk ANY [VM] 1  [] 02 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_blcmsk = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','c','m','s','k', str...>, hold<T...>> {
    static constexpr auto value = asm_blcmsk<T...>;
};
//  blcmsk X64 [VM] 1  [] 02 

//  blcs ANY [VM] 3  [] 01 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_blcs = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','c','s', str...>, hold<T...>> {
    static constexpr auto value = asm_blcs<T...>;
};
//  blcs X64 [VM] 3  [] 01 

//  blendpd ANY [RMI] r  [66] 0D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_blendpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','e','n','d','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_blendpd<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_blendpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0D>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_blendpd<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0D>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  blendps ANY [RMI] r  [66] 0C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_blendps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','e','n','d','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_blendps<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_blendps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0C>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_blendps<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0C>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  blendvpd ANY [RM] r  [66] 15 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_blendvpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','e','n','d','v','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_blendvpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_blendvpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x15>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_blendvpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x15>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  blendvps ANY [RM] r  [66] 14 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_blendvps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','e','n','d','v','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_blendvps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_blendvps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x14>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_blendvps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x14>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  blsfill ANY [VM] 2  [] 01 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_blsfill = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','s','f','i','l','l', str...>, hold<T...>> {
    static constexpr auto value = asm_blsfill<T...>;
};
//  blsfill X64 [VM] 2  [] 01 

//  blsi ANY [VM] 3  [] F3 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_blsi = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','s','i', str...>, hold<T...>> {
    static constexpr auto value = asm_blsi<T...>;
};
//  blsi X64 [VM] 3  [] F3 

//  blsic ANY [VM] 6  [] 01 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_blsic = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','s','i','c', str...>, hold<T...>> {
    static constexpr auto value = asm_blsic<T...>;
};
//  blsic X64 [VM] 6  [] 01 

//  blsmsk ANY [VM] 2  [] F3 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_blsmsk = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','s','m','s','k', str...>, hold<T...>> {
    static constexpr auto value = asm_blsmsk<T...>;
};
//  blsmsk X64 [VM] 2  [] F3 

//  blsr ANY [VM] 1  [] F3 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_blsr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','l','s','r', str...>, hold<T...>> {
    static constexpr auto value = asm_blsr<T...>;
};
//  blsr X64 [VM] 1  [] F3 

//  bound X86 [RM] r  [66] 62 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_bound = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','o','u','n','d', str...>, hold<T...>> {
    static constexpr auto value = asm_bound<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_bound<zip<reg16>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x62>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_bound<zip<reg16>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x62>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  bound X86 [RM] r  [] 62 

template<typename ...T, typename ...Y>
constexpr auto asm_bound<zip<reg32>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x62>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_bound<zip<reg32>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x62>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  bsf ANY [RM] r  [66] BC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_bsf = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','s','f', str...>, hold<T...>> {
    static constexpr auto value = asm_bsf<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_bsf<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBC>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_bsf<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBC>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  bsf ANY [RM] r  [] BC 

template<typename ...T, typename ...Y>
constexpr auto asm_bsf<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBC>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_bsf<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBC>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  bsf X64 [RM] r  [] BC 

template<typename ...T, typename ...Y>
constexpr auto asm_bsf<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBC>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_bsf<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBC>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  bsr ANY [RM] r  [66] BD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_bsr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','s','r', str...>, hold<T...>> {
    static constexpr auto value = asm_bsr<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_bsr<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBD>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_bsr<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBD>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  bsr ANY [RM] r  [] BD 

template<typename ...T, typename ...Y>
constexpr auto asm_bsr<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBD>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_bsr<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBD>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  bsr X64 [RM] r  [] BD 

template<typename ...T, typename ...Y>
constexpr auto asm_bsr<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBD>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_bsr<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBD>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  bswap ANY [O]   [66] C8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_bswap = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','s','w','a','p', str...>, hold<T...>> {
    static constexpr auto value = asm_bswap<T...>;
};
//  bswap ANY [O]   [] C8 

//  bswap X64 [O]   [] C8 

//  bt ANY [MI] 4  [66] BA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_bt = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','t', str...>, hold<T...>> {
    static constexpr auto value = asm_bt<T...>;
};
template<typename ...T, uint8_t Y>
constexpr auto asm_bt<ptr<reg16, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, typename mrm<T...>::template value<hold<reg<4>>>, typename disp8<Y>::value>>::value;

//  bt ANY [MI] 4  [] BA 

template<typename ...T, uint8_t Y>
constexpr auto asm_bt<ptr<reg32, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, typename mrm<T...>::template value<hold<reg<4>>>, typename disp8<Y>::value>>::value;

//  bt X64 [MI] 4  [] BA 

template<typename ...T, uint8_t Y>
constexpr auto asm_bt<ptr<reg64, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, typename mrm<T...>::template value<hold<reg<4>>>, typename disp8<Y>::value>>::value;

//  bt ANY [MR] r  [66] A3 

template<typename ...T, typename ...Y>
constexpr auto asm_bt<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xA3>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_bt<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xA3>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  bt ANY [MR] r  [] A3 

template<typename ...T, typename ...Y>
constexpr auto asm_bt<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xA3>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_bt<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xA3>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  bt X64 [MR] r  [] A3 

template<typename ...T, typename ...Y>
constexpr auto asm_bt<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xA3>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_bt<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xA3>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  btc ANY [MI] 7  [66] BA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_btc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','t','c', str...>, hold<T...>> {
    static constexpr auto value = asm_btc<T...>;
};
template<typename ...T, uint8_t Y>
constexpr auto asm_btc<ptr<reg16, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, typename mrm<T...>::template value<hold<reg<7>>>, typename disp8<Y>::value>>::value;

//  btc ANY [MI] 7  [] BA 

template<typename ...T, uint8_t Y>
constexpr auto asm_btc<ptr<reg32, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, typename mrm<T...>::template value<hold<reg<7>>>, typename disp8<Y>::value>>::value;

//  btc X64 [MI] 7  [] BA 

template<typename ...T, uint8_t Y>
constexpr auto asm_btc<ptr<reg64, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, typename mrm<T...>::template value<hold<reg<7>>>, typename disp8<Y>::value>>::value;

//  btc ANY [MR] r  [66] BB 

template<typename ...T, typename ...Y>
constexpr auto asm_btc<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xBB>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_btc<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBB>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  btc ANY [MR] r  [] BB 

template<typename ...T, typename ...Y>
constexpr auto asm_btc<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xBB>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_btc<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBB>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  btc X64 [MR] r  [] BB 

template<typename ...T, typename ...Y>
constexpr auto asm_btc<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xBB>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_btc<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBB>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  btr ANY [MI] 6  [66] BA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_btr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','t','r', str...>, hold<T...>> {
    static constexpr auto value = asm_btr<T...>;
};
template<typename ...T, uint8_t Y>
constexpr auto asm_btr<ptr<reg16, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, typename mrm<T...>::template value<hold<reg<6>>>, typename disp8<Y>::value>>::value;

//  btr ANY [MI] 6  [] BA 

template<typename ...T, uint8_t Y>
constexpr auto asm_btr<ptr<reg32, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, typename mrm<T...>::template value<hold<reg<6>>>, typename disp8<Y>::value>>::value;

//  btr X64 [MI] 6  [] BA 

template<typename ...T, uint8_t Y>
constexpr auto asm_btr<ptr<reg64, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, typename mrm<T...>::template value<hold<reg<6>>>, typename disp8<Y>::value>>::value;

//  btr ANY [MR] r  [66] B3 

template<typename ...T, typename ...Y>
constexpr auto asm_btr<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xB3>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_btr<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xB3>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  btr ANY [MR] r  [] B3 

template<typename ...T, typename ...Y>
constexpr auto asm_btr<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xB3>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_btr<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xB3>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  btr X64 [MR] r  [] B3 

template<typename ...T, typename ...Y>
constexpr auto asm_btr<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xB3>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_btr<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xB3>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  bts ANY [MI] 5  [66] BA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_bts = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','t','s', str...>, hold<T...>> {
    static constexpr auto value = asm_bts<T...>;
};
template<typename ...T, uint8_t Y>
constexpr auto asm_bts<ptr<reg16, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, typename mrm<T...>::template value<hold<reg<5>>>, typename disp8<Y>::value>>::value;

//  bts ANY [MI] 5  [] BA 

template<typename ...T, uint8_t Y>
constexpr auto asm_bts<ptr<reg32, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, typename mrm<T...>::template value<hold<reg<5>>>, typename disp8<Y>::value>>::value;

//  bts X64 [MI] 5  [] BA 

template<typename ...T, uint8_t Y>
constexpr auto asm_bts<ptr<reg64, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xBA>, typename mrm<T...>::template value<hold<reg<5>>>, typename disp8<Y>::value>>::value;

//  bts ANY [MR] r  [66] AB 

template<typename ...T, typename ...Y>
constexpr auto asm_bts<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAB>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_bts<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAB>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  bts ANY [MR] r  [] AB 

template<typename ...T, typename ...Y>
constexpr auto asm_bts<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAB>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_bts<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAB>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  bts X64 [MR] r  [] AB 

template<typename ...T, typename ...Y>
constexpr auto asm_bts<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAB>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_bts<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAB>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  bzhi ANY [RMV] r  [] F5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_bzhi = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'b','z','h','i', str...>, hold<T...>> {
    static constexpr auto value = asm_bzhi<T...>;
};
//  bzhi X64 [RMV] r  [] F5 

//  call X86 [D]   [66] E8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_call = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','a','l','l', str...>, hold<T...>> {
    static constexpr auto value = asm_call<T...>;
};
template<uint16_t N>
constexpr auto asm_call<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0xE8>, typename rel16<N>::value>>::value;
//  call ANY [D]   [] E8 

template<uint32_t N>
constexpr auto asm_call<rel32<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0xE8>, typename rel32<N>::value>>::value;
//  call X86 [M] 2  [66] FF 

template<typename ...T>
constexpr auto asm_call<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_call<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  call X86 [M] 2  [] FF 

template<typename ...T>
constexpr auto asm_call<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_call<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  call X64 [M] 2  [] FF 

template<typename ...T>
constexpr auto asm_call<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_call<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  cbw ANY [NONE]   [66] 98 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cbw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_cbw<T...>;
};
template <>
constexpr auto asm_cbw<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0x98>>>::value;
//  cdq ANY [NONE]   [] 99 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cdq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_cdq<T...>;
};
template <>
constexpr auto asm_cdq<> = seq_to_arr<expand_byte_seq_v< byte_seq<0x99>>>::value;
//  cdqe X64 [NONE]   [] 98 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cdqe = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','d','q','e', str...>, hold<T...>> {
    static constexpr auto value = asm_cdqe<T...>;
};
template <>
constexpr auto asm_cdqe<> = seq_to_arr<expand_byte_seq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x98>>>::value;
//  clac ANY [NONE]   [] CA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_clac = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','a','c', str...>, hold<T...>> {
    static constexpr auto value = asm_clac<T...>;
};
template <>
constexpr auto asm_clac<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xCA>>>::value;
//  clc ANY [NONE]   [] F8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_clc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','c', str...>, hold<T...>> {
    static constexpr auto value = asm_clc<T...>;
};
template <>
constexpr auto asm_clc<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xF8>>>::value;
//  cld ANY [NONE]   [] FC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cld = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','d', str...>, hold<T...>> {
    static constexpr auto value = asm_cld<T...>;
};
template <>
constexpr auto asm_cld<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xFC>>>::value;
//  cldemote ANY [M] 0  [] 1C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cldemote = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','d','e','m','o','t','e', str...>, hold<T...>> {
    static constexpr auto value = asm_cldemote<T...>;
};
template<typename ...T>
constexpr auto asm_cldemote<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x1C>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  clflush ANY [M] 7  [] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_clflush = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','f','l','u','s','h', str...>, hold<T...>> {
    static constexpr auto value = asm_clflush<T...>;
};
template<typename ...T>
constexpr auto asm_clflush<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  clflushopt ANY [M] 7  [66] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_clflushopt = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','f','l','u','s','h','o','p','t', str...>, hold<T...>> {
    static constexpr auto value = asm_clflushopt<T...>;
};
template<typename ...T>
constexpr auto asm_clflushopt<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  clgi ANY [NONE]   [] DD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_clgi = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','g','i', str...>, hold<T...>> {
    static constexpr auto value = asm_clgi<T...>;
};
template <>
constexpr auto asm_clgi<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xDD>>>::value;
//  cli ANY [NONE]   [] FA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cli = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','i', str...>, hold<T...>> {
    static constexpr auto value = asm_cli<T...>;
};
template <>
constexpr auto asm_cli<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xFA>>>::value;
//  clrssbsy ANY [M] 6  [F3] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_clrssbsy = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','r','s','s','b','s','y', str...>, hold<T...>> {
    static constexpr auto value = asm_clrssbsy<T...>;
};
template<typename ...T>
constexpr auto asm_clrssbsy<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

template<typename ...T>
constexpr auto asm_clrssbsy<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  clts ANY [NONE]   [] 06 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_clts = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','t','s', str...>, hold<T...>> {
    static constexpr auto value = asm_clts<T...>;
};
template <>
constexpr auto asm_clts<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x06>>>::value;
//  clui X64 [NONE]   [F3] EE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_clui = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','u','i', str...>, hold<T...>> {
    static constexpr auto value = asm_clui<T...>;
};
template <>
constexpr auto asm_clui<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x01>,  byte_seq<0xEE>>>::value;
//  clwb ANY [M] 6  [66] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_clwb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','w','b', str...>, hold<T...>> {
    static constexpr auto value = asm_clwb<T...>;
};
template<typename ...T>
constexpr auto asm_clwb<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  clzero ANY [NONE]   [] FC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_clzero = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','l','z','e','r','o', str...>, hold<T...>> {
    static constexpr auto value = asm_clzero<T...>;
};
template <>
constexpr auto asm_clzero<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xFC>>>::value;
//  cmc ANY [NONE]   [] F5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','c', str...>, hold<T...>> {
    static constexpr auto value = asm_cmc<T...>;
};
template <>
constexpr auto asm_cmc<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xF5>>>::value;
//  cmova ANY [RM] r  [66] 47 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmova = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','a', str...>, hold<T...>> {
    static constexpr auto value = asm_cmova<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmova<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x47>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmova<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x47>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmova ANY [RM] r  [] 47 

template<typename ...T, typename ...Y>
constexpr auto asm_cmova<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x47>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmova<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x47>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmova X64 [RM] r  [] 47 

template<typename ...T, typename ...Y>
constexpr auto asm_cmova<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x47>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmova<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x47>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovae ANY [RM] r  [66] 43 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovae = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','a','e', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovae<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovae<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x43>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovae<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x43>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovae ANY [RM] r  [] 43 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovae<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x43>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovae<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x43>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovae X64 [RM] r  [] 43 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovae<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x43>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovae<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x43>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovb ANY [RM] r  [66] 42 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','b', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovb<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovb<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovb ANY [RM] r  [] 42 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovb<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovb<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovb X64 [RM] r  [] 42 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovb<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovb<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovbe ANY [RM] r  [66] 46 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovbe = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','b','e', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovbe<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovbe<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x46>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovbe<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x46>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovbe ANY [RM] r  [] 46 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovbe<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x46>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovbe<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x46>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovbe X64 [RM] r  [] 46 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovbe<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x46>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovbe<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x46>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovc ANY [RM] r  [66] 42 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','c', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovc<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovc<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovc<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovc ANY [RM] r  [] 42 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovc<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovc<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovc X64 [RM] r  [] 42 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovc<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovc<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmove ANY [RM] r  [66] 44 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmove = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','e', str...>, hold<T...>> {
    static constexpr auto value = asm_cmove<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmove<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x44>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmove<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x44>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmove ANY [RM] r  [] 44 

template<typename ...T, typename ...Y>
constexpr auto asm_cmove<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x44>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmove<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x44>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmove X64 [RM] r  [] 44 

template<typename ...T, typename ...Y>
constexpr auto asm_cmove<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x44>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmove<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x44>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovg ANY [RM] r  [66] 4F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovg = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','g', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovg<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovg<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovg<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovg ANY [RM] r  [] 4F 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovg<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovg<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovg X64 [RM] r  [] 4F 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovg<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovg<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovge ANY [RM] r  [66] 4D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovge = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','g','e', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovge<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovge<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovge<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovge ANY [RM] r  [] 4D 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovge<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovge<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovge X64 [RM] r  [] 4D 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovge<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovge<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovl ANY [RM] r  [66] 4C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovl = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','l', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovl<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovl<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovl<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovl ANY [RM] r  [] 4C 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovl<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovl<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovl X64 [RM] r  [] 4C 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovl<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovl<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovle ANY [RM] r  [66] 4E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovle = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','l','e', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovle<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovle<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovle<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovle ANY [RM] r  [] 4E 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovle<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovle<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovle X64 [RM] r  [] 4E 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovle<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovle<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovna ANY [RM] r  [66] 46 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovna = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','a', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovna<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovna<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x46>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovna<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x46>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovna ANY [RM] r  [] 46 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovna<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x46>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovna<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x46>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovna X64 [RM] r  [] 46 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovna<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x46>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovna<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x46>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnae ANY [RM] r  [66] 42 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovnae = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','a','e', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovnae<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovnae<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnae<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnae ANY [RM] r  [] 42 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnae<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnae<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnae X64 [RM] r  [] 42 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnae<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnae<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnb ANY [RM] r  [66] 43 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovnb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','b', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovnb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovnb<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x43>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnb<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x43>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnb ANY [RM] r  [] 43 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnb<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x43>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnb<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x43>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnb X64 [RM] r  [] 43 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnb<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x43>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnb<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x43>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnbe ANY [RM] r  [66] 47 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovnbe = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','b','e', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovnbe<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovnbe<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x47>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnbe<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x47>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnbe ANY [RM] r  [] 47 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnbe<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x47>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnbe<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x47>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnbe X64 [RM] r  [] 47 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnbe<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x47>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnbe<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x47>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnc ANY [RM] r  [66] 43 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovnc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','c', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovnc<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovnc<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x43>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnc<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x43>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnc ANY [RM] r  [] 43 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnc<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x43>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnc<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x43>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnc X64 [RM] r  [] 43 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnc<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x43>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnc<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x43>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovne ANY [RM] r  [66] 45 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovne = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','e', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovne<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovne<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x45>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovne<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x45>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovne ANY [RM] r  [] 45 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovne<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x45>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovne<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x45>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovne X64 [RM] r  [] 45 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovne<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x45>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovne<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x45>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovng ANY [RM] r  [66] 4E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovng = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','g', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovng<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovng<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovng<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovng ANY [RM] r  [] 4E 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovng<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovng<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovng X64 [RM] r  [] 4E 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovng<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovng<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnge ANY [RM] r  [66] 4C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovnge = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','g','e', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovnge<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovnge<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnge<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnge ANY [RM] r  [] 4C 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnge<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnge<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnge X64 [RM] r  [] 4C 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnge<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnge<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnl ANY [RM] r  [66] 4D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovnl = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','l', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovnl<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovnl<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnl<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnl ANY [RM] r  [] 4D 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnl<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnl<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnl X64 [RM] r  [] 4D 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnl<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnl<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnle ANY [RM] r  [66] 4F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovnle = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','l','e', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovnle<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovnle<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnle<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnle ANY [RM] r  [] 4F 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnle<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnle<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnle X64 [RM] r  [] 4F 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnle<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnle<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovno ANY [RM] r  [66] 41 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovno = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','o', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovno<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovno<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x41>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovno<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x41>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovno ANY [RM] r  [] 41 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovno<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x41>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovno<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x41>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovno X64 [RM] r  [] 41 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovno<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x41>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovno<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x41>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnp ANY [RM] r  [66] 4B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovnp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','p', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovnp<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovnp<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnp<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnp ANY [RM] r  [] 4B 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnp<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnp<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnp X64 [RM] r  [] 4B 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnp<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnp<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovns ANY [RM] r  [66] 49 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovns = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','s', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovns<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovns<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x49>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovns<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x49>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovns ANY [RM] r  [] 49 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovns<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x49>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovns<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x49>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovns X64 [RM] r  [] 49 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovns<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x49>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovns<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x49>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnz ANY [RM] r  [66] 45 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovnz = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','n','z', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovnz<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovnz<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x45>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnz<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x45>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnz ANY [RM] r  [] 45 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnz<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x45>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnz<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x45>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovnz X64 [RM] r  [] 45 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnz<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x45>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovnz<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x45>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovo ANY [RM] r  [66] 40 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovo = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','o', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovo<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovo<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x40>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovo<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x40>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovo ANY [RM] r  [] 40 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovo<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x40>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovo<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x40>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovo X64 [RM] r  [] 40 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovo<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x40>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovo<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x40>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovp ANY [RM] r  [66] 4A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','p', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovp<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovp<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovp<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovp ANY [RM] r  [] 4A 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovp<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovp<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovp X64 [RM] r  [] 4A 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovp<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovp<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovpe ANY [RM] r  [66] 4A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovpe = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','p','e', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovpe<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovpe<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovpe<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovpe ANY [RM] r  [] 4A 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovpe<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovpe<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovpe X64 [RM] r  [] 4A 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovpe<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovpe<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovpo ANY [RM] r  [66] 4B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovpo = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','p','o', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovpo<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovpo<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovpo<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovpo ANY [RM] r  [] 4B 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovpo<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovpo<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovpo X64 [RM] r  [] 4B 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovpo<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x4B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovpo<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x4B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovs ANY [RM] r  [66] 48 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovs = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','s', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovs<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovs<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x48>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovs<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x48>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovs ANY [RM] r  [] 48 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovs<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x48>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovs<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x48>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovs X64 [RM] r  [] 48 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovs<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x48>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovs<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x48>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovz ANY [RM] r  [66] 44 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmovz = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','o','v','z', str...>, hold<T...>> {
    static constexpr auto value = asm_cmovz<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmovz<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x44>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovz<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x44>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovz ANY [RM] r  [] 44 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovz<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x44>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovz<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x44>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmovz X64 [RM] r  [] 44 

template<typename ...T, typename ...Y>
constexpr auto asm_cmovz<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x44>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmovz<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x44>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmp ANY [I]   [] 3C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p', str...>, hold<T...>> {
    static constexpr auto value = asm_cmp<T...>;
};
template <uint8_t Y> 
constexpr auto asm_cmp<al, disp8<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x3C>, typename disp8<Y>::value>>::value;
//  cmp ANY [I]   [66] 3D 

template <uint16_t Y> 
constexpr auto asm_cmp<ax, disp16<Y>> =
    seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0x3D>, typename disp16<Y>::value>>::value;
//  cmp ANY [I]   [] 3D 

template <uint32_t Y> 
constexpr auto asm_cmp<eax, disp32<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x3D>, typename disp32<Y>::value>>::value;
//  cmp X64 [I]   [] 3D 

template <uint32_t Y> 
constexpr auto asm_cmp<rax, id<Y>> =
    seq_to_arr<expand_byte_seq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x3D>, typename id<Y>::value>>::value;
//  cmp ANY [MI] 7  [] 80 

template<typename ...T, uint8_t Y>
constexpr auto asm_cmp<ptr<reg8, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x80>, typename mrm<T...>::template value<hold<reg<7>>>, typename disp8<Y>::value>>::value;

//  cmp ANY [MI] 7  [66] 81 

template<typename ...T, uint16_t Y>
constexpr auto asm_cmp<ptr<reg16, T...>, disp16<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<7>>>, typename disp16<Y>::value>>::value;

//  cmp ANY [MI] 7  [] 81 

template<typename ...T, uint32_t Y>
constexpr auto asm_cmp<ptr<reg32, T...>, disp32<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<7>>>, typename disp32<Y>::value>>::value;

//  cmp X64 [MI] 7  [] 81 

template<typename ...T, uint32_t Y>
constexpr auto asm_cmp<ptr<reg64, T...>, id<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<7>>>, typename id<Y>::value>>::value;

//  cmp ANY [MI] 7  [66] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_cmp<ptr<reg16, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<7>>>, typename ib<Y>::value>>::value;

//  cmp ANY [MI] 7  [] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_cmp<ptr<reg32, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<7>>>, typename ib<Y>::value>>::value;

//  cmp X64 [MI] 7  [] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_cmp<ptr<reg64, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<7>>>, typename ib<Y>::value>>::value;

//  cmp ANY [MR] r  [] 38 

template<typename ...T, typename ...Y>
constexpr auto asm_cmp<ptr<reg8, T...>, zip<reg8>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x38>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  cmp ANY [MR] r  [66] 39 

template<typename ...T, typename ...Y>
constexpr auto asm_cmp<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x39>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  cmp ANY [MR] r  [] 39 

template<typename ...T, typename ...Y>
constexpr auto asm_cmp<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x39>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  cmp X64 [MR] r  [] 39 

template<typename ...T, typename ...Y>
constexpr auto asm_cmp<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x39>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  cmp ANY [RM] r  [] 3A 

template<typename ...T, typename ...Y>
constexpr auto asm_cmp<zip<reg8>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmp<zip<reg8>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmp ANY [RM] r  [66] 3B 

template<typename ...T, typename ...Y>
constexpr auto asm_cmp<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmp<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmp ANY [RM] r  [] 3B 

template<typename ...T, typename ...Y>
constexpr auto asm_cmp<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmp<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmp X64 [RM] r  [] 3B 

template<typename ...T, typename ...Y>
constexpr auto asm_cmp<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmp<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cmppd ANY [RMI] r  [66] C2 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmppd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_cmppd<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_cmppd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC2>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_cmppd<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC2>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  cmpps ANY [RMI] r  [] C2 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmpps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_cmpps<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_cmpps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC2>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_cmpps<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC2>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  cmpsb ANY [NONE]   [] A6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmpsb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_cmpsb<T...>;
};
template <>
constexpr auto asm_cmpsb<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xA6>>>::value;
//  cmpsd ANY [NONE]   [] A7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmpsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_cmpsd<T...>;
};
template <>
constexpr auto asm_cmpsd<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xA7>>>::value;
//  cmpsd ANY [RMI] r  [F2] C2 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_cmpsd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC2>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_cmpsd<zip<reg128>::with<T...>, ptr<reg64, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC2>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  cmpsq X64 [NONE]   [] A7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmpsq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','s','q', str...>, hold<T...>> {
    static constexpr auto value = asm_cmpsq<T...>;
};
template <>
constexpr auto asm_cmpsq<> = seq_to_arr<expand_byte_seq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0xA7>>>::value;
//  cmpss ANY [RMI] r  [F3] C2 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmpss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_cmpss<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_cmpss<zip<reg128>::with<T...>, zip<reg32>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC2>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_cmpss<zip<reg128>::with<T...>, ptr<reg32, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC2>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  cmpsw ANY [NONE]   [66] A7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmpsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_cmpsw<T...>;
};
template <>
constexpr auto asm_cmpsw<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0xA7>>>::value;
//  cmpxchg ANY [MR] r  [] B0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmpxchg = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','x','c','h','g', str...>, hold<T...>> {
    static constexpr auto value = asm_cmpxchg<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cmpxchg<zip<reg8>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xB0>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmpxchg<ptr<reg8, T...>, zip<reg8>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xB0>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  cmpxchg ANY [MR] r  [66] B1 

template<typename ...T, typename ...Y>
constexpr auto asm_cmpxchg<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xB1>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmpxchg<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xB1>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  cmpxchg ANY [MR] r  [] B1 

template<typename ...T, typename ...Y>
constexpr auto asm_cmpxchg<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xB1>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmpxchg<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xB1>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  cmpxchg X64 [MR] r  [] B1 

template<typename ...T, typename ...Y>
constexpr auto asm_cmpxchg<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xB1>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cmpxchg<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xB1>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  cmpxchg16b X64 [M] 1  [] C7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmpxchg16b = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','x','c','h','g','1','6','b', str...>, hold<T...>> {
    static constexpr auto value = asm_cmpxchg16b<T...>;
};
template<typename ...T>
constexpr auto asm_cmpxchg16b<zip<reg128>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_cmpxchg16b<ptr<reg128, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  cmpxchg8b ANY [M] 1  [] C7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cmpxchg8b = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','m','p','x','c','h','g','8','b', str...>, hold<T...>> {
    static constexpr auto value = asm_cmpxchg8b<T...>;
};
template<typename ...T>
constexpr auto asm_cmpxchg8b<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_cmpxchg8b<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  comisd ANY [RM] r  [66] 2F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_comisd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','o','m','i','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_comisd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_comisd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_comisd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  comiss ANY [RM] r  [] 2F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_comiss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','o','m','i','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_comiss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_comiss<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_comiss<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cpuid ANY [NONE]   [] A2 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cpuid = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','p','u','i','d', str...>, hold<T...>> {
    static constexpr auto value = asm_cpuid<T...>;
};
template <>
constexpr auto asm_cpuid<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0xA2>>>::value;
//  cqo X64 [NONE]   [] 99 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cqo = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','q','o', str...>, hold<T...>> {
    static constexpr auto value = asm_cqo<T...>;
};
template <>
constexpr auto asm_cqo<> = seq_to_arr<expand_byte_seq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x99>>>::value;
//  crc32 ANY [RM] r  [F2] F0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_crc32 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','r','c','3','2', str...>, hold<T...>> {
    static constexpr auto value = asm_crc32<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_crc32<zip<reg32>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_crc32<zip<reg32>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF0>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  crc32 ANY [RM] r  [66F2] F1 

template<typename ...T, typename ...Y>
constexpr auto asm_crc32<zip<reg32>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66, 0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF1>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_crc32<zip<reg32>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66, 0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF1>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  crc32 ANY [RM] r  [F2] F1 

template<typename ...T, typename ...Y>
constexpr auto asm_crc32<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF1>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_crc32<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF1>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  crc32 X64 [RM] r  [F2] F0 

template<typename ...T, typename ...Y>
constexpr auto asm_crc32<zip<reg64>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_crc32<zip<reg64>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF0>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  crc32 X64 [RM] r  [F2] F1 

template<typename ...T, typename ...Y>
constexpr auto asm_crc32<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF1>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_crc32<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF1>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtdq2pd ANY [RM] r  [F3] E6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvtdq2pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','d','q','2','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_cvtdq2pd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvtdq2pd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtdq2pd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtdq2ps ANY [RM] r  [] 5B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvtdq2ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','d','q','2','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_cvtdq2ps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvtdq2ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtdq2ps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtpd2dq ANY [RM] r  [F2] E6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvtpd2dq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','p','d','2','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_cvtpd2dq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvtpd2dq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtpd2dq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtpd2pi ANY [RM] r  [66] 2D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvtpd2pi = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','p','d','2','p','i', str...>, hold<T...>> {
    static constexpr auto value = asm_cvtpd2pi<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvtpd2pi<zip<mmx>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtpd2pi<zip<mmx>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtpd2ps ANY [RM] r  [66] 5A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvtpd2ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','p','d','2','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_cvtpd2ps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvtpd2ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtpd2ps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtpi2pd ANY [RM] r  [66] 2A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvtpi2pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','p','i','2','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_cvtpi2pd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvtpi2pd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtpi2pd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtpi2ps ANY [RM] r  [] 2A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvtpi2ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','p','i','2','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_cvtpi2ps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvtpi2ps<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtpi2ps<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtps2dq ANY [RM] r  [66] 5B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvtps2dq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','p','s','2','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_cvtps2dq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvtps2dq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtps2dq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtps2pd ANY [RM] r  [] 5A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvtps2pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','p','s','2','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_cvtps2pd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvtps2pd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtps2pd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtps2pi ANY [RM] r  [] 2D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvtps2pi = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','p','s','2','p','i', str...>, hold<T...>> {
    static constexpr auto value = asm_cvtps2pi<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvtps2pi<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtps2pi<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtsd2si ANY [RM] r  [F2] 2D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvtsd2si = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','s','d','2','s','i', str...>, hold<T...>> {
    static constexpr auto value = asm_cvtsd2si<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvtsd2si<zip<reg32>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtsd2si<zip<reg32>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtsd2si X64 [RM] r  [F2] 2D 

template<typename ...T, typename ...Y>
constexpr auto asm_cvtsd2si<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtsd2si<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtsd2ss ANY [RM] r  [F2] 5A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvtsd2ss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','s','d','2','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_cvtsd2ss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvtsd2ss<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtsd2ss<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtsi2sd ANY [RM] r  [F2] 2A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvtsi2sd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','s','i','2','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_cvtsi2sd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvtsi2sd<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtsi2sd<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtsi2sd X64 [RM] r  [F2] 2A 

template<typename ...T, typename ...Y>
constexpr auto asm_cvtsi2sd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtsi2sd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtsi2ss ANY [RM] r  [F3] 2A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvtsi2ss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','s','i','2','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_cvtsi2ss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvtsi2ss<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtsi2ss<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtsi2ss X64 [RM] r  [F3] 2A 

template<typename ...T, typename ...Y>
constexpr auto asm_cvtsi2ss<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtsi2ss<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtss2sd ANY [RM] r  [F3] 5A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvtss2sd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','s','s','2','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_cvtss2sd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvtss2sd<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtss2sd<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtss2si ANY [RM] r  [F3] 2D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvtss2si = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','s','s','2','s','i', str...>, hold<T...>> {
    static constexpr auto value = asm_cvtss2si<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvtss2si<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtss2si<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvtss2si X64 [RM] r  [F3] 2D 

template<typename ...T, typename ...Y>
constexpr auto asm_cvtss2si<zip<reg64>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvtss2si<zip<reg64>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvttpd2dq ANY [RM] r  [66] E6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvttpd2dq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','t','p','d','2','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_cvttpd2dq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvttpd2dq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvttpd2dq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvttpd2pi ANY [RM] r  [66] 2C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvttpd2pi = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','t','p','d','2','p','i', str...>, hold<T...>> {
    static constexpr auto value = asm_cvttpd2pi<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvttpd2pi<zip<mmx>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvttpd2pi<zip<mmx>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvttps2dq ANY [RM] r  [F3] 5B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvttps2dq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','t','p','s','2','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_cvttps2dq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvttps2dq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvttps2dq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvttps2pi ANY [RM] r  [] 2C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvttps2pi = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','t','p','s','2','p','i', str...>, hold<T...>> {
    static constexpr auto value = asm_cvttps2pi<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvttps2pi<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvttps2pi<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvttsd2si ANY [RM] r  [F2] 2C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvttsd2si = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','t','s','d','2','s','i', str...>, hold<T...>> {
    static constexpr auto value = asm_cvttsd2si<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvttsd2si<zip<reg32>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvttsd2si<zip<reg32>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvttsd2si X64 [RM] r  [F2] 2C 

template<typename ...T, typename ...Y>
constexpr auto asm_cvttsd2si<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvttsd2si<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvttss2si ANY [RM] r  [F3] 2C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cvttss2si = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','v','t','t','s','s','2','s','i', str...>, hold<T...>> {
    static constexpr auto value = asm_cvttss2si<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_cvttss2si<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvttss2si<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cvttss2si X64 [RM] r  [F3] 2C 

template<typename ...T, typename ...Y>
constexpr auto asm_cvttss2si<zip<reg64>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_cvttss2si<zip<reg64>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  cwd ANY [NONE]   [66] 99 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cwd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','w','d', str...>, hold<T...>> {
    static constexpr auto value = asm_cwd<T...>;
};
template <>
constexpr auto asm_cwd<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0x99>>>::value;
//  cwde ANY [NONE]   [] 98 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_cwde = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'c','w','d','e', str...>, hold<T...>> {
    static constexpr auto value = asm_cwde<T...>;
};
template <>
constexpr auto asm_cwde<> = seq_to_arr<expand_byte_seq_v< byte_seq<0x98>>>::value;
//  daa X86 [NONE]   [] 27 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_daa = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','a','a', str...>, hold<T...>> {
    static constexpr auto value = asm_daa<T...>;
};
template <>
constexpr auto asm_daa<> = seq_to_arr<expand_byte_seq_v< byte_seq<0x27>>>::value;
//  das X86 [NONE]   [] 2F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_das = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','a','s', str...>, hold<T...>> {
    static constexpr auto value = asm_das<T...>;
};
template <>
constexpr auto asm_das<> = seq_to_arr<expand_byte_seq_v< byte_seq<0x2F>>>::value;
//  dec X86 [O]   [66] 48 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_dec = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','e','c', str...>, hold<T...>> {
    static constexpr auto value = asm_dec<T...>;
};
//  dec X86 [O]   [] 48 

//  dec ANY [M] 1  [] FE 

template<typename ...T>
constexpr auto asm_dec<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFE>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_dec<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFE>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  dec ANY [M] 1  [66] FF 

template<typename ...T>
constexpr auto asm_dec<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_dec<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  dec ANY [M] 1  [] FF 

template<typename ...T>
constexpr auto asm_dec<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_dec<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  dec X64 [M] 1  [] FF 

template<typename ...T>
constexpr auto asm_dec<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_dec<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  div ANY [M] 6  [] F6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_div = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','i','v', str...>, hold<T...>> {
    static constexpr auto value = asm_div<T...>;
};
template<typename ...Y>
constexpr auto asm_div<zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<reg<6>>>::value>>::value;

template<typename ...Y>
constexpr auto asm_div<ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, typename mrm<Y...>::template value<hold<reg<6>>>>>::value;

//  div ANY [M] 6  [66] F7 

template<typename ...Z>
constexpr auto asm_div<zip<reg16>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<6>>>::value>>::value;

template<typename ...Z>
constexpr auto asm_div<ptr<reg16, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, typename mrm<Z...>::template value<hold<reg<6>>>>>::value;

//  div ANY [M] 6  [] F7 

template<typename ...Z>
constexpr auto asm_div<zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<6>>>::value>>::value;

template<typename ...Z>
constexpr auto asm_div<ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, typename mrm<Z...>::template value<hold<reg<6>>>>>::value;

//  div X64 [M] 6  [] F7 

template<typename ...Z>
constexpr auto asm_div<zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<6>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<6>>>::value>>::value;

template<typename ...Z>
constexpr auto asm_div<ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<6>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, typename mrm<Z...>::template value<hold<reg<6>>>>>::value;

//  divpd ANY [RM] r  [66] 5E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_divpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','i','v','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_divpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_divpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_divpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  divps ANY [RM] r  [] 5E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_divps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','i','v','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_divps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_divps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_divps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  divsd ANY [RM] r  [F2] 5E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_divsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','i','v','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_divsd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_divsd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_divsd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  divss ANY [RM] r  [F3] 5E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_divss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','i','v','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_divss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_divss<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_divss<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  dppd ANY [RMI] r  [66] 41 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_dppd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','p','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_dppd<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_dppd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x41>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_dppd<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x41>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  dpps ANY [RMI] r  [66] 40 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_dpps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'d','p','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_dpps<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_dpps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x40>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_dpps<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x40>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  emms ANY [NONE]   [] 77 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_emms = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'e','m','m','s', str...>, hold<T...>> {
    static constexpr auto value = asm_emms<T...>;
};
template <>
constexpr auto asm_emms<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x77>>>::value;
//  endbr32 ANY [NONE] 7 3 [F3] FB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_endbr32 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'e','n','d','b','r','3','2', str...>, hold<T...>> {
    static constexpr auto value = asm_endbr32<T...>;
};
template <>
constexpr auto asm_endbr32<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>,  byte_seq<0xFB>>>::value;
//  endbr64 ANY [NONE] 7 2 [F3] FA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_endbr64 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'e','n','d','b','r','6','4', str...>, hold<T...>> {
    static constexpr auto value = asm_endbr64<T...>;
};
template <>
constexpr auto asm_endbr64<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>,  byte_seq<0xFA>>>::value;
//  enqcmd X86 [RM] r  [F2] F8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_enqcmd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'e','n','q','c','m','d', str...>, hold<T...>> {
    static constexpr auto value = asm_enqcmd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_enqcmd<zip<reg32>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF8>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_enqcmd<zip<reg32>::with<T...>, ptr<reg512, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF8>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  enqcmd X64 [RM] r  [F2] F8 

template<typename ...T, typename ...Y>
constexpr auto asm_enqcmd<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF8>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_enqcmd<zip<reg64>::with<T...>, ptr<reg512, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF8>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  enqcmds X86 [RM] r  [F3] F8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_enqcmds = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'e','n','q','c','m','d','s', str...>, hold<T...>> {
    static constexpr auto value = asm_enqcmds<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_enqcmds<zip<reg32>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF8>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_enqcmds<zip<reg32>::with<T...>, ptr<reg512, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF8>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  enqcmds X64 [RM] r  [F3] F8 

template<typename ...T, typename ...Y>
constexpr auto asm_enqcmds<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF8>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_enqcmds<zip<reg64>::with<T...>, ptr<reg512, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF8>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  enter ANY [II]   [] C8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_enter = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'e','n','t','e','r', str...>, hold<T...>> {
    static constexpr auto value = asm_enter<T...>;
};
template <uint16_t T, uint8_t Y> 
constexpr auto asm_enter<disp16<T>, disp8<Y>> =
  seq_to_arr<expand_byte_seq_v< byte_seq<0xC8>, typename disp16<T>::value, typename disp8<Y>::value>>::value;
//  extractps ANY [MRI] r  [66] 17 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_extractps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'e','x','t','r','a','c','t','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_extractps<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_extractps<ptr<reg32, T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x17>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  extrq ANY [RII] 0  [66] 78 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_extrq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'e','x','t','r','q', str...>, hold<T...>> {
    static constexpr auto value = asm_extrq<T...>;
};
//  extrq ANY [RM] r  [66] 79 

template<typename ...T, typename ...Y>
constexpr auto asm_extrq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x79>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  f2xm1 ANY [NONE]   [] F0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_f2xm1 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','2','x','m','1', str...>, hold<T...>> {
    static constexpr auto value = asm_f2xm1<T...>;
};
template <>
constexpr auto asm_f2xm1<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xF0>>>::value;
//  fabs ANY [NONE]   [] E1 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fabs = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','a','b','s', str...>, hold<T...>> {
    static constexpr auto value = asm_fabs<T...>;
};
template <>
constexpr auto asm_fabs<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xE1>>>::value;
//  fadd ANY [M] 0  [] D8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fadd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','a','d','d', str...>, hold<T...>> {
    static constexpr auto value = asm_fadd<T...>;
};
template<typename ...T>
constexpr auto asm_fadd<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fadd<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD8>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  fadd ANY [M] 0  [] DC 

template<typename ...T>
constexpr auto asm_fadd<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fadd<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDC>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  fadd ANY [O]   [] C0 

template<typename ...Y>
constexpr auto asm_fadd<st<0>, zip<reg80>::with<Y...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD8>,  byte_seq<0xC0 + reg<reg_n<Y...>::value>::value>>>::value;
//  fadd ANY [O]   [] C0 

template<typename ...T>
constexpr auto asm_fadd<zip<reg80>::with<T...>, st<0>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDC>,  byte_seq<0xC0 + reg<reg_n<T...>::value>::value>>>::value;
//  faddp ANY [NONE]   [] C1 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_faddp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','a','d','d','p', str...>, hold<T...>> {
    static constexpr auto value = asm_faddp<T...>;
};
template <>
constexpr auto asm_faddp<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDE>,  byte_seq<0xC1>>>::value;
//  faddp ANY [O]   [] C0 

template<typename ...T>
constexpr auto asm_faddp<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDE>,  byte_seq<0xC0 + reg<reg_n<T...>::value>::value>>>::value;
//  fbld ANY [M] 4  [] DF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fbld = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','b','l','d', str...>, hold<T...>> {
    static constexpr auto value = asm_fbld<T...>;
};
template<typename ...T>
constexpr auto asm_fbld<zip<reg128>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fbld<ptr<reg128, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDF>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  fbstp ANY [M] 6  [] DF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fbstp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','b','s','t','p', str...>, hold<T...>> {
    static constexpr auto value = asm_fbstp<T...>;
};
template<typename ...T>
constexpr auto asm_fbstp<zip<reg128>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fbstp<ptr<reg128, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDF>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  fchs ANY [NONE]   [] E0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fchs = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','h','s', str...>, hold<T...>> {
    static constexpr auto value = asm_fchs<T...>;
};
template <>
constexpr auto asm_fchs<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xE0>>>::value;
//  fclex ANY [NONE]   [9B] E2 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fclex = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','l','e','x', str...>, hold<T...>> {
    static constexpr auto value = asm_fclex<T...>;
};
template <>
constexpr auto asm_fclex<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x9B>, byte_seq<0xDB>,  byte_seq<0xE2>>>::value;
//  fcmovb ANY [O]   [] C0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fcmovb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','m','o','v','b', str...>, hold<T...>> {
    static constexpr auto value = asm_fcmovb<T...>;
};
template<typename ...T>
constexpr auto asm_fcmovb<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDA>,  byte_seq<0xC0 + reg<reg_n<T...>::value>::value>>>::value;
//  fcmovbe ANY [O]   [] D0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fcmovbe = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','m','o','v','b','e', str...>, hold<T...>> {
    static constexpr auto value = asm_fcmovbe<T...>;
};
template<typename ...T>
constexpr auto asm_fcmovbe<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDA>,  byte_seq<0xD0 + reg<reg_n<T...>::value>::value>>>::value;
//  fcmove ANY [O]   [] C8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fcmove = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','m','o','v','e', str...>, hold<T...>> {
    static constexpr auto value = asm_fcmove<T...>;
};
template<typename ...T>
constexpr auto asm_fcmove<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDA>,  byte_seq<0xC8 + reg<reg_n<T...>::value>::value>>>::value;
//  fcmovnb ANY [O]   [] C0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fcmovnb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','m','o','v','n','b', str...>, hold<T...>> {
    static constexpr auto value = asm_fcmovnb<T...>;
};
template<typename ...T>
constexpr auto asm_fcmovnb<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDB>,  byte_seq<0xC0 + reg<reg_n<T...>::value>::value>>>::value;
//  fcmovnbe ANY [O]   [] D0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fcmovnbe = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','m','o','v','n','b','e', str...>, hold<T...>> {
    static constexpr auto value = asm_fcmovnbe<T...>;
};
template<typename ...T>
constexpr auto asm_fcmovnbe<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDB>,  byte_seq<0xD0 + reg<reg_n<T...>::value>::value>>>::value;
//  fcmovne ANY [O]   [] C8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fcmovne = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','m','o','v','n','e', str...>, hold<T...>> {
    static constexpr auto value = asm_fcmovne<T...>;
};
template<typename ...T>
constexpr auto asm_fcmovne<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDB>,  byte_seq<0xC8 + reg<reg_n<T...>::value>::value>>>::value;
//  fcmovnu ANY [O]   [] D8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fcmovnu = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','m','o','v','n','u', str...>, hold<T...>> {
    static constexpr auto value = asm_fcmovnu<T...>;
};
template<typename ...T>
constexpr auto asm_fcmovnu<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDB>,  byte_seq<0xD8 + reg<reg_n<T...>::value>::value>>>::value;
//  fcmovu ANY [O]   [] D8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fcmovu = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','m','o','v','u', str...>, hold<T...>> {
    static constexpr auto value = asm_fcmovu<T...>;
};
template<typename ...T>
constexpr auto asm_fcmovu<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDA>,  byte_seq<0xD8 + reg<reg_n<T...>::value>::value>>>::value;
//  fcom ANY [NONE]   [] D1 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fcom = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','o','m', str...>, hold<T...>> {
    static constexpr auto value = asm_fcom<T...>;
};
template <>
constexpr auto asm_fcom<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD8>,  byte_seq<0xD1>>>::value;
//  fcom ANY [M] 2  [] D8 

template<typename ...T>
constexpr auto asm_fcom<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fcom<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD8>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  fcom ANY [M] 2  [] DC 

template<typename ...T>
constexpr auto asm_fcom<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fcom<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDC>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  fcom ANY [O]   [] D0 

template<typename ...T>
constexpr auto asm_fcom<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD8>,  byte_seq<0xD0 + reg<reg_n<T...>::value>::value>>>::value;
//  fcomi ANY [O]   [] F0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fcomi = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','o','m','i', str...>, hold<T...>> {
    static constexpr auto value = asm_fcomi<T...>;
};
template<typename ...T>
constexpr auto asm_fcomi<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDB>,  byte_seq<0xF0 + reg<reg_n<T...>::value>::value>>>::value;
//  fcomip ANY [O]   [] F0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fcomip = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','o','m','i','p', str...>, hold<T...>> {
    static constexpr auto value = asm_fcomip<T...>;
};
template<typename ...T>
constexpr auto asm_fcomip<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDF>,  byte_seq<0xF0 + reg<reg_n<T...>::value>::value>>>::value;
//  fcomp ANY [NONE]   [] D9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fcomp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','o','m','p', str...>, hold<T...>> {
    static constexpr auto value = asm_fcomp<T...>;
};
template <>
constexpr auto asm_fcomp<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD8>,  byte_seq<0xD9>>>::value;
//  fcomp ANY [M] 3  [] D8 

template<typename ...T>
constexpr auto asm_fcomp<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fcomp<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD8>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  fcomp ANY [M] 3  [] DC 

template<typename ...T>
constexpr auto asm_fcomp<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fcomp<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDC>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  fcomp ANY [O]   [] D8 

template<typename ...T>
constexpr auto asm_fcomp<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD8>,  byte_seq<0xD8 + reg<reg_n<T...>::value>::value>>>::value;
//  fcompp ANY [NONE]   [] D9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fcompp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','o','m','p','p', str...>, hold<T...>> {
    static constexpr auto value = asm_fcompp<T...>;
};
template <>
constexpr auto asm_fcompp<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDE>,  byte_seq<0xD9>>>::value;
//  fcos ANY [NONE]   [] FF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fcos = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','c','o','s', str...>, hold<T...>> {
    static constexpr auto value = asm_fcos<T...>;
};
template <>
constexpr auto asm_fcos<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xFF>>>::value;
//  fdecstp ANY [NONE]   [] F6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fdecstp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','d','e','c','s','t','p', str...>, hold<T...>> {
    static constexpr auto value = asm_fdecstp<T...>;
};
template <>
constexpr auto asm_fdecstp<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xF6>>>::value;
//  fdiv ANY [M] 6  [] D8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fdiv = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','d','i','v', str...>, hold<T...>> {
    static constexpr auto value = asm_fdiv<T...>;
};
template<typename ...T>
constexpr auto asm_fdiv<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fdiv<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD8>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  fdiv ANY [M] 6  [] DC 

template<typename ...T>
constexpr auto asm_fdiv<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fdiv<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDC>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  fdiv ANY [O]   [] F0 

template<typename ...Y>
constexpr auto asm_fdiv<st<0>, zip<reg80>::with<Y...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD8>,  byte_seq<0xF0 + reg<reg_n<Y...>::value>::value>>>::value;
//  fdiv ANY [O]   [] F8 

template<typename ...T>
constexpr auto asm_fdiv<zip<reg80>::with<T...>, st<0>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDC>,  byte_seq<0xF8 + reg<reg_n<T...>::value>::value>>>::value;
//  fdivp ANY [NONE]   [] F9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fdivp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','d','i','v','p', str...>, hold<T...>> {
    static constexpr auto value = asm_fdivp<T...>;
};
template <>
constexpr auto asm_fdivp<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDE>,  byte_seq<0xF9>>>::value;
//  fdivp ANY [O]   [] F8 

template<typename ...T>
constexpr auto asm_fdivp<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDE>,  byte_seq<0xF8 + reg<reg_n<T...>::value>::value>>>::value;
//  fdivr ANY [M] 7  [] D8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fdivr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','d','i','v','r', str...>, hold<T...>> {
    static constexpr auto value = asm_fdivr<T...>;
};
template<typename ...T>
constexpr auto asm_fdivr<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fdivr<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD8>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  fdivr ANY [M] 7  [] DC 

template<typename ...T>
constexpr auto asm_fdivr<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fdivr<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDC>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  fdivr ANY [O]   [] F8 

template<typename ...Y>
constexpr auto asm_fdivr<st<0>, zip<reg80>::with<Y...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD8>,  byte_seq<0xF8 + reg<reg_n<Y...>::value>::value>>>::value;
//  fdivr ANY [O]   [] F0 

template<typename ...T>
constexpr auto asm_fdivr<zip<reg80>::with<T...>, st<0>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDC>,  byte_seq<0xF0 + reg<reg_n<T...>::value>::value>>>::value;
//  fdivrp ANY [NONE]   [] F1 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fdivrp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','d','i','v','r','p', str...>, hold<T...>> {
    static constexpr auto value = asm_fdivrp<T...>;
};
template <>
constexpr auto asm_fdivrp<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDE>,  byte_seq<0xF1>>>::value;
//  fdivrp ANY [O]   [] F0 

template<typename ...T>
constexpr auto asm_fdivrp<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDE>,  byte_seq<0xF0 + reg<reg_n<T...>::value>::value>>>::value;
//  femms ANY [NONE]   [] 0E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_femms = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','e','m','m','s', str...>, hold<T...>> {
    static constexpr auto value = asm_femms<T...>;
};
template <>
constexpr auto asm_femms<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x0E>>>::value;
//  ffree ANY [O]   [] C0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_ffree = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','f','r','e','e', str...>, hold<T...>> {
    static constexpr auto value = asm_ffree<T...>;
};
template<typename ...T>
constexpr auto asm_ffree<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDD>,  byte_seq<0xC0 + reg<reg_n<T...>::value>::value>>>::value;
//  fiadd ANY [M] 0  [] DE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fiadd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','a','d','d', str...>, hold<T...>> {
    static constexpr auto value = asm_fiadd<T...>;
};
template<typename ...T>
constexpr auto asm_fiadd<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fiadd<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDE>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  fiadd ANY [M] 0  [] DA 

template<typename ...T>
constexpr auto asm_fiadd<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fiadd<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDA>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  ficom ANY [M] 2  [] DE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_ficom = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','c','o','m', str...>, hold<T...>> {
    static constexpr auto value = asm_ficom<T...>;
};
template<typename ...T>
constexpr auto asm_ficom<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ficom<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDE>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  ficom ANY [M] 2  [] DA 

template<typename ...T>
constexpr auto asm_ficom<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ficom<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDA>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  ficomp ANY [M] 3  [] DE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_ficomp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','c','o','m','p', str...>, hold<T...>> {
    static constexpr auto value = asm_ficomp<T...>;
};
template<typename ...T>
constexpr auto asm_ficomp<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ficomp<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDE>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  ficomp ANY [M] 3  [] DA 

template<typename ...T>
constexpr auto asm_ficomp<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ficomp<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDA>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  fidiv ANY [M] 6  [] DE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fidiv = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','d','i','v', str...>, hold<T...>> {
    static constexpr auto value = asm_fidiv<T...>;
};
template<typename ...T>
constexpr auto asm_fidiv<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fidiv<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDE>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  fidiv ANY [M] 6  [] DA 

template<typename ...T>
constexpr auto asm_fidiv<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fidiv<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDA>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  fidivr ANY [M] 7  [] DE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fidivr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','d','i','v','r', str...>, hold<T...>> {
    static constexpr auto value = asm_fidivr<T...>;
};
template<typename ...T>
constexpr auto asm_fidivr<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fidivr<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDE>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  fidivr ANY [M] 7  [] DA 

template<typename ...T>
constexpr auto asm_fidivr<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fidivr<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDA>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  fild ANY [M] 0  [] DF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fild = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','l','d', str...>, hold<T...>> {
    static constexpr auto value = asm_fild<T...>;
};
template<typename ...T>
constexpr auto asm_fild<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fild<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDF>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  fild ANY [M] 0  [] DB 

template<typename ...T>
constexpr auto asm_fild<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDB>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fild<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDB>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  fild ANY [M] 5  [] DF 

template<typename ...T>
constexpr auto asm_fild<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fild<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDF>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  fimul ANY [M] 1  [] DE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fimul = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','m','u','l', str...>, hold<T...>> {
    static constexpr auto value = asm_fimul<T...>;
};
template<typename ...T>
constexpr auto asm_fimul<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fimul<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDE>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  fimul ANY [M] 1  [] DA 

template<typename ...T>
constexpr auto asm_fimul<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fimul<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDA>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  fincstp ANY [NONE]   [] F7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fincstp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','n','c','s','t','p', str...>, hold<T...>> {
    static constexpr auto value = asm_fincstp<T...>;
};
template <>
constexpr auto asm_fincstp<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xF7>>>::value;
//  finit ANY [NONE]   [9B] E3 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_finit = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','n','i','t', str...>, hold<T...>> {
    static constexpr auto value = asm_finit<T...>;
};
template <>
constexpr auto asm_finit<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x9B>, byte_seq<0xDB>,  byte_seq<0xE3>>>::value;
//  fist ANY [M] 2  [] DF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fist = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','s','t', str...>, hold<T...>> {
    static constexpr auto value = asm_fist<T...>;
};
template<typename ...T>
constexpr auto asm_fist<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fist<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDF>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  fist ANY [M] 2  [] DB 

template<typename ...T>
constexpr auto asm_fist<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDB>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fist<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDB>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  fistp ANY [M] 3  [] DF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fistp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','s','t','p', str...>, hold<T...>> {
    static constexpr auto value = asm_fistp<T...>;
};
template<typename ...T>
constexpr auto asm_fistp<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fistp<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDF>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  fistp ANY [M] 3  [] DB 

template<typename ...T>
constexpr auto asm_fistp<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDB>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fistp<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDB>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  fistp ANY [M] 7  [] DF 

template<typename ...T>
constexpr auto asm_fistp<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fistp<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDF>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  fisttp ANY [M] 1  [] DF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fisttp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','s','t','t','p', str...>, hold<T...>> {
    static constexpr auto value = asm_fisttp<T...>;
};
template<typename ...T>
constexpr auto asm_fisttp<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fisttp<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDF>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  fisttp ANY [M] 1  [] DB 

template<typename ...T>
constexpr auto asm_fisttp<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDB>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fisttp<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDB>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  fisttp ANY [M] 1  [] DD 

template<typename ...T>
constexpr auto asm_fisttp<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDD>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fisttp<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDD>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  fisub ANY [M] 4  [] DE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fisub = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','s','u','b', str...>, hold<T...>> {
    static constexpr auto value = asm_fisub<T...>;
};
template<typename ...T>
constexpr auto asm_fisub<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fisub<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDE>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  fisub ANY [M] 4  [] DA 

template<typename ...T>
constexpr auto asm_fisub<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fisub<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDA>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  fisubr ANY [M] 5  [] DE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fisubr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','i','s','u','b','r', str...>, hold<T...>> {
    static constexpr auto value = asm_fisubr<T...>;
};
template<typename ...T>
constexpr auto asm_fisubr<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fisubr<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDE>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  fisubr ANY [M] 5  [] DA 

template<typename ...T>
constexpr auto asm_fisubr<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fisubr<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDA>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  fld ANY [M] 0  [] D9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fld = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d', str...>, hold<T...>> {
    static constexpr auto value = asm_fld<T...>;
};
template<typename ...T>
constexpr auto asm_fld<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD9>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fld<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD9>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  fld ANY [M] 0  [] DD 

template<typename ...T>
constexpr auto asm_fld<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDD>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fld<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDD>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  fld ANY [M] 5  [] DB 

template<typename ...T>
constexpr auto asm_fld<zip<reg128>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDB>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fld<ptr<reg128, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDB>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  fld ANY [O]   [] C0 

template<typename ...T>
constexpr auto asm_fld<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xC0 + reg<reg_n<T...>::value>::value>>>::value;
//  fld1 ANY [NONE]   [] E8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fld1 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d','1', str...>, hold<T...>> {
    static constexpr auto value = asm_fld1<T...>;
};
template <>
constexpr auto asm_fld1<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xE8>>>::value;
//  fldcw ANY [M] 5  [] D9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fldcw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d','c','w', str...>, hold<T...>> {
    static constexpr auto value = asm_fldcw<T...>;
};
template<typename ...T>
constexpr auto asm_fldcw<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD9>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fldcw<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD9>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  fldenv ANY [M] 4  [] D9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fldenv = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d','e','n','v', str...>, hold<T...>> {
    static constexpr auto value = asm_fldenv<T...>;
};
template<typename ...T>
constexpr auto asm_fldenv<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD9>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  fldl2e ANY [NONE]   [] EA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fldl2e = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d','l','2','e', str...>, hold<T...>> {
    static constexpr auto value = asm_fldl2e<T...>;
};
template <>
constexpr auto asm_fldl2e<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xEA>>>::value;
//  fldl2t ANY [NONE]   [] E9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fldl2t = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d','l','2','t', str...>, hold<T...>> {
    static constexpr auto value = asm_fldl2t<T...>;
};
template <>
constexpr auto asm_fldl2t<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xE9>>>::value;
//  fldlg2 ANY [NONE]   [] EC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fldlg2 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d','l','g','2', str...>, hold<T...>> {
    static constexpr auto value = asm_fldlg2<T...>;
};
template <>
constexpr auto asm_fldlg2<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xEC>>>::value;
//  fldln2 ANY [NONE]   [] ED 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fldln2 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d','l','n','2', str...>, hold<T...>> {
    static constexpr auto value = asm_fldln2<T...>;
};
template <>
constexpr auto asm_fldln2<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xED>>>::value;
//  fldpi ANY [NONE]   [] EB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fldpi = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d','p','i', str...>, hold<T...>> {
    static constexpr auto value = asm_fldpi<T...>;
};
template <>
constexpr auto asm_fldpi<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xEB>>>::value;
//  fldz ANY [NONE]   [] EE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fldz = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','l','d','z', str...>, hold<T...>> {
    static constexpr auto value = asm_fldz<T...>;
};
template <>
constexpr auto asm_fldz<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xEE>>>::value;
//  fmul ANY [M] 1  [] D8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fmul = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','m','u','l', str...>, hold<T...>> {
    static constexpr auto value = asm_fmul<T...>;
};
template<typename ...T>
constexpr auto asm_fmul<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fmul<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD8>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  fmul ANY [M] 1  [] DC 

template<typename ...T>
constexpr auto asm_fmul<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fmul<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDC>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  fmul ANY [O]   [] C8 

template<typename ...Y>
constexpr auto asm_fmul<st<0>, zip<reg80>::with<Y...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD8>,  byte_seq<0xC8 + reg<reg_n<Y...>::value>::value>>>::value;
//  fmul ANY [O]   [] C8 

template<typename ...T>
constexpr auto asm_fmul<zip<reg80>::with<T...>, st<0>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDC>,  byte_seq<0xC8 + reg<reg_n<T...>::value>::value>>>::value;
//  fmulp ANY [NONE]   [] C9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fmulp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','m','u','l','p', str...>, hold<T...>> {
    static constexpr auto value = asm_fmulp<T...>;
};
template <>
constexpr auto asm_fmulp<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDE>,  byte_seq<0xC9>>>::value;
//  fmulp ANY [O]   [] C8 

template<typename ...T>
constexpr auto asm_fmulp<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDE>,  byte_seq<0xC8 + reg<reg_n<T...>::value>::value>>>::value;
//  fnclex ANY [NONE]   [] E2 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fnclex = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','n','c','l','e','x', str...>, hold<T...>> {
    static constexpr auto value = asm_fnclex<T...>;
};
template <>
constexpr auto asm_fnclex<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDB>,  byte_seq<0xE2>>>::value;
//  fninit ANY [NONE]   [] E3 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fninit = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','n','i','n','i','t', str...>, hold<T...>> {
    static constexpr auto value = asm_fninit<T...>;
};
template <>
constexpr auto asm_fninit<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDB>,  byte_seq<0xE3>>>::value;
//  fnop ANY [NONE]   [] D0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fnop = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','n','o','p', str...>, hold<T...>> {
    static constexpr auto value = asm_fnop<T...>;
};
template <>
constexpr auto asm_fnop<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xD0>>>::value;
//  fnsave ANY [M] 6  [] DD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fnsave = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','n','s','a','v','e', str...>, hold<T...>> {
    static constexpr auto value = asm_fnsave<T...>;
};
template<typename ...T>
constexpr auto asm_fnsave<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDD>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  fnstcw ANY [M] 7  [] D9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fnstcw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','n','s','t','c','w', str...>, hold<T...>> {
    static constexpr auto value = asm_fnstcw<T...>;
};
template<typename ...T>
constexpr auto asm_fnstcw<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD9>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fnstcw<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD9>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  fnstenv ANY [M] 6  [] D9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fnstenv = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','n','s','t','e','n','v', str...>, hold<T...>> {
    static constexpr auto value = asm_fnstenv<T...>;
};
template<typename ...T>
constexpr auto asm_fnstenv<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD9>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  fnstsw ANY [NONE]   [] E0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fnstsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','n','s','t','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_fnstsw<T...>;
};
template <>
constexpr auto asm_fnstsw<ax> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDF>,  byte_seq<0xE0>>>::value;
//  fnstsw ANY [M] 7  [] DD 

template<typename ...T>
constexpr auto asm_fnstsw<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDD>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fnstsw<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDD>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  fpatan ANY [NONE]   [F3] D9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fpatan = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','p','a','t','a','n', str...>, hold<T...>> {
    static constexpr auto value = asm_fpatan<T...>;
};
template <>
constexpr auto asm_fpatan<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>,  byte_seq<0xD9>>>::value;
//  fprem ANY [NONE]   [] F8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fprem = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','p','r','e','m', str...>, hold<T...>> {
    static constexpr auto value = asm_fprem<T...>;
};
template <>
constexpr auto asm_fprem<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xF8>>>::value;
//  fprem1 ANY [NONE]   [] F5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fprem1 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','p','r','e','m','1', str...>, hold<T...>> {
    static constexpr auto value = asm_fprem1<T...>;
};
template <>
constexpr auto asm_fprem1<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xF5>>>::value;
//  fptan ANY [NONE]   [F2] D9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fptan = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','p','t','a','n', str...>, hold<T...>> {
    static constexpr auto value = asm_fptan<T...>;
};
template <>
constexpr auto asm_fptan<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>,  byte_seq<0xD9>>>::value;
//  frndint ANY [NONE]   [] FC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_frndint = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','r','n','d','i','n','t', str...>, hold<T...>> {
    static constexpr auto value = asm_frndint<T...>;
};
template <>
constexpr auto asm_frndint<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xFC>>>::value;
//  frstor ANY [M] 4  [] DD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_frstor = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','r','s','t','o','r', str...>, hold<T...>> {
    static constexpr auto value = asm_frstor<T...>;
};
template<typename ...T>
constexpr auto asm_frstor<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDD>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  fsave ANY [M] 6  [9B] DD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fsave = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','a','v','e', str...>, hold<T...>> {
    static constexpr auto value = asm_fsave<T...>;
};
template<typename ...T>
constexpr auto asm_fsave<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x9B>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDD>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  fscale ANY [NONE]   [] FD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fscale = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','c','a','l','e', str...>, hold<T...>> {
    static constexpr auto value = asm_fscale<T...>;
};
template <>
constexpr auto asm_fscale<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xFD>>>::value;
//  fsin ANY [NONE]   [] FE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fsin = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','i','n', str...>, hold<T...>> {
    static constexpr auto value = asm_fsin<T...>;
};
template <>
constexpr auto asm_fsin<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xFE>>>::value;
//  fsincos ANY [NONE]   [] FB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fsincos = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','i','n','c','o','s', str...>, hold<T...>> {
    static constexpr auto value = asm_fsincos<T...>;
};
template <>
constexpr auto asm_fsincos<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xFB>>>::value;
//  fsqrt ANY [NONE]   [] FE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fsqrt = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','q','r','t', str...>, hold<T...>> {
    static constexpr auto value = asm_fsqrt<T...>;
};
template <>
constexpr auto asm_fsqrt<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xFE>>>::value;
//  fst ANY [M] 2  [] D9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fst = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','t', str...>, hold<T...>> {
    static constexpr auto value = asm_fst<T...>;
};
template<typename ...T>
constexpr auto asm_fst<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD9>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fst<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD9>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  fst ANY [M] 2  [] DD 

template<typename ...T>
constexpr auto asm_fst<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDD>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fst<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDD>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  fst ANY [O]   [] D0 

template<typename ...T>
constexpr auto asm_fst<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDD>,  byte_seq<0xD0 + reg<reg_n<T...>::value>::value>>>::value;
//  fstcw ANY [M] 7  [9B] D9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fstcw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','t','c','w', str...>, hold<T...>> {
    static constexpr auto value = asm_fstcw<T...>;
};
template<typename ...T>
constexpr auto asm_fstcw<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x9B>, typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD9>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fstcw<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x9B>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD9>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  fstenv ANY [M] 6  [9B] D9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fstenv = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','t','e','n','v', str...>, hold<T...>> {
    static constexpr auto value = asm_fstenv<T...>;
};
template<typename ...T>
constexpr auto asm_fstenv<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x9B>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD9>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  fstp ANY [M] 3  [] D9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fstp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','t','p', str...>, hold<T...>> {
    static constexpr auto value = asm_fstp<T...>;
};
template<typename ...T>
constexpr auto asm_fstp<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD9>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fstp<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD9>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  fstp ANY [M] 3  [] DD 

template<typename ...T>
constexpr auto asm_fstp<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDD>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fstp<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDD>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  fstp ANY [M] 7  [] DB 

template<typename ...T>
constexpr auto asm_fstp<zip<reg128>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDB>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fstp<ptr<reg128, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDB>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  fstp ANY [O]   [] D8 

template<typename ...T>
constexpr auto asm_fstp<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDD>,  byte_seq<0xD8 + reg<reg_n<T...>::value>::value>>>::value;
//  fstsw ANY [NONE]   [9B] E0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fstsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','t','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_fstsw<T...>;
};
template <>
constexpr auto asm_fstsw<ax> = seq_to_arr<expand_byte_seq_v<byte_seq<0x9B>, byte_seq<0xDF>,  byte_seq<0xE0>>>::value;
//  fstsw ANY [M] 7  [9B] DD 

template<typename ...T>
constexpr auto asm_fstsw<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x9B>, typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDD>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fstsw<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x9B>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDD>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  fsub ANY [M] 4  [] D8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fsub = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','u','b', str...>, hold<T...>> {
    static constexpr auto value = asm_fsub<T...>;
};
template<typename ...T>
constexpr auto asm_fsub<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fsub<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD8>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  fsub ANY [M] 4  [] DC 

template<typename ...T>
constexpr auto asm_fsub<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fsub<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDC>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  fsub ANY [O]   [] E0 

template<typename ...Y>
constexpr auto asm_fsub<st<0>, zip<reg80>::with<Y...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD8>,  byte_seq<0xE0 + reg<reg_n<Y...>::value>::value>>>::value;
//  fsub ANY [O]   [] E8 

template<typename ...T>
constexpr auto asm_fsub<zip<reg80>::with<T...>, st<0>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDC>,  byte_seq<0xE8 + reg<reg_n<T...>::value>::value>>>::value;
//  fsubp ANY [NONE]   [] E9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fsubp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','u','b','p', str...>, hold<T...>> {
    static constexpr auto value = asm_fsubp<T...>;
};
template <>
constexpr auto asm_fsubp<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDE>,  byte_seq<0xE9>>>::value;
//  fsubp ANY [O]   [] E8 

template<typename ...T>
constexpr auto asm_fsubp<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDE>,  byte_seq<0xE8 + reg<reg_n<T...>::value>::value>>>::value;
//  fsubr ANY [M] 5  [] D8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fsubr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','u','b','r', str...>, hold<T...>> {
    static constexpr auto value = asm_fsubr<T...>;
};
template<typename ...T>
constexpr auto asm_fsubr<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fsubr<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD8>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  fsubr ANY [M] 5  [] DC 

template<typename ...T>
constexpr auto asm_fsubr<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_fsubr<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xDC>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  fsubr ANY [O]   [] E8 

template<typename ...Y>
constexpr auto asm_fsubr<st<0>, zip<reg80>::with<Y...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD8>,  byte_seq<0xE8 + reg<reg_n<Y...>::value>::value>>>::value;
//  fsubr ANY [O]   [] E0 

template<typename ...T>
constexpr auto asm_fsubr<zip<reg80>::with<T...>, st<0>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDC>,  byte_seq<0xE0 + reg<reg_n<T...>::value>::value>>>::value;
//  fsubrp ANY [NONE]   [] E1 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fsubrp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','s','u','b','r','p', str...>, hold<T...>> {
    static constexpr auto value = asm_fsubrp<T...>;
};
template <>
constexpr auto asm_fsubrp<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDE>,  byte_seq<0xE1>>>::value;
//  fsubrp ANY [O]   [] E0 

template<typename ...T>
constexpr auto asm_fsubrp<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDE>,  byte_seq<0xE0 + reg<reg_n<T...>::value>::value>>>::value;
//  ftst ANY [NONE]   [] E4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_ftst = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','t','s','t', str...>, hold<T...>> {
    static constexpr auto value = asm_ftst<T...>;
};
template <>
constexpr auto asm_ftst<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xE4>>>::value;
//  fucom ANY [NONE]   [] E1 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fucom = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','u','c','o','m', str...>, hold<T...>> {
    static constexpr auto value = asm_fucom<T...>;
};
template <>
constexpr auto asm_fucom<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDD>,  byte_seq<0xE1>>>::value;
//  fucom ANY [O]   [] E0 

template<typename ...T>
constexpr auto asm_fucom<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDD>,  byte_seq<0xE0 + reg<reg_n<T...>::value>::value>>>::value;
//  fucomi ANY [O]   [] E8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fucomi = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','u','c','o','m','i', str...>, hold<T...>> {
    static constexpr auto value = asm_fucomi<T...>;
};
template<typename ...T>
constexpr auto asm_fucomi<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDB>,  byte_seq<0xE8 + reg<reg_n<T...>::value>::value>>>::value;
//  fucomip ANY [O]   [] E8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fucomip = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','u','c','o','m','i','p', str...>, hold<T...>> {
    static constexpr auto value = asm_fucomip<T...>;
};
template<typename ...T>
constexpr auto asm_fucomip<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDF>,  byte_seq<0xE8 + reg<reg_n<T...>::value>::value>>>::value;
//  fucomp ANY [NONE]   [] E9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fucomp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','u','c','o','m','p', str...>, hold<T...>> {
    static constexpr auto value = asm_fucomp<T...>;
};
template <>
constexpr auto asm_fucomp<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDD>,  byte_seq<0xE9>>>::value;
//  fucomp ANY [O]   [] E8 

template<typename ...T>
constexpr auto asm_fucomp<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDD>,  byte_seq<0xE8 + reg<reg_n<T...>::value>::value>>>::value;
//  fucompp ANY [NONE]   [] E9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fucompp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','u','c','o','m','p','p', str...>, hold<T...>> {
    static constexpr auto value = asm_fucompp<T...>;
};
template <>
constexpr auto asm_fucompp<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xDA>,  byte_seq<0xE9>>>::value;
//  fwait ANY [NONE]   [] 9B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fwait = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','w','a','i','t', str...>, hold<T...>> {
    static constexpr auto value = asm_fwait<T...>;
};
template <>
constexpr auto asm_fwait<> = seq_to_arr<expand_byte_seq_v< byte_seq<0x9B>>>::value;
//  fxam ANY [NONE]   [] E5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fxam = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','x','a','m', str...>, hold<T...>> {
    static constexpr auto value = asm_fxam<T...>;
};
template <>
constexpr auto asm_fxam<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xE5>>>::value;
//  fxch ANY [NONE]   [] C9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fxch = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','x','c','h', str...>, hold<T...>> {
    static constexpr auto value = asm_fxch<T...>;
};
template <>
constexpr auto asm_fxch<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xC9>>>::value;
//  fxch ANY [O]   [] C8 

template<typename ...T>
constexpr auto asm_fxch<zip<reg80>::with<T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xC8 + reg<reg_n<T...>::value>::value>>>::value;
//  fxrstor ANY [NONE] 1  [] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fxrstor = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','x','r','s','t','o','r', str...>, hold<T...>> {
    static constexpr auto value = asm_fxrstor<T...>;
};
template <typename... T>
constexpr auto asm_fxrstor<ptr<reg64, T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;
//  fxrstor64 X64 [NONE] 1  [] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fxrstor64 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','x','r','s','t','o','r','6','4', str...>, hold<T...>> {
    static constexpr auto value = asm_fxrstor64<T...>;
};
template <typename... T>
constexpr auto asm_fxrstor64<ptr<reg64, T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, 0, 0, 0>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;
//  fxsave ANY [NONE] 0  [] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fxsave = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','x','s','a','v','e', str...>, hold<T...>> {
    static constexpr auto value = asm_fxsave<T...>;
};
template <typename... T>
constexpr auto asm_fxsave<ptr<reg64, T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;
//  fxsave64 X64 [NONE] 0  [] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fxsave64 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','x','s','a','v','e','6','4', str...>, hold<T...>> {
    static constexpr auto value = asm_fxsave64<T...>;
};
template <typename... T>
constexpr auto asm_fxsave64<ptr<reg64, T...>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, 0, 0, 0>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;
//  fxtract ANY [NONE]   [] F4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fxtract = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','x','t','r','a','c','t', str...>, hold<T...>> {
    static constexpr auto value = asm_fxtract<T...>;
};
template <>
constexpr auto asm_fxtract<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xF4>>>::value;
//  fyl2x ANY [NONE]   [] F1 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fyl2x = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','y','l','2','x', str...>, hold<T...>> {
    static constexpr auto value = asm_fyl2x<T...>;
};
template <>
constexpr auto asm_fyl2x<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xF1>>>::value;
//  fyl2xp1 ANY [NONE]   [] F9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_fyl2xp1 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'f','y','l','2','x','p','1', str...>, hold<T...>> {
    static constexpr auto value = asm_fyl2xp1<T...>;
};
template <>
constexpr auto asm_fyl2xp1<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xD9>,  byte_seq<0xF9>>>::value;
//  getsec ANY [NONE]   [] 37 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_getsec = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'g','e','t','s','e','c', str...>, hold<T...>> {
    static constexpr auto value = asm_getsec<T...>;
};
template <>
constexpr auto asm_getsec<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x37>>>::value;
//  gf2p8affineinvqb ANY [RMI] r  [66] CF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_gf2p8affineinvqb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'g','f','2','p','8','a','f','f','i','n','e','i','n','v','q','b', str...>, hold<T...>> {
    static constexpr auto value = asm_gf2p8affineinvqb<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_gf2p8affineinvqb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xCF>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_gf2p8affineinvqb<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xCF>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  gf2p8affineqb ANY [RMI] r  [66] CE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_gf2p8affineqb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'g','f','2','p','8','a','f','f','i','n','e','q','b', str...>, hold<T...>> {
    static constexpr auto value = asm_gf2p8affineqb<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_gf2p8affineqb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xCE>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_gf2p8affineqb<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xCE>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  gf2p8mulb ANY [RM] r  [66] CF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_gf2p8mulb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'g','f','2','p','8','m','u','l','b', str...>, hold<T...>> {
    static constexpr auto value = asm_gf2p8mulb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_gf2p8mulb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xCF>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_gf2p8mulb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xCF>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  haddpd ANY [RM] r  [66] 7C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_haddpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'h','a','d','d','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_haddpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_haddpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x7C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_haddpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x7C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  haddps ANY [RM] r  [F2] 7C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_haddps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'h','a','d','d','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_haddps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_haddps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x7C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_haddps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x7C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  hlt ANY [NONE]   [] F4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_hlt = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'h','l','t', str...>, hold<T...>> {
    static constexpr auto value = asm_hlt<T...>;
};
template <>
constexpr auto asm_hlt<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xF4>>>::value;
//  hreset ANY [I] 0  [F3] F0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_hreset = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'h','r','e','s','e','t', str...>, hold<T...>> {
    static constexpr auto value = asm_hreset<T...>;
};
template <uint8_t T> 
constexpr auto asm_hreset<disp8<T>, eax> =
    seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x3A>,  byte_seq<0xF0>, typename disp8<T>::value>>::value;
//  hsubpd ANY [RM] r  [66] 7D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_hsubpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'h','s','u','b','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_hsubpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_hsubpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x7D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_hsubpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x7D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  hsubps ANY [RM] r  [F2] 7D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_hsubps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'h','s','u','b','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_hsubps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_hsubps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x7D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_hsubps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x7D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  idiv ANY [M] 7  [] F6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_idiv = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','d','i','v', str...>, hold<T...>> {
    static constexpr auto value = asm_idiv<T...>;
};
template<typename ...Y>
constexpr auto asm_idiv<zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<reg<7>>>::value>>::value;

template<typename ...Y>
constexpr auto asm_idiv<ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, typename mrm<Y...>::template value<hold<reg<7>>>>>::value;

//  idiv ANY [M] 7  [66] F7 

template<typename ...Z>
constexpr auto asm_idiv<zip<reg16>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<7>>>::value>>::value;

template<typename ...Z>
constexpr auto asm_idiv<ptr<reg16, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, typename mrm<Z...>::template value<hold<reg<7>>>>>::value;

//  idiv ANY [M] 7  [] F7 

template<typename ...Z>
constexpr auto asm_idiv<zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<7>>>::value>>::value;

template<typename ...Z>
constexpr auto asm_idiv<ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, typename mrm<Z...>::template value<hold<reg<7>>>>>::value;

//  idiv X64 [M] 7  [] F7 

template<typename ...Z>
constexpr auto asm_idiv<zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<7>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<7>>>::value>>::value;

template<typename ...Z>
constexpr auto asm_idiv<ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<7>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, typename mrm<Z...>::template value<hold<reg<7>>>>>::value;

//  imul ANY [M] 5  [] F6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_imul = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','m','u','l', str...>, hold<T...>> {
    static constexpr auto value = asm_imul<T...>;
};
template<typename ...Y>
constexpr auto asm_imul<zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<reg<5>>>::value>>::value;

template<typename ...Y>
constexpr auto asm_imul<ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, typename mrm<Y...>::template value<hold<reg<5>>>>>::value;

//  imul ANY [M] 5  [66] F7 

template<typename ...Z>
constexpr auto asm_imul<zip<reg16>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<5>>>::value>>::value;

template<typename ...Z>
constexpr auto asm_imul<ptr<reg16, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, typename mrm<Z...>::template value<hold<reg<5>>>>>::value;

//  imul ANY [M] 5  [] F7 

template<typename ...Z>
constexpr auto asm_imul<zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<5>>>::value>>::value;

template<typename ...Z>
constexpr auto asm_imul<ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, typename mrm<Z...>::template value<hold<reg<5>>>>>::value;

//  imul X64 [M] 5  [] F7 

template<typename ...Z>
constexpr auto asm_imul<zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<5>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<5>>>::value>>::value;

template<typename ...Z>
constexpr auto asm_imul<ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, typename mrm<Z...>::template value<hold<reg<5>>>>>::value;

//  imul ANY [RM] r  [66] AF 

template<typename ...T, typename ...Y>
constexpr auto asm_imul<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xAF>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_imul<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xAF>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  imul ANY [RM] r  [] AF 

template<typename ...T, typename ...Y>
constexpr auto asm_imul<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xAF>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_imul<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xAF>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  imul X64 [RM] r  [] AF 

template<typename ...T, typename ...Y>
constexpr auto asm_imul<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xAF>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_imul<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xAF>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  imul ANY [RMI] r  [66] 6B 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_imul<zip<reg16>::with<T...>, zip<reg16>::with<Y...>, ib<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6B>, typename modrm<hold<Y...>, hold<T...>>::value, typename ib<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_imul<zip<reg16>::with<T...>, ptr<reg16, Y...>, ib<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6B>, typename mrm<Y...>::template value<hold<T...>>, typename ib<Z>::value>>::value;

//  imul ANY [RMI] r  [] 6B 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_imul<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, ib<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6B>, typename modrm<hold<Y...>, hold<T...>>::value, typename ib<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_imul<zip<reg32>::with<T...>, ptr<reg32, Y...>, ib<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6B>, typename mrm<Y...>::template value<hold<T...>>, typename ib<Z>::value>>::value;

//  imul X64 [RMI] r  [] 6B 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_imul<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, ib<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6B>, typename modrm<hold<Y...>, hold<T...>>::value, typename ib<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_imul<zip<reg64>::with<T...>, ptr<reg64, Y...>, ib<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6B>, typename mrm<Y...>::template value<hold<T...>>, typename ib<Z>::value>>::value;

//  imul ANY [RMI] r  [66] 69 

template<typename ...T, typename ...Y, uint16_t Z>
constexpr auto asm_imul<zip<reg16>::with<T...>, zip<reg16>::with<Y...>, disp16<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x69>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp16<Z>::value>>::value;

template<typename ...T, typename ...Y, uint16_t Z>
constexpr auto asm_imul<zip<reg16>::with<T...>, ptr<reg16, Y...>, disp16<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x69>, typename mrm<Y...>::template value<hold<T...>>, typename disp16<Z>::value>>::value;

//  imul ANY [RMI] r  [] 69 

template<typename ...T, typename ...Y, uint32_t Z>
constexpr auto asm_imul<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, disp32<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x69>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp32<Z>::value>>::value;

template<typename ...T, typename ...Y, uint32_t Z>
constexpr auto asm_imul<zip<reg32>::with<T...>, ptr<reg32, Y...>, disp32<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x69>, typename mrm<Y...>::template value<hold<T...>>, typename disp32<Z>::value>>::value;

//  imul X64 [RMI] r  [] 69 

template<typename ...T, typename ...Y, uint32_t Z>
constexpr auto asm_imul<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, id<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x69>, typename modrm<hold<Y...>, hold<T...>>::value, typename id<Z>::value>>::value;

template<typename ...T, typename ...Y, uint32_t Z>
constexpr auto asm_imul<zip<reg64>::with<T...>, ptr<reg64, Y...>, id<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x69>, typename mrm<Y...>::template value<hold<T...>>, typename id<Z>::value>>::value;

//  in ANY [I]   [] E4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_in = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n', str...>, hold<T...>> {
    static constexpr auto value = asm_in<T...>;
};
template <uint8_t Y> 
constexpr auto asm_in<al, disp8<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0xE4>, typename disp8<Y>::value>>::value;
//  in ANY [I]   [66] E5 

template <uint8_t Y> 
constexpr auto asm_in<ax, disp8<Y>> =
    seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0xE5>, typename disp8<Y>::value>>::value;
//  in ANY [I]   [] E5 

template <uint8_t Y> 
constexpr auto asm_in<eax, disp8<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0xE5>, typename disp8<Y>::value>>::value;
//  inc X86 [O]   [66] 40 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_inc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','c', str...>, hold<T...>> {
    static constexpr auto value = asm_inc<T...>;
};
//  inc X86 [O]   [] 40 

//  inc ANY [M] 0  [] FE 

template<typename ...T>
constexpr auto asm_inc<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFE>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_inc<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFE>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  inc ANY [M] 0  [66] FF 

template<typename ...T>
constexpr auto asm_inc<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_inc<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  inc ANY [M] 0  [] FF 

template<typename ...T>
constexpr auto asm_inc<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_inc<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  inc X64 [M] 0  [] FF 

template<typename ...T>
constexpr auto asm_inc<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_inc<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  incsspd ANY [M] 5  [F3] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_incsspd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','c','s','s','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_incsspd<T...>;
};
template<typename ...T>
constexpr auto asm_incsspd<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

//  incsspq X64 [M] 5  [F3] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_incsspq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','c','s','s','p','q', str...>, hold<T...>> {
    static constexpr auto value = asm_incsspq<T...>;
};
template<typename ...T>
constexpr auto asm_incsspq<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

//  insb ANY [NONE]   [] 6C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_insb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_insb<T...>;
};
template <>
constexpr auto asm_insb<zdi, dx> = seq_to_arr<expand_byte_seq_v< byte_seq<0x6C>>>::value;
//  insd ANY [NONE]   [] 6D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_insd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_insd<T...>;
};
template <>
constexpr auto asm_insd<zdi, dx> = seq_to_arr<expand_byte_seq_v< byte_seq<0x6D>>>::value;
//  insertps ANY [RMI] r  [66] 21 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_insertps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','s','e','r','t','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_insertps<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_insertps<zip<reg128>::with<T...>, zip<reg32>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x21>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_insertps<zip<reg128>::with<T...>, ptr<reg32, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x21>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  insertq ANY [RM] r  [F2] 79 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_insertq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','s','e','r','t','q', str...>, hold<T...>> {
    static constexpr auto value = asm_insertq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_insertq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x79>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  insertq ANY [RMII] r  [F2] 78 

template<typename ...T, typename ...Y, uint8_t Z, uint8_t O>
constexpr auto asm_insertq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x78>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value, typename disp8<O>::value>>::value;

//  insw ANY [NONE]   [66] 6D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_insw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_insw<T...>;
};
template <>
constexpr auto asm_insw<zdi, dx> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0x6D>>>::value;
//  int ANY [I]   [] CD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_int = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','t', str...>, hold<T...>> {
    static constexpr auto value = asm_int<T...>;
};
template <uint8_t T> 
constexpr auto asm_int<disp8<T>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0xCD>, typename disp8<T>::value>>::value;
//  int3 ANY [NONE]   [] CC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_int3 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','t','3', str...>, hold<T...>> {
    static constexpr auto value = asm_int3<T...>;
};
template <>
constexpr auto asm_int3<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xCC>>>::value;
//  into X86 [NONE]   [] CE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_into = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','t','o', str...>, hold<T...>> {
    static constexpr auto value = asm_into<T...>;
};
template <>
constexpr auto asm_into<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xCE>>>::value;
//  invd ANY [NONE]   [] 08 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_invd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','v','d', str...>, hold<T...>> {
    static constexpr auto value = asm_invd<T...>;
};
template <>
constexpr auto asm_invd<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x08>>>::value;
//  invept X86 [RM] r  [66] 80 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_invept = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','v','e','p','t', str...>, hold<T...>> {
    static constexpr auto value = asm_invept<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_invept<zip<reg32>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x80>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_invept<zip<reg32>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x80>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  invept X64 [RM] r  [66] 80 

template<typename ...T, typename ...Y>
constexpr auto asm_invept<zip<reg64>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x80>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_invept<zip<reg64>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x80>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  invlpg ANY [M] 7  [] 01 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_invlpg = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','v','l','p','g', str...>, hold<T...>> {
    static constexpr auto value = asm_invlpg<T...>;
};
template<typename ...T>
constexpr auto asm_invlpg<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  invlpga X86 [NONE]   [] DF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_invlpga = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','v','l','p','g','a', str...>, hold<T...>> {
    static constexpr auto value = asm_invlpga<T...>;
};
template <>
constexpr auto asm_invlpga<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xDF>>>::value;
//  invpcid X86 [RM] r  [66] 82 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_invpcid = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','v','p','c','i','d', str...>, hold<T...>> {
    static constexpr auto value = asm_invpcid<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_invpcid<zip<reg32>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x82>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_invpcid<zip<reg32>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x82>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  invpcid X64 [RM] r  [66] 82 

template<typename ...T, typename ...Y>
constexpr auto asm_invpcid<zip<reg64>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x82>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_invpcid<zip<reg64>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x82>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  invvpid X86 [RM] r  [66] 81 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_invvpid = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','n','v','v','p','i','d', str...>, hold<T...>> {
    static constexpr auto value = asm_invvpid<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_invvpid<zip<reg32>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x81>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_invvpid<zip<reg32>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x81>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  invvpid X64 [RM] r  [66] 81 

template<typename ...T, typename ...Y>
constexpr auto asm_invvpid<zip<reg64>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x81>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_invvpid<zip<reg64>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x81>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  iret ANY [NONE]   [66] CF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_iret = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','r','e','t', str...>, hold<T...>> {
    static constexpr auto value = asm_iret<T...>;
};
template <>
constexpr auto asm_iret<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0xCF>>>::value;
//  iretd ANY [NONE]   [] CF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_iretd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','r','e','t','d', str...>, hold<T...>> {
    static constexpr auto value = asm_iretd<T...>;
};
template <>
constexpr auto asm_iretd<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xCF>>>::value;
//  iretq X64 [NONE]   [] CF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_iretq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'i','r','e','t','q', str...>, hold<T...>> {
    static constexpr auto value = asm_iretq<T...>;
};
template <>
constexpr auto asm_iretq<> = seq_to_arr<expand_byte_seq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0xCF>>>::value;
//  ja ANY [D]   [] 77 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_ja = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','a', str...>, hold<T...>> {
    static constexpr auto value = asm_ja<T...>;
};
template<uint8_t N>
constexpr auto asm_ja<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x77>, typename rel8<N>::value>>::value;
//  ja X86 [D]   [66] 87 

template<uint16_t N>
constexpr auto asm_ja<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x87>, typename rel16<N>::value>>::value;
//  ja ANY [D]   [] 87 

template<uint32_t N>
constexpr auto asm_ja<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x87>, typename rel32<N>::value>>::value;
//  jae ANY [D]   [] 73 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jae = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','a','e', str...>, hold<T...>> {
    static constexpr auto value = asm_jae<T...>;
};
template<uint8_t N>
constexpr auto asm_jae<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x73>, typename rel8<N>::value>>::value;
//  jae X86 [D]   [66] 83 

template<uint16_t N>
constexpr auto asm_jae<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x83>, typename rel16<N>::value>>::value;
//  jae ANY [D]   [] 83 

template<uint32_t N>
constexpr auto asm_jae<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x83>, typename rel32<N>::value>>::value;
//  jb ANY [D]   [] 72 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','b', str...>, hold<T...>> {
    static constexpr auto value = asm_jb<T...>;
};
template<uint8_t N>
constexpr auto asm_jb<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x72>, typename rel8<N>::value>>::value;
//  jb X86 [D]   [66] 82 

template<uint16_t N>
constexpr auto asm_jb<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x82>, typename rel16<N>::value>>::value;
//  jb ANY [D]   [] 82 

template<uint32_t N>
constexpr auto asm_jb<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x82>, typename rel32<N>::value>>::value;
//  jbe ANY [D]   [] 76 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jbe = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','b','e', str...>, hold<T...>> {
    static constexpr auto value = asm_jbe<T...>;
};
template<uint8_t N>
constexpr auto asm_jbe<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x76>, typename rel8<N>::value>>::value;
//  jbe X86 [D]   [66] 86 

template<uint16_t N>
constexpr auto asm_jbe<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x86>, typename rel16<N>::value>>::value;
//  jbe ANY [D]   [] 86 

template<uint32_t N>
constexpr auto asm_jbe<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x86>, typename rel32<N>::value>>::value;
//  jc ANY [D]   [] 72 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','c', str...>, hold<T...>> {
    static constexpr auto value = asm_jc<T...>;
};
template<uint8_t N>
constexpr auto asm_jc<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x72>, typename rel8<N>::value>>::value;
//  jc X86 [D]   [66] 82 

template<uint16_t N>
constexpr auto asm_jc<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x82>, typename rel16<N>::value>>::value;
//  jc ANY [D]   [] 82 

template<uint32_t N>
constexpr auto asm_jc<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x82>, typename rel32<N>::value>>::value;
//  je ANY [D]   [] 74 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_je = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','e', str...>, hold<T...>> {
    static constexpr auto value = asm_je<T...>;
};
template<uint8_t N>
constexpr auto asm_je<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x74>, typename rel8<N>::value>>::value;
//  je X86 [D]   [66] 84 

template<uint16_t N>
constexpr auto asm_je<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x84>, typename rel16<N>::value>>::value;
//  je ANY [D]   [] 84 

template<uint32_t N>
constexpr auto asm_je<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x84>, typename rel32<N>::value>>::value;
//  jecxz X86 [D]   [] E3 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jecxz = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','e','c','x','z', str...>, hold<T...>> {
    static constexpr auto value = asm_jecxz<T...>;
};
template<uint8_t N>
constexpr auto asm_jecxz<rel8<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x67>,  byte_seq<0xE3>, typename rel8<N>::value>>::value;
//  jg ANY [D]   [] 7F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jg = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','g', str...>, hold<T...>> {
    static constexpr auto value = asm_jg<T...>;
};
template<uint8_t N>
constexpr auto asm_jg<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x7F>, typename rel8<N>::value>>::value;
//  jg X86 [D]   [66] 8F 

template<uint16_t N>
constexpr auto asm_jg<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x8F>, typename rel16<N>::value>>::value;
//  jg ANY [D]   [] 8F 

template<uint32_t N>
constexpr auto asm_jg<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x8F>, typename rel32<N>::value>>::value;
//  jge ANY [D]   [] 7D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jge = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','g','e', str...>, hold<T...>> {
    static constexpr auto value = asm_jge<T...>;
};
template<uint8_t N>
constexpr auto asm_jge<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x7D>, typename rel8<N>::value>>::value;
//  jge X86 [D]   [66] 8D 

template<uint16_t N>
constexpr auto asm_jge<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x8D>, typename rel16<N>::value>>::value;
//  jge ANY [D]   [] 8D 

template<uint32_t N>
constexpr auto asm_jge<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x8D>, typename rel32<N>::value>>::value;
//  jl ANY [D]   [] 7C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jl = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','l', str...>, hold<T...>> {
    static constexpr auto value = asm_jl<T...>;
};
template<uint8_t N>
constexpr auto asm_jl<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x7C>, typename rel8<N>::value>>::value;
//  jl X86 [D]   [66] 8C 

template<uint16_t N>
constexpr auto asm_jl<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x8C>, typename rel16<N>::value>>::value;
//  jl ANY [D]   [] 8C 

template<uint32_t N>
constexpr auto asm_jl<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x8C>, typename rel32<N>::value>>::value;
//  jle ANY [D]   [] 7E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jle = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','l','e', str...>, hold<T...>> {
    static constexpr auto value = asm_jle<T...>;
};
template<uint8_t N>
constexpr auto asm_jle<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x7E>, typename rel8<N>::value>>::value;
//  jle X86 [D]   [66] 8E 

template<uint16_t N>
constexpr auto asm_jle<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x8E>, typename rel16<N>::value>>::value;
//  jle ANY [D]   [] 8E 

template<uint32_t N>
constexpr auto asm_jle<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x8E>, typename rel32<N>::value>>::value;
//  jmp ANY [D]   [] EB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jmp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','m','p', str...>, hold<T...>> {
    static constexpr auto value = asm_jmp<T...>;
};
template<uint8_t N>
constexpr auto asm_jmp<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0xEB>, typename rel8<N>::value>>::value;
//  jmp X86 [D]   [66] E9 

template<uint16_t N>
constexpr auto asm_jmp<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0xE9>, typename rel16<N>::value>>::value;
//  jmp ANY [D]   [] E9 

template<uint32_t N>
constexpr auto asm_jmp<rel32<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0xE9>, typename rel32<N>::value>>::value;
//  jmp X86 [D] 4  [] FF 

template<typename ...T>
constexpr auto asm_jmp<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_jmp<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  jmp X64 [D] 4  [] FF 

template<typename ...T>
constexpr auto asm_jmp<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_jmp<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  jna ANY [D]   [] 76 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jna = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','a', str...>, hold<T...>> {
    static constexpr auto value = asm_jna<T...>;
};
template<uint8_t N>
constexpr auto asm_jna<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x76>, typename rel8<N>::value>>::value;
//  jna X86 [D]   [66] 86 

template<uint16_t N>
constexpr auto asm_jna<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x86>, typename rel16<N>::value>>::value;
//  jna ANY [D]   [] 86 

template<uint32_t N>
constexpr auto asm_jna<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x86>, typename rel32<N>::value>>::value;
//  jnae ANY [D]   [] 72 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jnae = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','a','e', str...>, hold<T...>> {
    static constexpr auto value = asm_jnae<T...>;
};
template<uint8_t N>
constexpr auto asm_jnae<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x72>, typename rel8<N>::value>>::value;
//  jnae X86 [D]   [66] 82 

template<uint16_t N>
constexpr auto asm_jnae<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x82>, typename rel16<N>::value>>::value;
//  jnae ANY [D]   [] 82 

template<uint32_t N>
constexpr auto asm_jnae<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x82>, typename rel32<N>::value>>::value;
//  jnb ANY [D]   [] 73 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jnb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','b', str...>, hold<T...>> {
    static constexpr auto value = asm_jnb<T...>;
};
template<uint8_t N>
constexpr auto asm_jnb<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x73>, typename rel8<N>::value>>::value;
//  jnb X86 [D]   [66] 83 

template<uint16_t N>
constexpr auto asm_jnb<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x83>, typename rel16<N>::value>>::value;
//  jnb ANY [D]   [] 83 

template<uint32_t N>
constexpr auto asm_jnb<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x83>, typename rel32<N>::value>>::value;
//  jnbe ANY [D]   [] 77 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jnbe = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','b','e', str...>, hold<T...>> {
    static constexpr auto value = asm_jnbe<T...>;
};
template<uint8_t N>
constexpr auto asm_jnbe<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x77>, typename rel8<N>::value>>::value;
//  jnbe X86 [D]   [66] 87 

template<uint16_t N>
constexpr auto asm_jnbe<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x87>, typename rel16<N>::value>>::value;
//  jnbe ANY [D]   [] 87 

template<uint32_t N>
constexpr auto asm_jnbe<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x87>, typename rel32<N>::value>>::value;
//  jnc ANY [D]   [] 73 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jnc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','c', str...>, hold<T...>> {
    static constexpr auto value = asm_jnc<T...>;
};
template<uint8_t N>
constexpr auto asm_jnc<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x73>, typename rel8<N>::value>>::value;
//  jnc X86 [D]   [66] 83 

template<uint16_t N>
constexpr auto asm_jnc<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x83>, typename rel16<N>::value>>::value;
//  jnc ANY [D]   [] 83 

template<uint32_t N>
constexpr auto asm_jnc<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x83>, typename rel32<N>::value>>::value;
//  jne ANY [D]   [] 75 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jne = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','e', str...>, hold<T...>> {
    static constexpr auto value = asm_jne<T...>;
};
template<uint8_t N>
constexpr auto asm_jne<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x75>, typename rel8<N>::value>>::value;
//  jne X86 [D]   [66] 85 

template<uint16_t N>
constexpr auto asm_jne<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x85>, typename rel16<N>::value>>::value;
//  jne ANY [D]   [] 85 

template<uint32_t N>
constexpr auto asm_jne<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x85>, typename rel32<N>::value>>::value;
//  jng ANY [D]   [] 7E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jng = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','g', str...>, hold<T...>> {
    static constexpr auto value = asm_jng<T...>;
};
template<uint8_t N>
constexpr auto asm_jng<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x7E>, typename rel8<N>::value>>::value;
//  jng X86 [D]   [66] 8E 

template<uint16_t N>
constexpr auto asm_jng<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x8E>, typename rel16<N>::value>>::value;
//  jng ANY [D]   [] 8E 

template<uint32_t N>
constexpr auto asm_jng<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x8E>, typename rel32<N>::value>>::value;
//  jnge ANY [D]   [] 7C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jnge = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','g','e', str...>, hold<T...>> {
    static constexpr auto value = asm_jnge<T...>;
};
template<uint8_t N>
constexpr auto asm_jnge<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x7C>, typename rel8<N>::value>>::value;
//  jnge X86 [D]   [66] 8C 

template<uint16_t N>
constexpr auto asm_jnge<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x8C>, typename rel16<N>::value>>::value;
//  jnge ANY [D]   [] 8C 

template<uint32_t N>
constexpr auto asm_jnge<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x8C>, typename rel32<N>::value>>::value;
//  jnl ANY [D]   [] 7D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jnl = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','l', str...>, hold<T...>> {
    static constexpr auto value = asm_jnl<T...>;
};
template<uint8_t N>
constexpr auto asm_jnl<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x7D>, typename rel8<N>::value>>::value;
//  jnl X86 [D]   [66] 8D 

template<uint16_t N>
constexpr auto asm_jnl<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x8D>, typename rel16<N>::value>>::value;
//  jnl ANY [D]   [] 8D 

template<uint32_t N>
constexpr auto asm_jnl<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x8D>, typename rel32<N>::value>>::value;
//  jnle ANY [D]   [] 7F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jnle = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','l','e', str...>, hold<T...>> {
    static constexpr auto value = asm_jnle<T...>;
};
template<uint8_t N>
constexpr auto asm_jnle<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x7F>, typename rel8<N>::value>>::value;
//  jnle X86 [D]   [66] 8F 

template<uint16_t N>
constexpr auto asm_jnle<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x8F>, typename rel16<N>::value>>::value;
//  jnle ANY [D]   [] 8F 

template<uint32_t N>
constexpr auto asm_jnle<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x8F>, typename rel32<N>::value>>::value;
//  jno ANY [D]   [] 71 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jno = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','o', str...>, hold<T...>> {
    static constexpr auto value = asm_jno<T...>;
};
template<uint8_t N>
constexpr auto asm_jno<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x71>, typename rel8<N>::value>>::value;
//  jno X86 [D]   [66] 81 

template<uint16_t N>
constexpr auto asm_jno<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x81>, typename rel16<N>::value>>::value;
//  jno ANY [D]   [] 81 

template<uint32_t N>
constexpr auto asm_jno<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x81>, typename rel32<N>::value>>::value;
//  jnp ANY [D]   [] 7B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jnp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','p', str...>, hold<T...>> {
    static constexpr auto value = asm_jnp<T...>;
};
template<uint8_t N>
constexpr auto asm_jnp<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x7B>, typename rel8<N>::value>>::value;
//  jnp X86 [D]   [66] 8B 

template<uint16_t N>
constexpr auto asm_jnp<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x8B>, typename rel16<N>::value>>::value;
//  jnp ANY [D]   [] 8B 

template<uint32_t N>
constexpr auto asm_jnp<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x8B>, typename rel32<N>::value>>::value;
//  jns ANY [D]   [] 79 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jns = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','s', str...>, hold<T...>> {
    static constexpr auto value = asm_jns<T...>;
};
template<uint8_t N>
constexpr auto asm_jns<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x79>, typename rel8<N>::value>>::value;
//  jns X86 [D]   [66] 89 

template<uint16_t N>
constexpr auto asm_jns<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x89>, typename rel16<N>::value>>::value;
//  jns ANY [D]   [] 89 

template<uint32_t N>
constexpr auto asm_jns<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x89>, typename rel32<N>::value>>::value;
//  jnz ANY [D]   [] 75 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jnz = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','n','z', str...>, hold<T...>> {
    static constexpr auto value = asm_jnz<T...>;
};
template<uint8_t N>
constexpr auto asm_jnz<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x75>, typename rel8<N>::value>>::value;
//  jnz X86 [D]   [66] 85 

template<uint16_t N>
constexpr auto asm_jnz<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x85>, typename rel16<N>::value>>::value;
//  jnz ANY [D]   [] 85 

template<uint32_t N>
constexpr auto asm_jnz<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x85>, typename rel32<N>::value>>::value;
//  jo ANY [D]   [] 70 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jo = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','o', str...>, hold<T...>> {
    static constexpr auto value = asm_jo<T...>;
};
template<uint8_t N>
constexpr auto asm_jo<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x70>, typename rel8<N>::value>>::value;
//  jo X86 [D]   [66] 80 

template<uint16_t N>
constexpr auto asm_jo<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x80>, typename rel16<N>::value>>::value;
//  jo ANY [D]   [] 80 

template<uint32_t N>
constexpr auto asm_jo<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x80>, typename rel32<N>::value>>::value;
//  jp ANY [D]   [] 7A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','p', str...>, hold<T...>> {
    static constexpr auto value = asm_jp<T...>;
};
template<uint8_t N>
constexpr auto asm_jp<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x7A>, typename rel8<N>::value>>::value;
//  jp X86 [D]   [66] 8A 

template<uint16_t N>
constexpr auto asm_jp<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x8A>, typename rel16<N>::value>>::value;
//  jp ANY [D]   [] 8A 

template<uint32_t N>
constexpr auto asm_jp<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x8A>, typename rel32<N>::value>>::value;
//  jpe ANY [D]   [] 7A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jpe = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','p','e', str...>, hold<T...>> {
    static constexpr auto value = asm_jpe<T...>;
};
template<uint8_t N>
constexpr auto asm_jpe<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x7A>, typename rel8<N>::value>>::value;
//  jpe X86 [D]   [66] 8A 

template<uint16_t N>
constexpr auto asm_jpe<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x8A>, typename rel16<N>::value>>::value;
//  jpe ANY [D]   [] 8A 

template<uint32_t N>
constexpr auto asm_jpe<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x8A>, typename rel32<N>::value>>::value;
//  jpo ANY [D]   [] 7B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jpo = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','p','o', str...>, hold<T...>> {
    static constexpr auto value = asm_jpo<T...>;
};
template<uint8_t N>
constexpr auto asm_jpo<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x7B>, typename rel8<N>::value>>::value;
//  jpo X86 [D]   [66] 8B 

template<uint16_t N>
constexpr auto asm_jpo<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x8B>, typename rel16<N>::value>>::value;
//  jpo ANY [D]   [] 8B 

template<uint32_t N>
constexpr auto asm_jpo<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x8B>, typename rel32<N>::value>>::value;
//  js ANY [D]   [] 78 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_js = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','s', str...>, hold<T...>> {
    static constexpr auto value = asm_js<T...>;
};
template<uint8_t N>
constexpr auto asm_js<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x78>, typename rel8<N>::value>>::value;
//  js X86 [D]   [66] 88 

template<uint16_t N>
constexpr auto asm_js<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x88>, typename rel16<N>::value>>::value;
//  js ANY [D]   [] 88 

template<uint32_t N>
constexpr auto asm_js<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x88>, typename rel32<N>::value>>::value;
//  jz ANY [D]   [] 74 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_jz = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'j','z', str...>, hold<T...>> {
    static constexpr auto value = asm_jz<T...>;
};
template<uint8_t N>
constexpr auto asm_jz<rel8<N>> = seq_to_arr<expand_byte_seq_v< byte_seq<0x74>, typename rel8<N>::value>>::value;
//  jz X86 [D]   [66] 84 

template<uint16_t N>
constexpr auto asm_jz<rel16<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>,  byte_seq<0x84>, typename rel16<N>::value>>::value;
//  jz ANY [D]   [] 84 

template<uint32_t N>
constexpr auto asm_jz<rel32<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x84>, typename rel32<N>::value>>::value;
//  lahf ANY [NONE]   [] 9F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lahf = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','a','h','f', str...>, hold<T...>> {
    static constexpr auto value = asm_lahf<T...>;
};
template <>
constexpr auto asm_lahf<> = seq_to_arr<expand_byte_seq_v< byte_seq<0x9F>>>::value;
//  lar ANY [RM] r  [66] 02 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lar = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','a','r', str...>, hold<T...>> {
    static constexpr auto value = asm_lar<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_lar<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x02>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lar<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x02>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lar ANY [RM] r  [] 02 

template<typename ...T, typename ...Y>
constexpr auto asm_lar<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x02>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lar<zip<reg32>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x02>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lcall X86 [II]   [66] 9A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lcall = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','c','a','l','l', str...>, hold<T...>> {
    static constexpr auto value = asm_lcall<T...>;
};
template <uint16_t T, uint16_t Y> 
constexpr auto asm_lcall<disp16<T>, disp16<Y>> =
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0x9A>, typename disp16<T>::value, typename disp16<Y>::value>>::value;
//  lcall X86 [II]   [] 9A 

template <uint16_t T, uint32_t Y> 
constexpr auto asm_lcall<disp16<T>, disp32<Y>> =
  seq_to_arr<expand_byte_seq_v< byte_seq<0x9A>, typename disp16<T>::value, typename disp32<Y>::value>>::value;
//  lcall ANY [M] 3  [66] FF 

template<typename ...T>
constexpr auto asm_lcall<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_lcall<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  lcall ANY [M] 3  [] FF 

template<typename ...T>
constexpr auto asm_lcall<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_lcall<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  lcall X64 [M] 3  [] FF 

template<typename ...T>
constexpr auto asm_lcall<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_lcall<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  lddqu ANY [RM] r  [F2] F0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lddqu = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','d','d','q','u', str...>, hold<T...>> {
    static constexpr auto value = asm_lddqu<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_lddqu<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lddqu<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF0>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  ldmxcsr ANY [M] 2  [] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_ldmxcsr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','d','m','x','c','s','r', str...>, hold<T...>> {
    static constexpr auto value = asm_ldmxcsr<T...>;
};
template<typename ...T>
constexpr auto asm_ldmxcsr<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ldmxcsr<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  lds X86 [RM] r  [66] C5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lds = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','d','s', str...>, hold<T...>> {
    static constexpr auto value = asm_lds<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_lds<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC5>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lds<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC5>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lds X86 [RM] r  [] C5 

template<typename ...T, typename ...Y>
constexpr auto asm_lds<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC5>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lds<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC5>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  ldtilecfg X64 [M] 0  [] 49 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_ldtilecfg = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','d','t','i','l','e','c','f','g', str...>, hold<T...>> {
    static constexpr auto value = asm_ldtilecfg<T...>;
};
template<typename ...T>
constexpr auto asm_ldtilecfg<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<0>>>>, disp8<is_ext_v<hold<T...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x49>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ldtilecfg<ptr<reg512, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<reg<0>>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x49>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  lea ANY [RM] r  [] 8D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lea = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','e','a', str...>, hold<T...>> {
    static constexpr auto value = asm_lea<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_lea<zip<reg16>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x67>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lea<zip<reg16>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<byte_seq<0x67>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lea ANY [RM] r  [] 8D 

template<typename ...T, typename ...Y>
constexpr auto asm_lea<zip<reg32>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lea<zip<reg32>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lea X64 [RM] r  [] 8D 

template<typename ...T, typename ...Y>
constexpr auto asm_lea<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lea<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  leave ANY [NONE]   [] C9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_leave = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','e','a','v','e', str...>, hold<T...>> {
    static constexpr auto value = asm_leave<T...>;
};
template <>
constexpr auto asm_leave<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xC9>>>::value;
//  les X86 [RM] r  [66] C4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_les = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','e','s', str...>, hold<T...>> {
    static constexpr auto value = asm_les<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_les<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC4>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_les<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC4>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  les X86 [RM] r  [] C4 

template<typename ...T, typename ...Y>
constexpr auto asm_les<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC4>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_les<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC4>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lfence ANY [NONE] 5 0 [] E8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lfence = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','f','e','n','c','e', str...>, hold<T...>> {
    static constexpr auto value = asm_lfence<T...>;
};
template <>
constexpr auto asm_lfence<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0xE8>>>::value;
//  lfs ANY [RM] r  [66] B4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lfs = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','f','s', str...>, hold<T...>> {
    static constexpr auto value = asm_lfs<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_lfs<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB4>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lfs<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB4>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lfs ANY [RM] r  [] B4 

template<typename ...T, typename ...Y>
constexpr auto asm_lfs<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB4>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lfs<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB4>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lfs X64 [RM] r  [] B4 

template<typename ...T, typename ...Y>
constexpr auto asm_lfs<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB4>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lfs<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB4>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lgdt ANY [M] 2  [] 01 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lgdt = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','g','d','t', str...>, hold<T...>> {
    static constexpr auto value = asm_lgdt<T...>;
};
template<typename ...T>
constexpr auto asm_lgdt<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  lgs ANY [RM] r  [66] B5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lgs = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','g','s', str...>, hold<T...>> {
    static constexpr auto value = asm_lgs<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_lgs<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB5>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lgs<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB5>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lgs ANY [RM] r  [] B5 

template<typename ...T, typename ...Y>
constexpr auto asm_lgs<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB5>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lgs<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB5>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lgs X64 [RM] r  [] B5 

template<typename ...T, typename ...Y>
constexpr auto asm_lgs<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB5>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lgs<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB5>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lidt ANY [M] 3  [] 01 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lidt = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','i','d','t', str...>, hold<T...>> {
    static constexpr auto value = asm_lidt<T...>;
};
template<typename ...T>
constexpr auto asm_lidt<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  ljmp X86 [II]   [66] EA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_ljmp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','j','m','p', str...>, hold<T...>> {
    static constexpr auto value = asm_ljmp<T...>;
};
template <uint16_t T, uint16_t Y> 
constexpr auto asm_ljmp<disp16<T>, disp16<Y>> =
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0xEA>, typename disp16<T>::value, typename disp16<Y>::value>>::value;
//  ljmp X86 [II]   [] EA 

template <uint16_t T, uint32_t Y> 
constexpr auto asm_ljmp<disp16<T>, disp32<Y>> =
  seq_to_arr<expand_byte_seq_v< byte_seq<0xEA>, typename disp16<T>::value, typename disp32<Y>::value>>::value;
//  ljmp ANY [M] 5  [66] FF 

template<typename ...T>
constexpr auto asm_ljmp<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ljmp<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  ljmp ANY [M] 5  [] FF 

template<typename ...T>
constexpr auto asm_ljmp<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ljmp<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  ljmp X64 [M] 5  [] FF 

template<typename ...T>
constexpr auto asm_ljmp<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ljmp<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  lldt ANY [M] 2  [] 00 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lldt = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','l','d','t', str...>, hold<T...>> {
    static constexpr auto value = asm_lldt<T...>;
};
template<typename ...T>
constexpr auto asm_lldt<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_lldt<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x00>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  llwpcb ANY [M] 0  [] 12 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_llwpcb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','l','w','p','c','b', str...>, hold<T...>> {
    static constexpr auto value = asm_llwpcb<T...>;
};
template<typename ...T>
constexpr auto asm_llwpcb<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<reg<0>>>>, disp8<is_ext_v<hold<T...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

//  llwpcb X64 [M] 0  [] 12 

template<typename ...T>
constexpr auto asm_llwpcb<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<reg<0>>>>, disp8<is_ext_v<hold<T...>>>, disp8<0>, disp8<9>, disp8<1>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

//  lmsw ANY [M] 6  [] 01 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lmsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','m','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_lmsw<T...>;
};
template<typename ...T>
constexpr auto asm_lmsw<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x01>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

template<typename ...T>
constexpr auto asm_lmsw<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  lodsb ANY [NONE]   [] AC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lodsb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','o','d','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_lodsb<T...>;
};
template <>
constexpr auto asm_lodsb<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xAC>>>::value;
//  lodsd ANY [NONE]   [] AD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lodsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','o','d','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_lodsd<T...>;
};
template <>
constexpr auto asm_lodsd<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xAD>>>::value;
//  lodsq X64 [NONE]   [] AD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lodsq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','o','d','s','q', str...>, hold<T...>> {
    static constexpr auto value = asm_lodsq<T...>;
};
template <>
constexpr auto asm_lodsq<> = seq_to_arr<expand_byte_seq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0xAD>>>::value;
//  lodsw ANY [NONE]   [66] AD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lodsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','o','d','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_lodsw<T...>;
};
template <>
constexpr auto asm_lodsw<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0xAD>>>::value;
//  loop X86 [D]   [] E2 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_loop = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','o','o','p', str...>, hold<T...>> {
    static constexpr auto value = asm_loop<T...>;
};
template<uint8_t N>
constexpr auto asm_loop<rel8<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x67>,  byte_seq<0xE2>, typename rel8<N>::value>>::value;
//  loope X86 [D]   [] E1 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_loope = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','o','o','p','e', str...>, hold<T...>> {
    static constexpr auto value = asm_loope<T...>;
};
template<uint8_t N>
constexpr auto asm_loope<rel8<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x67>,  byte_seq<0xE1>, typename rel8<N>::value>>::value;
//  loopne X86 [D]   [] E0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_loopne = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','o','o','p','n','e', str...>, hold<T...>> {
    static constexpr auto value = asm_loopne<T...>;
};
template<uint8_t N>
constexpr auto asm_loopne<rel8<N>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x67>,  byte_seq<0xE0>, typename rel8<N>::value>>::value;
//  lsl ANY [RM] r  [66] 03 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lsl = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','s','l', str...>, hold<T...>> {
    static constexpr auto value = asm_lsl<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_lsl<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x03>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lsl<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x03>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lsl ANY [RM] r  [] 03 

template<typename ...T, typename ...Y>
constexpr auto asm_lsl<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x03>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lsl<zip<reg32>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x03>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lsl X64 [RM] r  [] 03 

template<typename ...T, typename ...Y>
constexpr auto asm_lsl<zip<reg64>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x03>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lsl<zip<reg64>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x03>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lss ANY [RM] r  [66] B2 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_lss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_lss<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB2>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lss<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB2>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lss ANY [RM] r  [] B2 

template<typename ...T, typename ...Y>
constexpr auto asm_lss<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB2>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lss<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB2>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lss X64 [RM] r  [] B2 

template<typename ...T, typename ...Y>
constexpr auto asm_lss<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB2>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lss<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB2>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  ltr ANY [M] 3  [] 00 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_ltr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','t','r', str...>, hold<T...>> {
    static constexpr auto value = asm_ltr<T...>;
};
template<typename ...T>
constexpr auto asm_ltr<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ltr<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x00>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  lwpins ANY [VMI] 0  [] 12 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lwpins = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','w','p','i','n','s', str...>, hold<T...>> {
    static constexpr auto value = asm_lwpins<T...>;
};
template<typename ...T, typename ...Y, uint32_t Z>
constexpr auto asm_lwpins<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, disp32<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<reg<0>>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<0>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<reg<0>>>::value, typename disp32<Z>::value>>::value;

template<typename ...T, typename ...Y, uint32_t Z>
constexpr auto asm_lwpins<zip<reg32>::with<T...>, ptr<reg32, Y...>, disp32<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<reg<0>>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<0>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename mrm<Y...>::template value<hold<reg<0>>>, typename disp32<Z>::value>>::value;

//  lwpins X64 [VMI] 0  [] 12 

template<typename ...T, typename ...Y, uint32_t Z>
constexpr auto asm_lwpins<zip<reg64>::with<T...>, zip<reg32>::with<Y...>, disp32<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<reg<0>>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<0>, disp8<1>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<reg<0>>>::value, typename disp32<Z>::value>>::value;

template<typename ...T, typename ...Y, uint32_t Z>
constexpr auto asm_lwpins<zip<reg64>::with<T...>, ptr<reg32, Y...>, disp32<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<reg<0>>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<0>, disp8<1>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename mrm<Y...>::template value<hold<reg<0>>>, typename disp32<Z>::value>>::value;

//  lwpval ANY [VMI] 1  [] 12 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lwpval = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','w','p','v','a','l', str...>, hold<T...>> {
    static constexpr auto value = asm_lwpval<T...>;
};
template<typename ...T, typename ...Y, uint32_t Z>
constexpr auto asm_lwpval<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, disp32<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<reg<1>>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<0>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<reg<1>>>::value, typename disp32<Z>::value>>::value;

template<typename ...T, typename ...Y, uint32_t Z>
constexpr auto asm_lwpval<zip<reg32>::with<T...>, ptr<reg32, Y...>, disp32<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<reg<1>>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<0>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename mrm<Y...>::template value<hold<reg<1>>>, typename disp32<Z>::value>>::value;

//  lwpval X64 [VMI] 1  [] 12 

template<typename ...T, typename ...Y, uint32_t Z>
constexpr auto asm_lwpval<zip<reg64>::with<T...>, zip<reg32>::with<Y...>, disp32<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<reg<1>>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<0>, disp8<1>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<reg<1>>>::value, typename disp32<Z>::value>>::value;

template<typename ...T, typename ...Y, uint32_t Z>
constexpr auto asm_lwpval<zip<reg64>::with<T...>, ptr<reg32, Y...>, disp32<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<reg<1>>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<0>, disp8<1>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename mrm<Y...>::template value<hold<reg<1>>>, typename disp32<Z>::value>>::value;

//  lzcnt ANY [RM] r  [66F3] BD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_lzcnt = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'l','z','c','n','t', str...>, hold<T...>> {
    static constexpr auto value = asm_lzcnt<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_lzcnt<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66, 0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBD>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lzcnt<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66, 0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBD>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lzcnt ANY [RM] r  [F3] BD 

template<typename ...T, typename ...Y>
constexpr auto asm_lzcnt<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBD>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lzcnt<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBD>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  lzcnt X64 [RM] r  [F3] BD 

template<typename ...T, typename ...Y>
constexpr auto asm_lzcnt<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBD>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_lzcnt<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBD>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  maskmovdqu ANY [RM] r  [66] F7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_maskmovdqu = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','a','s','k','m','o','v','d','q','u', str...>, hold<T...>> {
    static constexpr auto value = asm_maskmovdqu<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_maskmovdqu<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  maskmovq ANY [RM] r  [] F7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_maskmovq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','a','s','k','m','o','v','q', str...>, hold<T...>> {
    static constexpr auto value = asm_maskmovq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_maskmovq<zip<mmx>::with<T...>, zip<mmx>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  maxpd ANY [RM] r  [66] 5F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_maxpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','a','x','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_maxpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_maxpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_maxpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  maxps ANY [RM] r  [] 5F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_maxps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','a','x','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_maxps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_maxps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_maxps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  maxsd ANY [RM] r  [F2] 5F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_maxsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','a','x','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_maxsd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_maxsd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_maxsd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  maxss ANY [RM] r  [F3] 5F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_maxss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','a','x','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_maxss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_maxss<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_maxss<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  mcommit ANY [NONE]   [F3] FA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_mcommit = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','c','o','m','m','i','t', str...>, hold<T...>> {
    static constexpr auto value = asm_mcommit<T...>;
};
template <>
constexpr auto asm_mcommit<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x01>,  byte_seq<0xFA>>>::value;
//  mfence ANY [NONE] 6 0 [] F0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_mfence = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','f','e','n','c','e', str...>, hold<T...>> {
    static constexpr auto value = asm_mfence<T...>;
};
template <>
constexpr auto asm_mfence<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0xF0>>>::value;
//  minpd ANY [RM] r  [66] 5D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_minpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','i','n','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_minpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_minpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_minpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  minps ANY [RM] r  [] 5D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_minps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','i','n','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_minps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_minps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_minps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  minsd ANY [RM] r  [F2] 5D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_minsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','i','n','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_minsd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_minsd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_minsd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  minss ANY [RM] r  [F3] 5D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_minss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','i','n','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_minss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_minss<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_minss<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  monitor ANY [NONE]   [] C8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_monitor = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','n','i','t','o','r', str...>, hold<T...>> {
    static constexpr auto value = asm_monitor<T...>;
};
template <>
constexpr auto asm_monitor<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xC8>>>::value;
//  monitorx ANY [NONE]   [] FA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_monitorx = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','n','i','t','o','r','x', str...>, hold<T...>> {
    static constexpr auto value = asm_monitorx<T...>;
};
template <>
constexpr auto asm_monitorx<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xFA>>>::value;
//  mov ANY [MR] r  [] 88 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_mov = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v', str...>, hold<T...>> {
    static constexpr auto value = asm_mov<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_mov<ptr<reg8, T...>, zip<reg8>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x88>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  mov ANY [MR] r  [66] 89 

template<typename ...T, typename ...Y>
constexpr auto asm_mov<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x89>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  mov ANY [MR] r  [] 89 

template<typename ...T, typename ...Y>
constexpr auto asm_mov<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x89>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  mov X64 [MR] r  [] 89 

template<typename ...T, typename ...Y>
constexpr auto asm_mov<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x89>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  mov ANY [MI] 0  [] C6 

template<typename ...T, uint8_t Y>
constexpr auto asm_mov<ptr<reg8, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC6>, typename mrm<T...>::template value<hold<reg<0>>>, typename disp8<Y>::value>>::value;

//  mov ANY [MI] 0  [66] C7 

template<typename ...T, uint16_t Y>
constexpr auto asm_mov<ptr<reg16, T...>, disp16<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, typename mrm<T...>::template value<hold<reg<0>>>, typename disp16<Y>::value>>::value;

//  mov ANY [MI] 0  [] C7 

template<typename ...T, uint32_t Y>
constexpr auto asm_mov<ptr<reg32, T...>, disp32<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, typename mrm<T...>::template value<hold<reg<0>>>, typename disp32<Y>::value>>::value;

//  mov X64 [MI] 0  [] C7 

template<typename ...T, uint32_t Y>
constexpr auto asm_mov<ptr<reg64, T...>, id<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, typename mrm<T...>::template value<hold<reg<0>>>, typename id<Y>::value>>::value;

//  mov ANY [I]   [] B0 

template <typename ...T, uint8_t Y> 
constexpr auto asm_mov<zip<reg8>::with<T...>, disp8<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0xB0>, typename disp8<Y>::value>>::value;
//  mov ANY [I]   [66] B8 

template <typename ...T, uint16_t Y> 
constexpr auto asm_mov<zip<reg16>::with<T...>, disp16<Y>> =
    seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0xB8>, typename disp16<Y>::value>>::value;
//  mov ANY [I]   [] B8 

template <typename ...T, uint32_t Y> 
constexpr auto asm_mov<zip<reg32>::with<T...>, disp32<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0xB8>, typename disp32<Y>::value>>::value;
//  mov X64 [I]   [] B8 

template <typename ...T, uint64_t Y> 
constexpr auto asm_mov<zip<reg64>::with<T...>, disp64<Y>> =
    seq_to_arr<expand_byte_seq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0xB8>, typename disp64<Y>::value>>::value;
//  mov ANY [RM] r  [] 8A 

template<typename ...T, typename ...Y>
constexpr auto asm_mov<zip<reg8>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_mov<zip<reg8>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  mov ANY [RM] r  [66] 8B 

template<typename ...T, typename ...Y>
constexpr auto asm_mov<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_mov<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  mov ANY [RM] r  [] 8B 

template<typename ...T, typename ...Y>
constexpr auto asm_mov<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_mov<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  mov X64 [RM] r  [] 8B 

template<typename ...T, typename ...Y>
constexpr auto asm_mov<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_mov<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movapd ANY [RM] r  [66] 28 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movapd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','a','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_movapd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movapd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x28>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movapd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x28>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movapd ANY [MR] r  [66] 29 

template<typename ...T, typename ...Y>
constexpr auto asm_movapd<ptr<reg128, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x29>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movaps ANY [RM] r  [] 28 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movaps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','a','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_movaps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movaps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x28>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movaps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x28>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movaps ANY [MR] r  [] 29 

template<typename ...T, typename ...Y>
constexpr auto asm_movaps<ptr<reg128, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x29>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movbe ANY [RM] r  [66] F0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movbe = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','b','e', str...>, hold<T...>> {
    static constexpr auto value = asm_movbe<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movbe<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movbe<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF0>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movbe ANY [RM] r  [] F0 

template<typename ...T, typename ...Y>
constexpr auto asm_movbe<zip<reg32>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movbe<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF0>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movbe X64 [RM] r  [] F0 

template<typename ...T, typename ...Y>
constexpr auto asm_movbe<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movbe<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF0>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movbe ANY [MR] r  [66] F1 

template<typename ...T, typename ...Y>
constexpr auto asm_movbe<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF1>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movbe ANY [MR] r  [] F1 

template<typename ...T, typename ...Y>
constexpr auto asm_movbe<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF1>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movbe X64 [MR] r  [] F1 

template<typename ...T, typename ...Y>
constexpr auto asm_movbe<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF1>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movd ANY [RM] r  [] 6E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','d', str...>, hold<T...>> {
    static constexpr auto value = asm_movd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movd<zip<mmx>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movd<zip<mmx>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movd ANY [MR] r  [] 7E 

template<typename ...T, typename ...Y>
constexpr auto asm_movd<ptr<reg32, T...>, zip<mmx>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x7E>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movd ANY [MR] r  [66] 7E 

template<typename ...T, typename ...Y>
constexpr auto asm_movd<ptr<reg32, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x7E>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movd ANY [RM] r  [66] 6E 

template<typename ...T, typename ...Y>
constexpr auto asm_movd<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movd<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movddup ANY [RM] r  [F2] 12 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movddup = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','d','d','u','p', str...>, hold<T...>> {
    static constexpr auto value = asm_movddup<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movddup<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movddup<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x12>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movdir64b ANY [RM] r  [66] F8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movdir64b = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','d','i','r','6','4','b', str...>, hold<T...>> {
    static constexpr auto value = asm_movdir64b<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movdir64b<zip<reg32>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF8>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movdir64b<zip<reg32>::with<T...>, ptr<reg512, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF8>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movdir64b X64 [RM] r  [66] F8 

template<typename ...T, typename ...Y>
constexpr auto asm_movdir64b<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF8>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movdir64b<zip<reg64>::with<T...>, ptr<reg512, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF8>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movdiri ANY [MR] r  [] F9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movdiri = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','d','i','r','i', str...>, hold<T...>> {
    static constexpr auto value = asm_movdiri<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movdiri<zip<reg64>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF9>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movdiri<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF9>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movdiri X64 [MR] r  [] F9 

template<typename ...T, typename ...Y>
constexpr auto asm_movdiri<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF9>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movdiri<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF9>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movdq2q ANY [RM] r  [F2] D6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movdq2q = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','d','q','2','q', str...>, hold<T...>> {
    static constexpr auto value = asm_movdq2q<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movdq2q<zip<mmx>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  movdqa ANY [RM] r  [66] 6F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movdqa = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','d','q','a', str...>, hold<T...>> {
    static constexpr auto value = asm_movdqa<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movdqa<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movdqa<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movdqa ANY [MR] r  [66] 7F 

template<typename ...T, typename ...Y>
constexpr auto asm_movdqa<ptr<reg128, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x7F>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movdqu ANY [RM] r  [F3] 6F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movdqu = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','d','q','u', str...>, hold<T...>> {
    static constexpr auto value = asm_movdqu<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movdqu<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movdqu<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movdqu ANY [MR] r  [F3] 7F 

template<typename ...T, typename ...Y>
constexpr auto asm_movdqu<ptr<reg128, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x7F>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movhlps ANY [RM] r  [] 12 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movhlps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','h','l','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_movhlps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movhlps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  movhpd ANY [MR] r  [66] 17 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movhpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','h','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_movhpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movhpd<ptr<reg64, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x17>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movhpd ANY [RM] r  [66] 16 

template<typename ...T, typename ...Y>
constexpr auto asm_movhpd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x16>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movhpd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x16>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movhps ANY [MR] r  [] 17 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movhps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','h','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_movhps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movhps<ptr<reg64, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x17>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movhps ANY [RM] r  [] 16 

template<typename ...T, typename ...Y>
constexpr auto asm_movhps<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x16>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movhps<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x16>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movlhps ANY [RM] r  [] 16 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movlhps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','l','h','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_movlhps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movlhps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x16>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  movlpd ANY [MR] r  [66] 13 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movlpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','l','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_movlpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movlpd<ptr<reg64, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x13>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movlpd ANY [RM] r  [66] 12 

template<typename ...T, typename ...Y>
constexpr auto asm_movlpd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movlpd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x12>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movlps ANY [MR] r  [] 13 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movlps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','l','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_movlps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movlps<ptr<reg64, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x13>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movlps ANY [RM] r  [] 12 

template<typename ...T, typename ...Y>
constexpr auto asm_movlps<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movlps<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x12>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movmskpd ANY [RM] r  [66] 50 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movmskpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','m','s','k','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_movmskpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movmskpd<zip<reg32>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x50>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  movmskps ANY [RM] r  [] 50 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movmskps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','m','s','k','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_movmskps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movmskps<zip<reg32>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x50>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  movntdq ANY [MR] r  [66] E7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movntdq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','n','t','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_movntdq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movntdq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xE7>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movntdq<ptr<reg128, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xE7>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movntdqa ANY [RM] r  [66] 2A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movntdqa = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','n','t','d','q','a', str...>, hold<T...>> {
    static constexpr auto value = asm_movntdqa<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movntdqa<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movntdqa<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movnti ANY [MR] r  [] C3 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movnti = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','n','t','i', str...>, hold<T...>> {
    static constexpr auto value = asm_movnti<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movnti<zip<reg64>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC3>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movnti<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC3>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movnti X64 [MR] r  [] C3 

template<typename ...T, typename ...Y>
constexpr auto asm_movnti<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC3>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movnti<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC3>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movntpd ANY [MR] r  [66] 2B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movntpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','n','t','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_movntpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movntpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x2B>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movntpd<ptr<reg128, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x2B>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movntps ANY [MR] r  [] 2B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movntps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','n','t','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_movntps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movntps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x2B>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movntps<ptr<reg128, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x2B>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movntq ANY [MR] r  [] E7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movntq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','n','t','q', str...>, hold<T...>> {
    static constexpr auto value = asm_movntq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movntq<zip<reg64>::with<T...>, zip<mmx>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xE7>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movntq<ptr<reg64, T...>, zip<mmx>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xE7>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movntsd ANY [RM] r  [F2] 2B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movntsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','n','t','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_movntsd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movntsd<zip<reg64>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  movntss ANY [RM] r  [F3] 2B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movntss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','n','t','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_movntss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movntss<zip<reg64>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  movq ANY [RM] r  [] 6F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','q', str...>, hold<T...>> {
    static constexpr auto value = asm_movq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movq<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movq<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movq X64 [RM] r  [] 6E 

//  movq ANY [MR] r  [] 7F 

template<typename ...T, typename ...Y>
constexpr auto asm_movq<ptr<reg64, T...>, zip<mmx>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x7F>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movq X64 [MR] r  [] 7E 

//  movq X64 [MR] r  [66] 7E 

//  movq X64 [RM] r  [66] 6E 

//  movq ANY [RM] r  [F3] 7E 

template<typename ...T, typename ...Y>
constexpr auto asm_movq<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x7E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movq<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x7E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movq ANY [MR] r  [66] D6 

template<typename ...T, typename ...Y>
constexpr auto asm_movq<ptr<reg64, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD6>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movq2dq ANY [RM] r  [F3] D6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movq2dq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','q','2','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_movq2dq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movq2dq<zip<reg128>::with<T...>, zip<mmx>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  movsb ANY [NONE]   [] A4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movsb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_movsb<T...>;
};
template <>
constexpr auto asm_movsb<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xA4>>>::value;
//  movsd ANY [NONE]   [] A5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_movsd<T...>;
};
template <>
constexpr auto asm_movsd<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xA5>>>::value;
//  movsd ANY [RM] r  [F2] 10 

template<typename ...T, typename ...Y>
constexpr auto asm_movsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  movsd ANY [RM] r  [F2] 10 

template<typename ...T, typename ...Y>
constexpr auto asm_movsd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movsd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x10>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movsd ANY [MR] r  [F2] 11 

template<typename ...T, typename ...Y>
constexpr auto asm_movsd<ptr<reg64, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x11>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movshdup ANY [RM] r  [F3] 16 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movshdup = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','s','h','d','u','p', str...>, hold<T...>> {
    static constexpr auto value = asm_movshdup<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movshdup<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x16>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movshdup<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x16>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movsldup ANY [RM] r  [F3] 12 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movsldup = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','s','l','d','u','p', str...>, hold<T...>> {
    static constexpr auto value = asm_movsldup<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movsldup<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movsldup<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x12>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movsq X64 [NONE]   [] A5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movsq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','s','q', str...>, hold<T...>> {
    static constexpr auto value = asm_movsq<T...>;
};
template <>
constexpr auto asm_movsq<> = seq_to_arr<expand_byte_seq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0xA5>>>::value;
//  movss ANY [RM] r  [F3] 10 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_movss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  movss ANY [RM] r  [F3] 10 

template<typename ...T, typename ...Y>
constexpr auto asm_movss<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movss<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x10>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movss ANY [MR] r  [F3] 11 

template<typename ...T, typename ...Y>
constexpr auto asm_movss<ptr<reg32, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x11>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movsw ANY [NONE]   [66] A5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_movsw<T...>;
};
template <>
constexpr auto asm_movsw<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0xA5>>>::value;
//  movsx ANY [RM] r  [66] BE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movsx = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','s','x', str...>, hold<T...>> {
    static constexpr auto value = asm_movsx<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movsx<zip<reg16>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBE>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movsx<zip<reg16>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBE>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movsx ANY [RM] r  [] BE 

template<typename ...T, typename ...Y>
constexpr auto asm_movsx<zip<reg32>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBE>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movsx<zip<reg32>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBE>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movsx X64 [RM] r  [] BE 

template<typename ...T, typename ...Y>
constexpr auto asm_movsx<zip<reg64>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBE>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movsx<zip<reg64>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBE>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movsx ANY [RM] r  [] BF 

template<typename ...T, typename ...Y>
constexpr auto asm_movsx<zip<reg32>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBF>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movsx<zip<reg32>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBF>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movsx X64 [RM] r  [] BF 

template<typename ...T, typename ...Y>
constexpr auto asm_movsx<zip<reg64>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBF>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movsx<zip<reg64>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBF>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movsxd X64 [RM] r  [66] 63 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movsxd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','s','x','d', str...>, hold<T...>> {
    static constexpr auto value = asm_movsxd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movsxd<zip<reg16>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x63>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movsxd<zip<reg16>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x63>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movsxd X64 [RM] r  [] 63 

template<typename ...T, typename ...Y>
constexpr auto asm_movsxd<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x63>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movsxd<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x63>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movsxd X64 [RM] r  [] 63 

template<typename ...T, typename ...Y>
constexpr auto asm_movsxd<zip<reg64>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x63>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movsxd<zip<reg64>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x63>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movupd ANY [RM] r  [66] 10 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movupd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','u','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_movupd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movupd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movupd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x10>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movupd ANY [MR] r  [66] 11 

template<typename ...T, typename ...Y>
constexpr auto asm_movupd<ptr<reg128, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x11>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movups ANY [RM] r  [] 10 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movups = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','u','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_movups<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movups<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movups<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x10>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movups ANY [MR] r  [] 11 

template<typename ...T, typename ...Y>
constexpr auto asm_movups<ptr<reg128, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x11>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  movzx ANY [RM] r  [66] B6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_movzx = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','o','v','z','x', str...>, hold<T...>> {
    static constexpr auto value = asm_movzx<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_movzx<zip<reg16>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movzx<zip<reg16>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movzx ANY [RM] r  [] B6 

template<typename ...T, typename ...Y>
constexpr auto asm_movzx<zip<reg32>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movzx<zip<reg32>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movzx X64 [RM] r  [] B6 

template<typename ...T, typename ...Y>
constexpr auto asm_movzx<zip<reg64>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movzx<zip<reg64>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movzx ANY [RM] r  [] B7 

template<typename ...T, typename ...Y>
constexpr auto asm_movzx<zip<reg32>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB7>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movzx<zip<reg32>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB7>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  movzx X64 [RM] r  [] B7 

template<typename ...T, typename ...Y>
constexpr auto asm_movzx<zip<reg64>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB7>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_movzx<zip<reg64>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB7>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  mpsadbw ANY [RMI] r  [66] 42 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_mpsadbw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','p','s','a','d','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_mpsadbw<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_mpsadbw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x42>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_mpsadbw<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x42>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  mul ANY [M] 4  [] F6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_mul = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','u','l', str...>, hold<T...>> {
    static constexpr auto value = asm_mul<T...>;
};
template<typename ...Y>
constexpr auto asm_mul<zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<reg<4>>>::value>>::value;

template<typename ...Y>
constexpr auto asm_mul<ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, typename mrm<Y...>::template value<hold<reg<4>>>>>::value;

//  mul ANY [M] 4  [66] F7 

template<typename ...Z>
constexpr auto asm_mul<zip<reg16>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<4>>>::value>>::value;

template<typename ...Z>
constexpr auto asm_mul<ptr<reg16, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, typename mrm<Z...>::template value<hold<reg<4>>>>>::value;

//  mul ANY [M] 4  [] F7 

template<typename ...Z>
constexpr auto asm_mul<zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<4>>>::value>>::value;

template<typename ...Z>
constexpr auto asm_mul<ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, typename mrm<Z...>::template value<hold<reg<4>>>>>::value;

//  mul X64 [M] 4  [] F7 

template<typename ...Z>
constexpr auto asm_mul<zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<4>>>, is_ext_v<hold<Z...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<Z...>, hold<reg<4>>>::value>>::value;

template<typename ...Z>
constexpr auto asm_mul<ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<Z...>::X, mrm<Z...>::B>::value, byte_seq<0xF7>, typename mrm<Z...>::template value<hold<reg<4>>>>>::value;

//  mulpd ANY [RM] r  [66] 59 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_mulpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','u','l','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_mulpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_mulpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x59>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_mulpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x59>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  mulps ANY [RM] r  [] 59 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_mulps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','u','l','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_mulps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_mulps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x59>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_mulps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x59>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  mulsd ANY [RM] r  [F2] 59 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_mulsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','u','l','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_mulsd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_mulsd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x59>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_mulsd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x59>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  mulss ANY [RM] r  [F3] 59 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_mulss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','u','l','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_mulss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_mulss<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x59>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_mulss<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x59>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  mulx ANY [RVM] r  [F2] F6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_mulx = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','u','l','x', str...>, hold<T...>> {
    static constexpr auto value = asm_mulx<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_mulx<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF6>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_mulx<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF6>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  mulx X64 [RVM] r  [F2] F6 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_mulx<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF6>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_mulx<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF6>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  mwait ANY [NONE]   [] C9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_mwait = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','w','a','i','t', str...>, hold<T...>> {
    static constexpr auto value = asm_mwait<T...>;
};
template <>
constexpr auto asm_mwait<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xC9>>>::value;
//  mwaitx ANY [NONE]   [] FB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_mwaitx = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'m','w','a','i','t','x', str...>, hold<T...>> {
    static constexpr auto value = asm_mwaitx<T...>;
};
template <>
constexpr auto asm_mwaitx<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xFB>>>::value;
//  neg ANY [M] 3  [] F6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_neg = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'n','e','g', str...>, hold<T...>> {
    static constexpr auto value = asm_neg<T...>;
};
template<typename ...T>
constexpr auto asm_neg<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_neg<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF6>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  neg ANY [M] 3  [66] F7 

template<typename ...T>
constexpr auto asm_neg<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_neg<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF7>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  neg ANY [M] 3  [] F7 

template<typename ...T>
constexpr auto asm_neg<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_neg<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF7>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  neg X64 [M] 3  [] F7 

template<typename ...T>
constexpr auto asm_neg<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_neg<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF7>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  nop ANY [NONE]   [] 90 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_nop = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'n','o','p', str...>, hold<T...>> {
    static constexpr auto value = asm_nop<T...>;
};
template <>
constexpr auto asm_nop<> = seq_to_arr<expand_byte_seq_v< byte_seq<0x90>>>::value;
//  nop ANY [M] 0  [66] 1F 

template<typename ...T>
constexpr auto asm_nop<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x1F>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_nop<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x1F>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  nop ANY [M] 0  [] 1F 

template<typename ...T>
constexpr auto asm_nop<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x1F>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_nop<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x1F>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  nop ANY [M] 0  [] 1F 

template<typename ...T>
constexpr auto asm_nop<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x1F>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_nop<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x1F>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  nop ANY [MR] r  [66] 1F 

template<typename ...T, typename ...Y>
constexpr auto asm_nop<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x1F>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_nop<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x1F>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  nop ANY [MR] r  [] 1F 

template<typename ...T, typename ...Y>
constexpr auto asm_nop<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x1F>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_nop<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x1F>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  nop ANY [MR] r  [] 1F 

template<typename ...T, typename ...Y>
constexpr auto asm_nop<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x1F>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_nop<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x1F>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  not ANY [M] 2  [] F6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_not = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'n','o','t', str...>, hold<T...>> {
    static constexpr auto value = asm_not<T...>;
};
template<typename ...T>
constexpr auto asm_not<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_not<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF6>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  not ANY [M] 2  [66] F7 

template<typename ...T>
constexpr auto asm_not<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_not<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF7>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  not ANY [M] 2  [] F7 

template<typename ...T>
constexpr auto asm_not<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_not<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF7>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  not X64 [M] 2  [] F7 

template<typename ...T>
constexpr auto asm_not<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF7>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_not<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF7>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  or ANY [I]   [] 0C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_or = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'o','r', str...>, hold<T...>> {
    static constexpr auto value = asm_or<T...>;
};
template <uint8_t Y> 
constexpr auto asm_or<al, disp8<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x0C>, typename disp8<Y>::value>>::value;
//  or ANY [I]   [66] 0D 

template <uint16_t Y> 
constexpr auto asm_or<ax, disp16<Y>> =
    seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0x0D>, typename disp16<Y>::value>>::value;
//  or ANY [I]   [] 0D 

template <uint32_t Y> 
constexpr auto asm_or<eax, disp32<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x0D>, typename disp32<Y>::value>>::value;
//  or X64 [I]   [] 0D 

template <uint32_t Y> 
constexpr auto asm_or<rax, id<Y>> =
    seq_to_arr<expand_byte_seq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x0D>, typename id<Y>::value>>::value;
//  or ANY [MI] 1  [] 80 

template<typename ...T, uint8_t Y>
constexpr auto asm_or<ptr<reg8, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x80>, typename mrm<T...>::template value<hold<reg<1>>>, typename disp8<Y>::value>>::value;

//  or ANY [MI] 1  [66] 81 

template<typename ...T, uint16_t Y>
constexpr auto asm_or<ptr<reg16, T...>, disp16<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<1>>>, typename disp16<Y>::value>>::value;

//  or ANY [MI] 1  [] 81 

template<typename ...T, uint32_t Y>
constexpr auto asm_or<ptr<reg32, T...>, disp32<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<1>>>, typename disp32<Y>::value>>::value;

//  or X64 [MI] 1  [] 81 

template<typename ...T, uint32_t Y>
constexpr auto asm_or<ptr<reg64, T...>, id<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<1>>>, typename id<Y>::value>>::value;

//  or ANY [MI] 1  [66] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_or<ptr<reg16, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<1>>>, typename ib<Y>::value>>::value;

//  or ANY [MI] 1  [] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_or<ptr<reg32, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<1>>>, typename ib<Y>::value>>::value;

//  or X64 [MI] 1  [] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_or<ptr<reg64, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<1>>>, typename ib<Y>::value>>::value;

//  or ANY [MR] r  [] 08 

template<typename ...T, typename ...Y>
constexpr auto asm_or<ptr<reg8, T...>, zip<reg8>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x08>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  or ANY [MR] r  [66] 09 

template<typename ...T, typename ...Y>
constexpr auto asm_or<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x09>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  or ANY [MR] r  [] 09 

template<typename ...T, typename ...Y>
constexpr auto asm_or<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x09>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  or X64 [MR] r  [] 09 

template<typename ...T, typename ...Y>
constexpr auto asm_or<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x09>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  or ANY [RM] r  [] 0A 

template<typename ...T, typename ...Y>
constexpr auto asm_or<zip<reg8>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_or<zip<reg8>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  or ANY [RM] r  [66] 0B 

template<typename ...T, typename ...Y>
constexpr auto asm_or<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_or<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  or ANY [RM] r  [] 0B 

template<typename ...T, typename ...Y>
constexpr auto asm_or<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_or<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  or X64 [RM] r  [] 0B 

template<typename ...T, typename ...Y>
constexpr auto asm_or<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_or<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  orpd ANY [RM] r  [66] 56 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_orpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'o','r','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_orpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_orpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x56>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_orpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x56>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  orps ANY [RM] r  [] 56 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_orps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'o','r','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_orps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_orps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x56>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_orps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x56>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  out ANY [I]   [] E6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_out = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'o','u','t', str...>, hold<T...>> {
    static constexpr auto value = asm_out<T...>;
};
template <uint8_t T> 
constexpr auto asm_out<disp8<T>, al> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0xE6>, typename disp8<T>::value>>::value;
//  out ANY [I]   [66] E7 

template <uint8_t T> 
constexpr auto asm_out<disp8<T>, ax> =
    seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0xE7>, typename disp8<T>::value>>::value;
//  out ANY [I]   [] E7 

template <uint8_t T> 
constexpr auto asm_out<disp8<T>, eax> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0xE7>, typename disp8<T>::value>>::value;
//  outsb ANY [NONE]   [] 6E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_outsb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'o','u','t','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_outsb<T...>;
};
template <>
constexpr auto asm_outsb<dx, zsi> = seq_to_arr<expand_byte_seq_v< byte_seq<0x6E>>>::value;
//  outsd ANY [NONE]   [] 6F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_outsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'o','u','t','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_outsd<T...>;
};
template <>
constexpr auto asm_outsd<dx, zsi> = seq_to_arr<expand_byte_seq_v< byte_seq<0x6F>>>::value;
//  outsw ANY [NONE]   [66] 6F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_outsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'o','u','t','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_outsw<T...>;
};
template <>
constexpr auto asm_outsw<dx, zsi> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0x6F>>>::value;
//  pabsb ANY [RM] r  [] 1C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pabsb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','b','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_pabsb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pabsb<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pabsb<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pabsb ANY [RM] r  [66] 1C 

template<typename ...T, typename ...Y>
constexpr auto asm_pabsb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pabsb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pabsd ANY [RM] r  [] 1E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pabsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','b','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pabsd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pabsd<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pabsd<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pabsd ANY [RM] r  [66] 1E 

template<typename ...T, typename ...Y>
constexpr auto asm_pabsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pabsd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pabsw ANY [RM] r  [] 1D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pabsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','b','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pabsw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pabsw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pabsw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pabsw ANY [RM] r  [66] 1D 

template<typename ...T, typename ...Y>
constexpr auto asm_pabsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pabsw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  packssdw ANY [RM] r  [] 6B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_packssdw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','c','k','s','s','d','w', str...>, hold<T...>> {
    static constexpr auto value = asm_packssdw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_packssdw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_packssdw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  packssdw ANY [RM] r  [66] 6B 

template<typename ...T, typename ...Y>
constexpr auto asm_packssdw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_packssdw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  packsswb ANY [RM] r  [] 63 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_packsswb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','c','k','s','s','w','b', str...>, hold<T...>> {
    static constexpr auto value = asm_packsswb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_packsswb<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x63>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_packsswb<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x63>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  packsswb ANY [RM] r  [66] 63 

template<typename ...T, typename ...Y>
constexpr auto asm_packsswb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x63>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_packsswb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x63>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  packusdw ANY [RM] r  [66] 2B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_packusdw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','c','k','u','s','d','w', str...>, hold<T...>> {
    static constexpr auto value = asm_packusdw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_packusdw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_packusdw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  packuswb ANY [RM] r  [] 67 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_packuswb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','c','k','u','s','w','b', str...>, hold<T...>> {
    static constexpr auto value = asm_packuswb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_packuswb<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x67>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_packuswb<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x67>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  packuswb ANY [RM] r  [66] 67 

template<typename ...T, typename ...Y>
constexpr auto asm_packuswb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x67>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_packuswb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x67>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  paddb ANY [RM] r  [] FC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_paddb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','d','d','b', str...>, hold<T...>> {
    static constexpr auto value = asm_paddb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_paddb<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFC>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_paddb<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFC>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  paddb ANY [RM] r  [66] FC 

template<typename ...T, typename ...Y>
constexpr auto asm_paddb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFC>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_paddb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFC>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  paddd ANY [RM] r  [] FE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_paddd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','d','d','d', str...>, hold<T...>> {
    static constexpr auto value = asm_paddd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_paddd<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFE>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_paddd<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFE>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  paddd ANY [RM] r  [66] FE 

template<typename ...T, typename ...Y>
constexpr auto asm_paddd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFE>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_paddd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFE>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  paddq ANY [RM] r  [] D4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_paddq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','d','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_paddq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_paddq<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD4>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_paddq<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD4>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  paddq ANY [RM] r  [66] D4 

template<typename ...T, typename ...Y>
constexpr auto asm_paddq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD4>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_paddq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD4>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  paddsb ANY [RM] r  [] EC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_paddsb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','d','d','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_paddsb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_paddsb<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEC>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_paddsb<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEC>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  paddsb ANY [RM] r  [66] EC 

template<typename ...T, typename ...Y>
constexpr auto asm_paddsb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEC>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_paddsb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEC>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  paddsw ANY [RM] r  [] ED 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_paddsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','d','d','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_paddsw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_paddsw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xED>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_paddsw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xED>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  paddsw ANY [RM] r  [66] ED 

template<typename ...T, typename ...Y>
constexpr auto asm_paddsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xED>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_paddsw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xED>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  paddusb ANY [RM] r  [] DC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_paddusb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','d','d','u','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_paddusb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_paddusb<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_paddusb<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDC>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  paddusb ANY [RM] r  [66] DC 

template<typename ...T, typename ...Y>
constexpr auto asm_paddusb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDC>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_paddusb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDC>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  paddusw ANY [RM] r  [] DD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_paddusw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','d','d','u','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_paddusw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_paddusw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDD>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_paddusw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDD>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  paddusw ANY [RM] r  [66] DD 

template<typename ...T, typename ...Y>
constexpr auto asm_paddusw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDD>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_paddusw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDD>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  paddw ANY [RM] r  [] FD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_paddw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','d','d','w', str...>, hold<T...>> {
    static constexpr auto value = asm_paddw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_paddw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFD>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_paddw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFD>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  paddw ANY [RM] r  [66] FD 

template<typename ...T, typename ...Y>
constexpr auto asm_paddw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFD>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_paddw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFD>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  palignr ANY [RMI] r  [] 0F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_palignr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','l','i','g','n','r', str...>, hold<T...>> {
    static constexpr auto value = asm_palignr<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_palignr<zip<mmx>::with<T...>, zip<reg64>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0F>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_palignr<zip<mmx>::with<T...>, ptr<reg64, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0F>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  palignr ANY [RMI] r  [66] 0F 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_palignr<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0F>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_palignr<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0F>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  pand ANY [RM] r  [] DB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pand = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','n','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pand<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pand<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDB>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pand<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDB>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pand ANY [RM] r  [66] DB 

template<typename ...T, typename ...Y>
constexpr auto asm_pand<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDB>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pand<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDB>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pandn ANY [RM] r  [] DF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pandn = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','n','d','n', str...>, hold<T...>> {
    static constexpr auto value = asm_pandn<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pandn<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pandn<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDF>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pandn ANY [RM] r  [66] DF 

template<typename ...T, typename ...Y>
constexpr auto asm_pandn<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDF>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pandn<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDF>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pause ANY [NONE]   [F3] 90 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pause = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','u','s','e', str...>, hold<T...>> {
    static constexpr auto value = asm_pause<T...>;
};
template <>
constexpr auto asm_pause<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>,  byte_seq<0x90>>>::value;
//  pavgb ANY [RM] r  [] E0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pavgb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','v','g','b', str...>, hold<T...>> {
    static constexpr auto value = asm_pavgb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pavgb<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE0>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pavgb<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE0>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pavgb ANY [RM] r  [66] E0 

template<typename ...T, typename ...Y>
constexpr auto asm_pavgb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE0>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pavgb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE0>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pavgusb ANY [RM] r  [] BF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pavgusb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','v','g','u','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_pavgusb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pavgusb<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBF>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pavgusb<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBF>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pavgw ANY [RM] r  [] E3 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pavgw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','a','v','g','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pavgw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pavgw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE3>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pavgw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE3>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pavgw ANY [RM] r  [66] E3 

template<typename ...T, typename ...Y>
constexpr auto asm_pavgw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE3>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pavgw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE3>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pblendvb ANY [RM] r  [66] E0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pblendvb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','b','l','e','n','d','v','b', str...>, hold<T...>> {
    static constexpr auto value = asm_pblendvb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pblendvb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE0>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pblendvb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE0>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pblendw ANY [RMI] r  [66] 0E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pblendw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','b','l','e','n','d','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pblendw<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pblendw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0E>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pblendw<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0E>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  pclmulqdq ANY [RMI] r  [66] 44 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pclmulqdq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','l','m','u','l','q','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_pclmulqdq<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pclmulqdq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x44>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pclmulqdq<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x44>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  pcmpeqb ANY [RM] r  [] 74 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pcmpeqb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','e','q','b', str...>, hold<T...>> {
    static constexpr auto value = asm_pcmpeqb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pcmpeqb<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x74>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpeqb<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x74>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pcmpeqb ANY [RM] r  [66] 74 

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpeqb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x74>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpeqb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x74>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pcmpeqd ANY [RM] r  [] 76 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pcmpeqd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','e','q','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pcmpeqd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pcmpeqd<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x76>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpeqd<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x76>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pcmpeqd ANY [RM] r  [66] 76 

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpeqd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x76>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpeqd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x76>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pcmpeqq ANY [RM] r  [66] 29 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pcmpeqq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','e','q','q', str...>, hold<T...>> {
    static constexpr auto value = asm_pcmpeqq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pcmpeqq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x29>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpeqq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x29>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pcmpeqw ANY [RM] r  [] 75 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pcmpeqw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','e','q','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pcmpeqw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pcmpeqw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x75>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpeqw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x75>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pcmpeqw ANY [RM] r  [66] 75 

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpeqw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x75>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpeqw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x75>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pcmpestri ANY [RMI] r  [66] 61 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pcmpestri = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','e','s','t','r','i', str...>, hold<T...>> {
    static constexpr auto value = asm_pcmpestri<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pcmpestri<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x61>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pcmpestri<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x61>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  pcmpestrm ANY [RMI] r  [66] 60 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pcmpestrm = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','e','s','t','r','m', str...>, hold<T...>> {
    static constexpr auto value = asm_pcmpestrm<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pcmpestrm<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x60>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pcmpestrm<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x60>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  pcmpgtb ANY [RM] r  [] 64 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pcmpgtb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','g','t','b', str...>, hold<T...>> {
    static constexpr auto value = asm_pcmpgtb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pcmpgtb<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x64>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpgtb<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x64>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pcmpgtb ANY [RM] r  [66] 64 

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpgtb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x64>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpgtb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x64>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pcmpgtd ANY [RM] r  [] 66 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pcmpgtd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','g','t','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pcmpgtd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pcmpgtd<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x66>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpgtd<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x66>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pcmpgtd ANY [RM] r  [66] 66 

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpgtd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x66>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpgtd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x66>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pcmpgtq ANY [RM] r  [66] 37 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pcmpgtq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','g','t','q', str...>, hold<T...>> {
    static constexpr auto value = asm_pcmpgtq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pcmpgtq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x37>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpgtq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x37>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pcmpgtw ANY [RM] r  [] 65 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pcmpgtw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','g','t','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pcmpgtw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pcmpgtw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x65>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpgtw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x65>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pcmpgtw ANY [RM] r  [66] 65 

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpgtw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x65>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pcmpgtw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x65>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pcmpistri ANY [RMI] r  [66] 63 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pcmpistri = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','i','s','t','r','i', str...>, hold<T...>> {
    static constexpr auto value = asm_pcmpistri<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pcmpistri<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x63>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pcmpistri<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x63>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  pcmpistrm ANY [RMI] r  [66] 62 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pcmpistrm = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','m','p','i','s','t','r','m', str...>, hold<T...>> {
    static constexpr auto value = asm_pcmpistrm<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pcmpistrm<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x62>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pcmpistrm<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x62>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  pconfig ANY [NONE]   [] C5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pconfig = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','c','o','n','f','i','g', str...>, hold<T...>> {
    static constexpr auto value = asm_pconfig<T...>;
};
template <>
constexpr auto asm_pconfig<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xC5>>>::value;
//  pdep ANY [RVM] r  [F2] F5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pdep = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','d','e','p', str...>, hold<T...>> {
    static constexpr auto value = asm_pdep<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_pdep<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF5>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_pdep<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF5>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  pdep X64 [RVM] r  [F2] F5 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_pdep<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF5>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_pdep<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF5>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  pext ANY [RVM] r  [F3] F5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pext = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','e','x','t', str...>, hold<T...>> {
    static constexpr auto value = asm_pext<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_pext<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0xF5>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_pext<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0xF5>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  pext X64 [RVM] r  [F3] F5 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_pext<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0xF5>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_pext<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0xF5>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  pextrb ANY [MRI] r  [66] 14 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pextrb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','e','x','t','r','b', str...>, hold<T...>> {
    static constexpr auto value = asm_pextrb<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pextrb<ptr<reg8, T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x14>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  pextrd ANY [MRI] r  [66] 16 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pextrd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','e','x','t','r','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pextrd<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pextrd<ptr<reg32, T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x16>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  pextrq X64 [MRI] r  [66] 16 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pextrq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','e','x','t','r','q', str...>, hold<T...>> {
    static constexpr auto value = asm_pextrq<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pextrq<ptr<reg64, T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x16>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  pextrw ANY [RMI] r  [] C5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pextrw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','e','x','t','r','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pextrw<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pextrw<zip<reg32>::with<T...>, zip<mmx>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC5>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

//  pextrw ANY [RMI] r  [66] C5 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pextrw<zip<reg32>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC5>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

//  pextrw ANY [MRI] r  [66] 15 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pextrw<ptr<reg16, T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x15>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  pf2id ANY [RM] r  [] 1D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pf2id = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','2','i','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pf2id<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pf2id<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pf2id<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pf2iw ANY [RM] r  [] 1C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pf2iw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','2','i','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pf2iw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pf2iw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pf2iw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfacc ANY [RM] r  [] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfacc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','a','c','c', str...>, hold<T...>> {
    static constexpr auto value = asm_pfacc<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfacc<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfacc<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xAE>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfadd ANY [RM] r  [] 9E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfadd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','a','d','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pfadd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfadd<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x9E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfadd<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x9E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfcmpeq ANY [RM] r  [] B0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfcmpeq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','c','m','p','e','q', str...>, hold<T...>> {
    static constexpr auto value = asm_pfcmpeq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfcmpeq<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB0>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfcmpeq<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB0>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfcmpge ANY [RM] r  [] 90 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfcmpge = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','c','m','p','g','e', str...>, hold<T...>> {
    static constexpr auto value = asm_pfcmpge<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfcmpge<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x90>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfcmpge<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x90>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfcmpgt ANY [RM] r  [] A0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfcmpgt = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','c','m','p','g','t', str...>, hold<T...>> {
    static constexpr auto value = asm_pfcmpgt<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfcmpgt<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xA0>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfcmpgt<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xA0>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfmax ANY [RM] r  [] A4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfmax = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','m','a','x', str...>, hold<T...>> {
    static constexpr auto value = asm_pfmax<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfmax<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xA4>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfmax<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xA4>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfmin ANY [RM] r  [] 94 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfmin = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','m','i','n', str...>, hold<T...>> {
    static constexpr auto value = asm_pfmin<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfmin<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x94>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfmin<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x94>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfmul ANY [RM] r  [] B4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfmul = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','m','u','l', str...>, hold<T...>> {
    static constexpr auto value = asm_pfmul<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfmul<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB4>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfmul<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB4>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfnacc ANY [RM] r  [] 8A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfnacc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','n','a','c','c', str...>, hold<T...>> {
    static constexpr auto value = asm_pfnacc<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfnacc<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfnacc<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfpnacc ANY [RM] r  [] 8E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfpnacc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','p','n','a','c','c', str...>, hold<T...>> {
    static constexpr auto value = asm_pfpnacc<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfpnacc<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x8E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfpnacc<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x8E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfrcp ANY [RM] r  [] 96 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfrcp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','r','c','p', str...>, hold<T...>> {
    static constexpr auto value = asm_pfrcp<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfrcp<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x96>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfrcp<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x96>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfrcpit1 ANY [RM] r  [] A6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfrcpit1 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','r','c','p','i','t','1', str...>, hold<T...>> {
    static constexpr auto value = asm_pfrcpit1<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfrcpit1<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xA6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfrcpit1<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xA6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfrcpit2 ANY [RM] r  [] B6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfrcpit2 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','r','c','p','i','t','2', str...>, hold<T...>> {
    static constexpr auto value = asm_pfrcpit2<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfrcpit2<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfrcpit2<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfrcpv ANY [RM] r  [] 86 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfrcpv = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','r','c','p','v', str...>, hold<T...>> {
    static constexpr auto value = asm_pfrcpv<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfrcpv<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x86>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfrcpv<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x86>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfrsqit1 ANY [RM] r  [] A7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfrsqit1 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','r','s','q','i','t','1', str...>, hold<T...>> {
    static constexpr auto value = asm_pfrsqit1<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfrsqit1<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xA7>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfrsqit1<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xA7>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfrsqrt ANY [RM] r  [] 97 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfrsqrt = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','r','s','q','r','t', str...>, hold<T...>> {
    static constexpr auto value = asm_pfrsqrt<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfrsqrt<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x97>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfrsqrt<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x97>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfrsqrtv ANY [RM] r  [] 87 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfrsqrtv = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','r','s','q','r','t','v', str...>, hold<T...>> {
    static constexpr auto value = asm_pfrsqrtv<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfrsqrtv<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x87>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfrsqrtv<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x87>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfsub ANY [RM] r  [] 9A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfsub = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','s','u','b', str...>, hold<T...>> {
    static constexpr auto value = asm_pfsub<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfsub<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x9A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfsub<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x9A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pfsubr ANY [RM] r  [] AA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pfsubr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','f','s','u','b','r', str...>, hold<T...>> {
    static constexpr auto value = asm_pfsubr<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pfsubr<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xAA>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pfsubr<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xAA>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  phaddd ANY [RM] r  [] 02 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_phaddd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','h','a','d','d','d', str...>, hold<T...>> {
    static constexpr auto value = asm_phaddd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_phaddd<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x02>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_phaddd<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x02>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  phaddd ANY [RM] r  [66] 02 

template<typename ...T, typename ...Y>
constexpr auto asm_phaddd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x02>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_phaddd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x02>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  phaddsw ANY [RM] r  [] 03 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_phaddsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','h','a','d','d','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_phaddsw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_phaddsw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x03>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_phaddsw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x03>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  phaddsw ANY [RM] r  [66] 03 

template<typename ...T, typename ...Y>
constexpr auto asm_phaddsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x03>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_phaddsw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x03>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  phaddw ANY [RM] r  [] 01 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_phaddw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','h','a','d','d','w', str...>, hold<T...>> {
    static constexpr auto value = asm_phaddw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_phaddw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x01>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_phaddw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x01>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  phaddw ANY [RM] r  [66] 01 

template<typename ...T, typename ...Y>
constexpr auto asm_phaddw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x01>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_phaddw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x01>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  phminposuw ANY [RM] r  [66] 41 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_phminposuw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','h','m','i','n','p','o','s','u','w', str...>, hold<T...>> {
    static constexpr auto value = asm_phminposuw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_phminposuw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x41>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_phminposuw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x41>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  phsubd ANY [RM] r  [] 06 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_phsubd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','h','s','u','b','d', str...>, hold<T...>> {
    static constexpr auto value = asm_phsubd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_phsubd<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x06>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_phsubd<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x06>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  phsubd ANY [RM] r  [66] 06 

template<typename ...T, typename ...Y>
constexpr auto asm_phsubd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x06>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_phsubd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x06>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  phsubsw ANY [RM] r  [] 07 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_phsubsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','h','s','u','b','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_phsubsw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_phsubsw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x07>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_phsubsw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x07>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  phsubsw ANY [RM] r  [66] 07 

template<typename ...T, typename ...Y>
constexpr auto asm_phsubsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x07>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_phsubsw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x07>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  phsubw ANY [RM] r  [] 05 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_phsubw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','h','s','u','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_phsubw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_phsubw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x05>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_phsubw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x05>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  phsubw ANY [RM] r  [66] 05 

template<typename ...T, typename ...Y>
constexpr auto asm_phsubw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x05>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_phsubw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x05>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pi2fd ANY [RM] r  [] 0D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pi2fd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','i','2','f','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pi2fd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pi2fd<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pi2fd<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pi2fw ANY [RM] r  [] 0C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pi2fw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','i','2','f','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pi2fw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pi2fw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pi2fw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pinsrb ANY [RMI] r  [66] 20 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pinsrb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','i','n','s','r','b', str...>, hold<T...>> {
    static constexpr auto value = asm_pinsrb<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pinsrb<zip<reg128>::with<T...>, zip<reg8>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x20>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pinsrb<zip<reg128>::with<T...>, ptr<reg8, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x20>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  pinsrd ANY [RMI] r  [66] 22 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pinsrd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','i','n','s','r','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pinsrd<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pinsrd<zip<reg128>::with<T...>, zip<reg32>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x22>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pinsrd<zip<reg128>::with<T...>, ptr<reg32, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x22>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  pinsrq X64 [RMI] r  [66] 22 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pinsrq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','i','n','s','r','q', str...>, hold<T...>> {
    static constexpr auto value = asm_pinsrq<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pinsrq<zip<reg128>::with<T...>, zip<reg64>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x22>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pinsrq<zip<reg128>::with<T...>, ptr<reg64, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x22>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  pinsrw ANY [RMI] r  [] C4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pinsrw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','i','n','s','r','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pinsrw<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pinsrw<zip<mmx>::with<T...>, zip<reg16>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC4>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pinsrw<zip<mmx>::with<T...>, ptr<reg16, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC4>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  pinsrw ANY [RMI] r  [66] C4 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pinsrw<zip<reg128>::with<T...>, zip<reg16>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC4>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pinsrw<zip<reg128>::with<T...>, ptr<reg16, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC4>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  pmaddubsw ANY [RM] r  [] 04 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmaddubsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','a','d','d','u','b','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pmaddubsw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmaddubsw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x04>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmaddubsw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x04>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmaddubsw ANY [RM] r  [66] 04 

template<typename ...T, typename ...Y>
constexpr auto asm_pmaddubsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x04>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmaddubsw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x04>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmaddwd ANY [RM] r  [] F5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmaddwd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','a','d','d','w','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pmaddwd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmaddwd<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF5>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmaddwd<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF5>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmaddwd ANY [RM] r  [66] F5 

template<typename ...T, typename ...Y>
constexpr auto asm_pmaddwd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF5>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmaddwd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF5>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmaxsb ANY [RM] r  [66] 3C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmaxsb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','a','x','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_pmaxsb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmaxsb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmaxsb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmaxsd ANY [RM] r  [66] 3D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmaxsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','a','x','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pmaxsd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmaxsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmaxsd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmaxsw ANY [RM] r  [] EE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmaxsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','a','x','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pmaxsw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmaxsw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEE>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmaxsw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEE>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmaxsw ANY [RM] r  [66] EE 

template<typename ...T, typename ...Y>
constexpr auto asm_pmaxsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEE>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmaxsw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEE>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmaxub ANY [RM] r  [] DE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmaxub = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','a','x','u','b', str...>, hold<T...>> {
    static constexpr auto value = asm_pmaxub<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmaxub<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmaxub<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDE>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmaxub ANY [RM] r  [66] DE 

template<typename ...T, typename ...Y>
constexpr auto asm_pmaxub<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDE>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmaxub<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDE>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmaxud ANY [RM] r  [66] 3F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmaxud = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','a','x','u','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pmaxud<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmaxud<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmaxud<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmaxuw ANY [RM] r  [66] 3E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmaxuw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','a','x','u','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pmaxuw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmaxuw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmaxuw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pminsb ANY [RM] r  [66] 38 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pminsb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','i','n','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_pminsb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pminsb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x38>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pminsb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x38>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pminsd ANY [RM] r  [66] 39 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pminsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','i','n','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pminsd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pminsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x39>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pminsd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x39>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pminsw ANY [RM] r  [] EA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pminsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','i','n','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pminsw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pminsw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEA>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pminsw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEA>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pminsw ANY [RM] r  [66] EA 

template<typename ...T, typename ...Y>
constexpr auto asm_pminsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEA>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pminsw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEA>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pminub ANY [RM] r  [] DA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pminub = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','i','n','u','b', str...>, hold<T...>> {
    static constexpr auto value = asm_pminub<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pminub<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pminub<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDA>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pminub ANY [RM] r  [66] DA 

template<typename ...T, typename ...Y>
constexpr auto asm_pminub<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xDA>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pminub<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xDA>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pminud ANY [RM] r  [66] 3B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pminud = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','i','n','u','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pminud<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pminud<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pminud<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pminuw ANY [RM] r  [66] 3A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pminuw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','i','n','u','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pminuw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pminuw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x3A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pminuw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x3A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmovmskb ANY [RM] r  [] D7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmovmskb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','m','s','k','b', str...>, hold<T...>> {
    static constexpr auto value = asm_pmovmskb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmovmskb<zip<reg32>::with<T...>, zip<mmx>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD7>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  pmovmskb ANY [RM] r  [66] D7 

template<typename ...T, typename ...Y>
constexpr auto asm_pmovmskb<zip<reg32>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD7>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  pmovsxbd ANY [RM] r  [66] 21 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmovsxbd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','s','x','b','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pmovsxbd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmovsxbd<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x21>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmovsxbd<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x21>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmovsxbq ANY [RM] r  [66] 22 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmovsxbq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','s','x','b','q', str...>, hold<T...>> {
    static constexpr auto value = asm_pmovsxbq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmovsxbq<zip<reg128>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x22>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmovsxbq<zip<reg128>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x22>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmovsxbw ANY [RM] r  [66] 20 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmovsxbw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','s','x','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pmovsxbw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmovsxbw<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x20>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmovsxbw<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x20>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmovsxdq ANY [RM] r  [66] 25 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmovsxdq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','s','x','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_pmovsxdq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmovsxdq<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x25>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmovsxdq<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x25>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmovsxwd ANY [RM] r  [66] 23 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmovsxwd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','s','x','w','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pmovsxwd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmovsxwd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x23>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmovsxwd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x23>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmovsxwq ANY [RM] r  [66] 24 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmovsxwq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','s','x','w','q', str...>, hold<T...>> {
    static constexpr auto value = asm_pmovsxwq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmovsxwq<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x24>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmovsxwq<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x24>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmovzxbd ANY [RM] r  [66] 31 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmovzxbd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','z','x','b','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pmovzxbd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmovzxbd<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x31>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmovzxbd<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x31>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmovzxbq ANY [RM] r  [66] 32 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmovzxbq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','z','x','b','q', str...>, hold<T...>> {
    static constexpr auto value = asm_pmovzxbq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmovzxbq<zip<reg128>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x32>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmovzxbq<zip<reg128>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x32>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmovzxbw ANY [RM] r  [66] 30 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmovzxbw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','z','x','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pmovzxbw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmovzxbw<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x30>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmovzxbw<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x30>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmovzxdq ANY [RM] r  [66] 35 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmovzxdq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','z','x','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_pmovzxdq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmovzxdq<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x35>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmovzxdq<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x35>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmovzxwd ANY [RM] r  [66] 33 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmovzxwd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','z','x','w','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pmovzxwd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmovzxwd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x33>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmovzxwd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x33>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmovzxwq ANY [RM] r  [66] 34 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmovzxwq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','o','v','z','x','w','q', str...>, hold<T...>> {
    static constexpr auto value = asm_pmovzxwq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmovzxwq<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x34>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmovzxwq<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x34>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmuldq ANY [RM] r  [66] 28 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmuldq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','u','l','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_pmuldq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmuldq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x28>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmuldq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x28>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmulhrsw ANY [RM] r  [] 0B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmulhrsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','u','l','h','r','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pmulhrsw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmulhrsw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmulhrsw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmulhrsw ANY [RM] r  [66] 0B 

template<typename ...T, typename ...Y>
constexpr auto asm_pmulhrsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmulhrsw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmulhrw ANY [RM] r  [] B7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmulhrw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','u','l','h','r','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pmulhrw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmulhrw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB7>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmulhrw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB7>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmulhuw ANY [RM] r  [] E4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmulhuw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','u','l','h','u','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pmulhuw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmulhuw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE4>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmulhuw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE4>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmulhuw ANY [RM] r  [66] E4 

template<typename ...T, typename ...Y>
constexpr auto asm_pmulhuw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE4>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmulhuw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE4>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmulhw ANY [RM] r  [] E5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmulhw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','u','l','h','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pmulhw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmulhw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE5>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmulhw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE5>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmulhw ANY [RM] r  [66] E5 

template<typename ...T, typename ...Y>
constexpr auto asm_pmulhw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE5>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmulhw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE5>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmulld ANY [RM] r  [66] 40 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmulld = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','u','l','l','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pmulld<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmulld<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x40>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmulld<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x40>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmullw ANY [RM] r  [] D5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmullw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','u','l','l','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pmullw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmullw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD5>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmullw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD5>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmullw ANY [RM] r  [66] D5 

template<typename ...T, typename ...Y>
constexpr auto asm_pmullw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD5>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmullw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD5>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmuludq ANY [RM] r  [] F4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pmuludq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','m','u','l','u','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_pmuludq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pmuludq<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF4>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmuludq<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF4>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pmuludq ANY [RM] r  [66] F4 

template<typename ...T, typename ...Y>
constexpr auto asm_pmuludq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF4>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pmuludq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF4>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pop ANY [M] 0  [66] 8F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pop = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','o','p', str...>, hold<T...>> {
    static constexpr auto value = asm_pop<T...>;
};
template<typename ...T>
constexpr auto asm_pop<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x8F>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_pop<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x8F>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  pop X86 [M] 0  [] 8F 

template<typename ...T>
constexpr auto asm_pop<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x8F>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_pop<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x8F>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  pop X64 [M] 0  [] 8F 

template<typename ...T>
constexpr auto asm_pop<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x8F>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_pop<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x8F>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  pop ANY [O]   [66] 58 

//  pop X86 [O]   [] 58 

//  pop X64 [O]   [] 58 

//  popa X86 [NONE]   [66] 61 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_popa = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','o','p','a', str...>, hold<T...>> {
    static constexpr auto value = asm_popa<T...>;
};
template <>
constexpr auto asm_popa<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0x61>>>::value;
//  popad X86 [NONE]   [] 61 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_popad = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','o','p','a','d', str...>, hold<T...>> {
    static constexpr auto value = asm_popad<T...>;
};
template <>
constexpr auto asm_popad<> = seq_to_arr<expand_byte_seq_v< byte_seq<0x61>>>::value;
//  popcnt ANY [RM] r  [66F3] B8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_popcnt = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','o','p','c','n','t', str...>, hold<T...>> {
    static constexpr auto value = asm_popcnt<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_popcnt<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66, 0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB8>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_popcnt<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66, 0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB8>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  popcnt ANY [RM] r  [F3] B8 

template<typename ...T, typename ...Y>
constexpr auto asm_popcnt<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB8>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_popcnt<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB8>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  popcnt X64 [RM] r  [F3] B8 

template<typename ...T, typename ...Y>
constexpr auto asm_popcnt<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB8>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_popcnt<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB8>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  popf ANY [NONE]   [66] 9D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_popf = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','o','p','f', str...>, hold<T...>> {
    static constexpr auto value = asm_popf<T...>;
};
template <>
constexpr auto asm_popf<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0x9D>>>::value;
//  popfd X86 [NONE]   [] 9D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_popfd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','o','p','f','d', str...>, hold<T...>> {
    static constexpr auto value = asm_popfd<T...>;
};
template <>
constexpr auto asm_popfd<> = seq_to_arr<expand_byte_seq_v< byte_seq<0x9D>>>::value;
//  popfq X64 [NONE]   [] 9D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_popfq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','o','p','f','q', str...>, hold<T...>> {
    static constexpr auto value = asm_popfq<T...>;
};
template <>
constexpr auto asm_popfq<> = seq_to_arr<expand_byte_seq_v< byte_seq<0x9D>>>::value;
//  por ANY [RM] r  [] EB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_por = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','o','r', str...>, hold<T...>> {
    static constexpr auto value = asm_por<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_por<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEB>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_por<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEB>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  por ANY [RM] r  [66] EB 

template<typename ...T, typename ...Y>
constexpr auto asm_por<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEB>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_por<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEB>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  prefetch ANY [M] 0  [] 0D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_prefetch = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','r','e','f','e','t','c','h', str...>, hold<T...>> {
    static constexpr auto value = asm_prefetch<T...>;
};
template<typename ...T>
constexpr auto asm_prefetch<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x0D>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  prefetchnta ANY [M] 0  [] 18 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_prefetchnta = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','r','e','f','e','t','c','h','n','t','a', str...>, hold<T...>> {
    static constexpr auto value = asm_prefetchnta<T...>;
};
template<typename ...T>
constexpr auto asm_prefetchnta<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x18>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  prefetcht0 ANY [M] 1  [] 18 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_prefetcht0 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','r','e','f','e','t','c','h','t','0', str...>, hold<T...>> {
    static constexpr auto value = asm_prefetcht0<T...>;
};
template<typename ...T>
constexpr auto asm_prefetcht0<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x18>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  prefetcht1 ANY [M] 2  [] 18 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_prefetcht1 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','r','e','f','e','t','c','h','t','1', str...>, hold<T...>> {
    static constexpr auto value = asm_prefetcht1<T...>;
};
template<typename ...T>
constexpr auto asm_prefetcht1<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x18>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  prefetcht2 ANY [M] 3  [] 18 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_prefetcht2 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','r','e','f','e','t','c','h','t','2', str...>, hold<T...>> {
    static constexpr auto value = asm_prefetcht2<T...>;
};
template<typename ...T>
constexpr auto asm_prefetcht2<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x18>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  prefetchw ANY [M] 1  [] 0D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_prefetchw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','r','e','f','e','t','c','h','w', str...>, hold<T...>> {
    static constexpr auto value = asm_prefetchw<T...>;
};
template<typename ...T>
constexpr auto asm_prefetchw<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x0D>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  prefetchwt1 ANY [M] 2  [] 0D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_prefetchwt1 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','r','e','f','e','t','c','h','w','t','1', str...>, hold<T...>> {
    static constexpr auto value = asm_prefetchwt1<T...>;
};
template<typename ...T>
constexpr auto asm_prefetchwt1<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x0D>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  psadbw ANY [RM] r  [] F6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psadbw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','a','d','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_psadbw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_psadbw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psadbw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psadbw ANY [RM] r  [66] F6 

template<typename ...T, typename ...Y>
constexpr auto asm_psadbw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psadbw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pshufb ANY [RM] r  [] 00 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pshufb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','h','u','f','b', str...>, hold<T...>> {
    static constexpr auto value = asm_pshufb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pshufb<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pshufb<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x00>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pshufb ANY [RM] r  [66] 00 

template<typename ...T, typename ...Y>
constexpr auto asm_pshufb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pshufb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x00>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pshufd ANY [RMI] r  [66] 70 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pshufd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','h','u','f','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pshufd<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pshufd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pshufd<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x70>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  pshufhw ANY [RMI] r  [F3] 70 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pshufhw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','h','u','f','h','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pshufhw<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pshufhw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pshufhw<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x70>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  pshuflw ANY [RMI] r  [F2] 70 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pshuflw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','h','u','f','l','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pshuflw<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pshuflw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pshuflw<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x70>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  pshufw ANY [RMI] r  [] 70 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pshufw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','h','u','f','w', str...>, hold<T...>> {
    static constexpr auto value = asm_pshufw<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pshufw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_pshufw<zip<mmx>::with<T...>, ptr<reg64, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x70>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  psignb ANY [RM] r  [] 08 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psignb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','i','g','n','b', str...>, hold<T...>> {
    static constexpr auto value = asm_psignb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_psignb<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x08>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psignb<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x08>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psignb ANY [RM] r  [66] 08 

template<typename ...T, typename ...Y>
constexpr auto asm_psignb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x08>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psignb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x08>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psignd ANY [RM] r  [] 0A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psignd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','i','g','n','d', str...>, hold<T...>> {
    static constexpr auto value = asm_psignd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_psignd<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psignd<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psignd ANY [RM] r  [66] 0A 

template<typename ...T, typename ...Y>
constexpr auto asm_psignd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psignd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psignw ANY [RM] r  [] 09 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psignw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','i','g','n','w', str...>, hold<T...>> {
    static constexpr auto value = asm_psignw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_psignw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x09>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psignw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x09>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psignw ANY [RM] r  [66] 09 

template<typename ...T, typename ...Y>
constexpr auto asm_psignw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x09>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psignw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x09>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pslld ANY [MI] 6  [] 72 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pslld = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','l','l','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pslld<T...>;
};
//  pslld ANY [RM] r  [] F2 

template<typename ...T, typename ...Y>
constexpr auto asm_pslld<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF2>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pslld<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF2>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pslld ANY [MI] 6  [66] 72 

//  pslld ANY [RM] r  [66] F2 

template<typename ...T, typename ...Y>
constexpr auto asm_pslld<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF2>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pslld<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF2>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pslldq ANY [MI] 7  [66] 73 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pslldq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','l','l','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_pslldq<T...>;
};
//  psllq ANY [MI] 6  [] 73 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psllq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','l','l','q', str...>, hold<T...>> {
    static constexpr auto value = asm_psllq<T...>;
};
//  psllq ANY [RM] r  [] F3 

template<typename ...T, typename ...Y>
constexpr auto asm_psllq<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF3>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psllq<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF3>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psllq ANY [MI] 6  [66] 73 

//  psllq ANY [RM] r  [66] F3 

template<typename ...T, typename ...Y>
constexpr auto asm_psllq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF3>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psllq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF3>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psllw ANY [MI] 6  [] 71 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psllw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','l','l','w', str...>, hold<T...>> {
    static constexpr auto value = asm_psllw<T...>;
};
//  psllw ANY [RM] r  [] F1 

template<typename ...T, typename ...Y>
constexpr auto asm_psllw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF1>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psllw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF1>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psllw ANY [MI] 6  [66] 71 

//  psllw ANY [RM] r  [66] F1 

template<typename ...T, typename ...Y>
constexpr auto asm_psllw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF1>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psllw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF1>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psmash X64 [NONE]   [F3] FF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psmash = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','m','a','s','h', str...>, hold<T...>> {
    static constexpr auto value = asm_psmash<T...>;
};
template <>
constexpr auto asm_psmash<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x01>,  byte_seq<0xFF>>>::value;
//  psrad ANY [MI] 4  [] 72 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psrad = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','r','a','d', str...>, hold<T...>> {
    static constexpr auto value = asm_psrad<T...>;
};
//  psrad ANY [RM] r  [] E2 

template<typename ...T, typename ...Y>
constexpr auto asm_psrad<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE2>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psrad<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE2>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psrad ANY [MI] 4  [66] 72 

//  psrad ANY [RM] r  [66] E2 

template<typename ...T, typename ...Y>
constexpr auto asm_psrad<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE2>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psrad<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE2>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psraw ANY [MI] 4  [] 71 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psraw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','r','a','w', str...>, hold<T...>> {
    static constexpr auto value = asm_psraw<T...>;
};
//  psraw ANY [RM] r  [] E1 

template<typename ...T, typename ...Y>
constexpr auto asm_psraw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE1>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psraw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE1>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psraw ANY [MI] 4  [66] 71 

//  psraw ANY [RM] r  [66] E1 

template<typename ...T, typename ...Y>
constexpr auto asm_psraw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE1>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psraw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE1>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psrld ANY [MI] 2  [] 72 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psrld = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','r','l','d', str...>, hold<T...>> {
    static constexpr auto value = asm_psrld<T...>;
};
//  psrld ANY [RM] r  [] D2 

template<typename ...T, typename ...Y>
constexpr auto asm_psrld<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psrld<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD2>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psrld ANY [MI] 2  [66] 72 

//  psrld ANY [RM] r  [66] D2 

template<typename ...T, typename ...Y>
constexpr auto asm_psrld<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psrld<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD2>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psrldq ANY [MI] 3  [66] 73 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psrldq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','r','l','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_psrldq<T...>;
};
//  psrlq ANY [MI] 2  [] 73 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psrlq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','r','l','q', str...>, hold<T...>> {
    static constexpr auto value = asm_psrlq<T...>;
};
//  psrlq ANY [RM] r  [] D3 

template<typename ...T, typename ...Y>
constexpr auto asm_psrlq<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psrlq<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD3>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psrlq ANY [MI] 2  [66] 73 

//  psrlq ANY [RM] r  [66] D3 

template<typename ...T, typename ...Y>
constexpr auto asm_psrlq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psrlq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD3>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psrlw ANY [MI] 2  [] 71 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psrlw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','r','l','w', str...>, hold<T...>> {
    static constexpr auto value = asm_psrlw<T...>;
};
//  psrlw ANY [RM] r  [] D1 

template<typename ...T, typename ...Y>
constexpr auto asm_psrlw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psrlw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD1>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psrlw ANY [MI] 2  [66] 71 

//  psrlw ANY [RM] r  [66] D1 

template<typename ...T, typename ...Y>
constexpr auto asm_psrlw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psrlw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD1>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psubb ANY [RM] r  [] F8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psubb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','u','b','b', str...>, hold<T...>> {
    static constexpr auto value = asm_psubb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_psubb<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF8>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psubb<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF8>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psubb ANY [RM] r  [66] F8 

template<typename ...T, typename ...Y>
constexpr auto asm_psubb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF8>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psubb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF8>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psubd ANY [RM] r  [] FA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psubd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','u','b','d', str...>, hold<T...>> {
    static constexpr auto value = asm_psubd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_psubd<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFA>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psubd<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFA>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psubd ANY [RM] r  [66] FA 

template<typename ...T, typename ...Y>
constexpr auto asm_psubd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFA>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psubd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFA>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psubq ANY [RM] r  [] FB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psubq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','u','b','q', str...>, hold<T...>> {
    static constexpr auto value = asm_psubq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_psubq<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFB>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psubq<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFB>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psubq ANY [RM] r  [66] FB 

template<typename ...T, typename ...Y>
constexpr auto asm_psubq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFB>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psubq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFB>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psubsb ANY [RM] r  [] E8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psubsb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','u','b','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_psubsb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_psubsb<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE8>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psubsb<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE8>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psubsb ANY [RM] r  [66] E8 

template<typename ...T, typename ...Y>
constexpr auto asm_psubsb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE8>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psubsb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE8>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psubsw ANY [RM] r  [] E9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psubsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','u','b','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_psubsw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_psubsw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE9>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psubsw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE9>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psubsw ANY [RM] r  [66] E9 

template<typename ...T, typename ...Y>
constexpr auto asm_psubsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xE9>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psubsw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xE9>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psubusb ANY [RM] r  [] D8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psubusb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','u','b','u','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_psubusb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_psubusb<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psubusb<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD8>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psubusb ANY [RM] r  [66] D8 

template<typename ...T, typename ...Y>
constexpr auto asm_psubusb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD8>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psubusb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD8>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psubusw ANY [RM] r  [] D9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psubusw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','u','b','u','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_psubusw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_psubusw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD9>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psubusw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD9>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psubusw ANY [RM] r  [66] D9 

template<typename ...T, typename ...Y>
constexpr auto asm_psubusw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xD9>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psubusw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xD9>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psubw ANY [RM] r  [] F9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_psubw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','u','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_psubw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_psubw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF9>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psubw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF9>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  psubw ANY [RM] r  [66] F9 

template<typename ...T, typename ...Y>
constexpr auto asm_psubw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xF9>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_psubw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xF9>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pswapd ANY [RM] r  [] BB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pswapd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','s','w','a','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pswapd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pswapd<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBB>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pswapd<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBB>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  ptest ANY [RM] r  [66] 17 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_ptest = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','t','e','s','t', str...>, hold<T...>> {
    static constexpr auto value = asm_ptest<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_ptest<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x17>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_ptest<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x17>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  ptwrite ANY [M] 4  [F3] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_ptwrite = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','t','w','r','i','t','e', str...>, hold<T...>> {
    static constexpr auto value = asm_ptwrite<T...>;
};
template<typename ...T>
constexpr auto asm_ptwrite<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ptwrite<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  ptwrite X64 [M] 4  [F3] AE 

template<typename ...T>
constexpr auto asm_ptwrite<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ptwrite<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  punpckhbw ANY [RM] r  [] 68 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_punpckhbw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','n','p','c','k','h','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_punpckhbw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_punpckhbw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x68>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_punpckhbw<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x68>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  punpckhbw ANY [RM] r  [66] 68 

template<typename ...T, typename ...Y>
constexpr auto asm_punpckhbw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x68>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_punpckhbw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x68>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  punpckhdq ANY [RM] r  [] 6A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_punpckhdq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','n','p','c','k','h','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_punpckhdq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_punpckhdq<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_punpckhdq<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  punpckhdq ANY [RM] r  [66] 6A 

template<typename ...T, typename ...Y>
constexpr auto asm_punpckhdq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_punpckhdq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  punpckhqdq ANY [RM] r  [66] 6D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_punpckhqdq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','n','p','c','k','h','q','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_punpckhqdq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_punpckhqdq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_punpckhqdq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  punpckhwd ANY [RM] r  [] 69 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_punpckhwd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','n','p','c','k','h','w','d', str...>, hold<T...>> {
    static constexpr auto value = asm_punpckhwd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_punpckhwd<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x69>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_punpckhwd<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x69>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  punpckhwd ANY [RM] r  [66] 69 

template<typename ...T, typename ...Y>
constexpr auto asm_punpckhwd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x69>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_punpckhwd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x69>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  punpcklbw ANY [RM] r  [] 60 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_punpcklbw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','n','p','c','k','l','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_punpcklbw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_punpcklbw<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x60>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_punpcklbw<zip<mmx>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x60>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  punpcklbw ANY [RM] r  [66] 60 

template<typename ...T, typename ...Y>
constexpr auto asm_punpcklbw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x60>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_punpcklbw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x60>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  punpckldq ANY [RM] r  [] 62 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_punpckldq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','n','p','c','k','l','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_punpckldq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_punpckldq<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x62>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_punpckldq<zip<mmx>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x62>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  punpckldq ANY [RM] r  [66] 62 

template<typename ...T, typename ...Y>
constexpr auto asm_punpckldq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x62>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_punpckldq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x62>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  punpcklqdq ANY [RM] r  [66] 6C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_punpcklqdq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','n','p','c','k','l','q','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_punpcklqdq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_punpcklqdq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x6C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_punpcklqdq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x6C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  punpcklwd ANY [RM] r  [] 61 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_punpcklwd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','n','p','c','k','l','w','d', str...>, hold<T...>> {
    static constexpr auto value = asm_punpcklwd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_punpcklwd<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x61>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_punpcklwd<zip<mmx>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x61>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  punpcklwd ANY [RM] r  [66] 61 

template<typename ...T, typename ...Y>
constexpr auto asm_punpcklwd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x61>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_punpcklwd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x61>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  push ANY [M] 6  [66] FF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_push = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','s','h', str...>, hold<T...>> {
    static constexpr auto value = asm_push<T...>;
};
template<typename ...T>
constexpr auto asm_push<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

template<typename ...T>
constexpr auto asm_push<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  push X86 [M] 6  [] FF 

template<typename ...T>
constexpr auto asm_push<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

template<typename ...T>
constexpr auto asm_push<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  push X64 [M] 6  [] FF 

template<typename ...T>
constexpr auto asm_push<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

template<typename ...T>
constexpr auto asm_push<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xFF>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  push ANY [O]   [66] 50 

//  push X86 [O]   [] 50 

//  push X64 [O]   [] 50 

//  push ANY [I]   [] 6A 

template <uint8_t T> 
constexpr auto asm_push<ib<T>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x6A>, typename ib<T>::value>>::value;
//  push ANY [I]   [66] 68 

template <uint16_t T> 
constexpr auto asm_push<iw<T>> =
    seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0x68>, typename iw<T>::value>>::value;
//  push X86 [I]   [] 68 

template <uint32_t T> 
constexpr auto asm_push<disp32<T>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x68>, typename disp32<T>::value>>::value;
//  push X64 [I]   [] 68 

template <uint32_t T> 
constexpr auto asm_push<id<T>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x68>, typename id<T>::value>>::value;
//  pusha X86 [NONE]   [66] 60 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pusha = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','s','h','a', str...>, hold<T...>> {
    static constexpr auto value = asm_pusha<T...>;
};
template <>
constexpr auto asm_pusha<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0x60>>>::value;
//  pushad X86 [NONE]   [] 60 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pushad = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','s','h','a','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pushad<T...>;
};
template <>
constexpr auto asm_pushad<> = seq_to_arr<expand_byte_seq_v< byte_seq<0x60>>>::value;
//  pushf ANY [NONE]   [66] 9C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pushf = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','s','h','f', str...>, hold<T...>> {
    static constexpr auto value = asm_pushf<T...>;
};
template <>
constexpr auto asm_pushf<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0x9C>>>::value;
//  pushfd X86 [NONE]   [] 9C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pushfd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','s','h','f','d', str...>, hold<T...>> {
    static constexpr auto value = asm_pushfd<T...>;
};
template <>
constexpr auto asm_pushfd<> = seq_to_arr<expand_byte_seq_v< byte_seq<0x9C>>>::value;
//  pushfq X64 [NONE]   [] 9C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pushfq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','u','s','h','f','q', str...>, hold<T...>> {
    static constexpr auto value = asm_pushfq<T...>;
};
template <>
constexpr auto asm_pushfq<> = seq_to_arr<expand_byte_seq_v< byte_seq<0x9C>>>::value;
//  pvalidate ANY [NONE]   [F2] FF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pvalidate = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','v','a','l','i','d','a','t','e', str...>, hold<T...>> {
    static constexpr auto value = asm_pvalidate<T...>;
};
template <>
constexpr auto asm_pvalidate<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x01>,  byte_seq<0xFF>>>::value;
//  pxor ANY [RM] r  [] EF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_pxor = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'p','x','o','r', str...>, hold<T...>> {
    static constexpr auto value = asm_pxor<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_pxor<zip<mmx>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEF>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pxor<zip<mmx>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEF>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  pxor ANY [RM] r  [66] EF 

template<typename ...T, typename ...Y>
constexpr auto asm_pxor<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xEF>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_pxor<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xEF>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  rcl ANY [M] 2  [] D0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rcl = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','c','l', str...>, hold<T...>> {
    static constexpr auto value = asm_rcl<T...>;
};
template<typename ...T>
constexpr auto asm_rcl<zip<reg8>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rcl<ptr<reg8, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD0>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  rcl ANY [M] 2  [] D2 

template<typename ...T>
constexpr auto asm_rcl<zip<reg8>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rcl<ptr<reg8, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD2>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  rcl ANY [MI] 2  [] C0 

template<typename ...T, uint8_t Y>
constexpr auto asm_rcl<ptr<reg8, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC0>, typename mrm<T...>::template value<hold<reg<2>>>, typename disp8<Y>::value>>::value;

//  rcl ANY [M] 2  [66] D1 

template<typename ...T>
constexpr auto asm_rcl<zip<reg16>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rcl<ptr<reg16, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  rcl ANY [M] 2  [66] D3 

template<typename ...T>
constexpr auto asm_rcl<zip<reg16>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rcl<ptr<reg16, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  rcl ANY [MI] 2  [66] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_rcl<ptr<reg16, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<2>>>, typename disp8<Y>::value>>::value;

//  rcl ANY [M] 2  [] D1 

template<typename ...T>
constexpr auto asm_rcl<zip<reg32>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rcl<ptr<reg32, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  rcl ANY [M] 2  [] D3 

template<typename ...T>
constexpr auto asm_rcl<zip<reg32>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rcl<ptr<reg32, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  rcl ANY [MI] 2  [] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_rcl<ptr<reg32, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<2>>>, typename disp8<Y>::value>>::value;

//  rcl X64 [M] 2  [] D1 

template<typename ...T>
constexpr auto asm_rcl<zip<reg64>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rcl<ptr<reg64, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  rcl X64 [M] 2  [] D3 

template<typename ...T>
constexpr auto asm_rcl<zip<reg64>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rcl<ptr<reg64, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  rcl X64 [MI] 2  [] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_rcl<ptr<reg64, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<2>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<2>>>, typename disp8<Y>::value>>::value;

//  rcpps ANY [RM] r  [] 53 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rcpps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','c','p','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_rcpps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_rcpps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x53>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_rcpps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x53>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  rcpss ANY [RM] r  [F3] 53 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rcpss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','c','p','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_rcpss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_rcpss<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x53>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_rcpss<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x53>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  rcr ANY [M] 3  [] D0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rcr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','c','r', str...>, hold<T...>> {
    static constexpr auto value = asm_rcr<T...>;
};
template<typename ...T>
constexpr auto asm_rcr<zip<reg8>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rcr<ptr<reg8, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD0>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  rcr ANY [M] 3  [] D2 

template<typename ...T>
constexpr auto asm_rcr<zip<reg8>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rcr<ptr<reg8, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD2>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  rcr ANY [MI] 3  [] C0 

template<typename ...T, uint8_t Y>
constexpr auto asm_rcr<ptr<reg8, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC0>, typename mrm<T...>::template value<hold<reg<3>>>, typename disp8<Y>::value>>::value;

//  rcr ANY [M] 3  [66] D1 

template<typename ...T>
constexpr auto asm_rcr<zip<reg16>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rcr<ptr<reg16, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  rcr ANY [M] 3  [66] D3 

template<typename ...T>
constexpr auto asm_rcr<zip<reg16>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rcr<ptr<reg16, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  rcr ANY [MI] 3  [66] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_rcr<ptr<reg16, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<3>>>, typename disp8<Y>::value>>::value;

//  rcr ANY [M] 3  [] D1 

template<typename ...T>
constexpr auto asm_rcr<zip<reg32>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rcr<ptr<reg32, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  rcr ANY [M] 3  [] D3 

template<typename ...T>
constexpr auto asm_rcr<zip<reg32>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rcr<ptr<reg32, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  rcr ANY [MI] 3  [] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_rcr<ptr<reg32, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<3>>>, typename disp8<Y>::value>>::value;

//  rcr X64 [M] 3  [] D1 

template<typename ...T>
constexpr auto asm_rcr<zip<reg64>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rcr<ptr<reg64, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  rcr X64 [M] 3  [] D3 

template<typename ...T>
constexpr auto asm_rcr<zip<reg64>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rcr<ptr<reg64, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  rcr X64 [MI] 3  [] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_rcr<ptr<reg64, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<3>>>, typename disp8<Y>::value>>::value;

//  rdfsbase X64 [M] 0  [F3] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rdfsbase = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','f','s','b','a','s','e', str...>, hold<T...>> {
    static constexpr auto value = asm_rdfsbase<T...>;
};
template<typename ...T>
constexpr auto asm_rdfsbase<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

//  rdfsbase X64 [M] 0  [F3] AE 

template<typename ...T>
constexpr auto asm_rdfsbase<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

//  rdgsbase X64 [M] 1  [F3] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rdgsbase = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','g','s','b','a','s','e', str...>, hold<T...>> {
    static constexpr auto value = asm_rdgsbase<T...>;
};
template<typename ...T>
constexpr auto asm_rdgsbase<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

//  rdgsbase X64 [M] 1  [F3] AE 

template<typename ...T>
constexpr auto asm_rdgsbase<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

//  rdmsr ANY [NONE]   [] 32 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rdmsr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','m','s','r', str...>, hold<T...>> {
    static constexpr auto value = asm_rdmsr<T...>;
};
template <>
constexpr auto asm_rdmsr<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x32>>>::value;
//  rdpid X86 [R] 7  [F3] C7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rdpid = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','p','i','d', str...>, hold<T...>> {
    static constexpr auto value = asm_rdpid<T...>;
};
//  rdpid X64 [R] 7  [F3] C7 

//  rdpkru ANY [NONE]   [] EE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rdpkru = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','p','k','r','u', str...>, hold<T...>> {
    static constexpr auto value = asm_rdpkru<T...>;
};
template <>
constexpr auto asm_rdpkru<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xEE>>>::value;
//  rdpmc ANY [NONE]   [] 33 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rdpmc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','p','m','c', str...>, hold<T...>> {
    static constexpr auto value = asm_rdpmc<T...>;
};
template <>
constexpr auto asm_rdpmc<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x33>>>::value;
//  rdpru ANY [NONE]   [] FD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rdpru = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','p','r','u', str...>, hold<T...>> {
    static constexpr auto value = asm_rdpru<T...>;
};
template <>
constexpr auto asm_rdpru<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xFD>>>::value;
//  rdrand ANY [M] 6  [66] C7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rdrand = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','r','a','n','d', str...>, hold<T...>> {
    static constexpr auto value = asm_rdrand<T...>;
};
template<typename ...T>
constexpr auto asm_rdrand<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

//  rdrand ANY [M] 6  [] C7 

template<typename ...T>
constexpr auto asm_rdrand<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

//  rdrand X64 [M] 6  [] C7 

template<typename ...T>
constexpr auto asm_rdrand<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

//  rdseed ANY [M] 7  [66] C7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rdseed = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','s','e','e','d', str...>, hold<T...>> {
    static constexpr auto value = asm_rdseed<T...>;
};
template<typename ...T>
constexpr auto asm_rdseed<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

//  rdseed ANY [M] 7  [] C7 

template<typename ...T>
constexpr auto asm_rdseed<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

//  rdseed X64 [M] 7  [] C7 

template<typename ...T>
constexpr auto asm_rdseed<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

//  rdsspd ANY [M] 1  [F3] 1E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rdsspd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','s','s','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_rdsspd<T...>;
};
template<typename ...T>
constexpr auto asm_rdsspd<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x1E>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

//  rdsspq X64 [M] 1  [F3] 1E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rdsspq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','s','s','p','q', str...>, hold<T...>> {
    static constexpr auto value = asm_rdsspq<T...>;
};
template<typename ...T>
constexpr auto asm_rdsspq<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x1E>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

//  rdtsc ANY [NONE]   [] 31 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rdtsc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','t','s','c', str...>, hold<T...>> {
    static constexpr auto value = asm_rdtsc<T...>;
};
template <>
constexpr auto asm_rdtsc<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x31>>>::value;
//  rdtscp ANY [NONE]   [] F9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rdtscp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','d','t','s','c','p', str...>, hold<T...>> {
    static constexpr auto value = asm_rdtscp<T...>;
};
template <>
constexpr auto asm_rdtscp<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xF9>>>::value;
//  ret ANY [NONE]   [] C3 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_ret = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','e','t', str...>, hold<T...>> {
    static constexpr auto value = asm_ret<T...>;
};
template <>
constexpr auto asm_ret<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xC3>>>::value;
//  ret ANY [I]   [] C2 

template <uint16_t T> 
constexpr auto asm_ret<disp16<T>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0xC2>, typename disp16<T>::value>>::value;
//  retf ANY [NONE]   [] CB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_retf = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','e','t','f', str...>, hold<T...>> {
    static constexpr auto value = asm_retf<T...>;
};
template <>
constexpr auto asm_retf<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xCB>>>::value;
//  retf ANY [I]   [] CA 

template <uint16_t T> 
constexpr auto asm_retf<disp16<T>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0xCA>, typename disp16<T>::value>>::value;
//  rmpadjust X64 [NONE]   [F3] FE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rmpadjust = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','m','p','a','d','j','u','s','t', str...>, hold<T...>> {
    static constexpr auto value = asm_rmpadjust<T...>;
};
template <>
constexpr auto asm_rmpadjust<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x01>,  byte_seq<0xFE>>>::value;
//  rmpupdate X64 [NONE]   [F2] FE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rmpupdate = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','m','p','u','p','d','a','t','e', str...>, hold<T...>> {
    static constexpr auto value = asm_rmpupdate<T...>;
};
template <>
constexpr auto asm_rmpupdate<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x01>,  byte_seq<0xFE>>>::value;
//  rol ANY [M] 0  [] D0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rol = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','o','l', str...>, hold<T...>> {
    static constexpr auto value = asm_rol<T...>;
};
template<typename ...T>
constexpr auto asm_rol<zip<reg8>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rol<ptr<reg8, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD0>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  rol ANY [M] 0  [] D2 

template<typename ...T>
constexpr auto asm_rol<zip<reg8>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rol<ptr<reg8, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD2>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  rol ANY [MI] 0  [] C0 

template<typename ...T, uint8_t Y>
constexpr auto asm_rol<ptr<reg8, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC0>, typename mrm<T...>::template value<hold<reg<0>>>, typename disp8<Y>::value>>::value;

//  rol ANY [M] 0  [66] D1 

template<typename ...T>
constexpr auto asm_rol<zip<reg16>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rol<ptr<reg16, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  rol ANY [M] 0  [66] D3 

template<typename ...T>
constexpr auto asm_rol<zip<reg16>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rol<ptr<reg16, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  rol ANY [MI] 0  [66] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_rol<ptr<reg16, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<0>>>, typename disp8<Y>::value>>::value;

//  rol ANY [M] 0  [] D1 

template<typename ...T>
constexpr auto asm_rol<zip<reg32>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rol<ptr<reg32, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  rol ANY [M] 0  [] D3 

template<typename ...T>
constexpr auto asm_rol<zip<reg32>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rol<ptr<reg32, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  rol ANY [MI] 0  [] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_rol<ptr<reg32, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<0>>>, typename disp8<Y>::value>>::value;

//  rol X64 [M] 0  [] D1 

template<typename ...T>
constexpr auto asm_rol<zip<reg64>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rol<ptr<reg64, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  rol X64 [M] 0  [] D3 

template<typename ...T>
constexpr auto asm_rol<zip<reg64>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rol<ptr<reg64, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  rol X64 [MI] 0  [] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_rol<ptr<reg64, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<0>>>, typename disp8<Y>::value>>::value;

//  ror ANY [M] 1  [] D0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_ror = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','o','r', str...>, hold<T...>> {
    static constexpr auto value = asm_ror<T...>;
};
template<typename ...T>
constexpr auto asm_ror<zip<reg8>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ror<ptr<reg8, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD0>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  ror ANY [M] 1  [] D2 

template<typename ...T>
constexpr auto asm_ror<zip<reg8>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ror<ptr<reg8, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD2>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  ror ANY [MI] 1  [] C0 

template<typename ...T, uint8_t Y>
constexpr auto asm_ror<ptr<reg8, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC0>, typename mrm<T...>::template value<hold<reg<1>>>, typename disp8<Y>::value>>::value;

//  ror ANY [M] 1  [66] D1 

template<typename ...T>
constexpr auto asm_ror<zip<reg16>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ror<ptr<reg16, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  ror ANY [M] 1  [66] D3 

template<typename ...T>
constexpr auto asm_ror<zip<reg16>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ror<ptr<reg16, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  ror ANY [MI] 1  [66] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_ror<ptr<reg16, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<1>>>, typename disp8<Y>::value>>::value;

//  ror ANY [M] 1  [] D1 

template<typename ...T>
constexpr auto asm_ror<zip<reg32>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ror<ptr<reg32, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  ror ANY [M] 1  [] D3 

template<typename ...T>
constexpr auto asm_ror<zip<reg32>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ror<ptr<reg32, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  ror ANY [MI] 1  [] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_ror<ptr<reg32, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<1>>>, typename disp8<Y>::value>>::value;

//  ror X64 [M] 1  [] D1 

template<typename ...T>
constexpr auto asm_ror<zip<reg64>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ror<ptr<reg64, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  ror X64 [M] 1  [] D3 

template<typename ...T>
constexpr auto asm_ror<zip<reg64>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_ror<ptr<reg64, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  ror X64 [MI] 1  [] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_ror<ptr<reg64, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<1>>>, typename disp8<Y>::value>>::value;

//  rorx ANY [RMI] r  [F2] F0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rorx = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','o','r','x', str...>, hold<T...>> {
    static constexpr auto value = asm_rorx<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_rorx<zip<reg32>::with<T...>, zip<reg32>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_rorx<zip<reg32>::with<T...>, ptr<reg32, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF0>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  rorx X64 [RMI] r  [F2] F0 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_rorx<zip<reg64>::with<T...>, zip<reg64>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<1>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_rorx<zip<reg64>::with<T...>, ptr<reg64, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<1>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF0>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  roundpd ANY [RMI] r  [66] 09 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_roundpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','o','u','n','d','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_roundpd<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_roundpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x09>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_roundpd<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x09>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  roundps ANY [RMI] r  [66] 08 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_roundps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','o','u','n','d','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_roundps<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_roundps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x08>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_roundps<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x08>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  roundsd ANY [RMI] r  [66] 0B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_roundsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','o','u','n','d','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_roundsd<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_roundsd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0B>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_roundsd<zip<reg128>::with<T...>, ptr<reg64, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0B>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  roundss ANY [RMI] r  [66] 0A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_roundss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','o','u','n','d','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_roundss<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_roundss<zip<reg128>::with<T...>, zip<reg32>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x0A>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_roundss<zip<reg128>::with<T...>, ptr<reg32, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x0A>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  rsm X86 [NONE]   [] AA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rsm = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','s','m', str...>, hold<T...>> {
    static constexpr auto value = asm_rsm<T...>;
};
template <>
constexpr auto asm_rsm<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0xAA>>>::value;
//  rsqrtps ANY [RM] r  [] 52 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rsqrtps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','s','q','r','t','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_rsqrtps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_rsqrtps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x52>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_rsqrtps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x52>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  rsqrtss ANY [RM] r  [F3] 52 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rsqrtss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','s','q','r','t','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_rsqrtss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_rsqrtss<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x52>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_rsqrtss<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x52>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  rstorssp ANY [M] 5  [F3] 01 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_rstorssp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'r','s','t','o','r','s','s','p', str...>, hold<T...>> {
    static constexpr auto value = asm_rstorssp<T...>;
};
template<typename ...T>
constexpr auto asm_rstorssp<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x01>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_rstorssp<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  sahf ANY [NONE]   [] 9E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sahf = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','a','h','f', str...>, hold<T...>> {
    static constexpr auto value = asm_sahf<T...>;
};
template <>
constexpr auto asm_sahf<> = seq_to_arr<expand_byte_seq_v< byte_seq<0x9E>>>::value;
//  sal ANY [M] 4  [] D0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sal = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','a','l', str...>, hold<T...>> {
    static constexpr auto value = asm_sal<T...>;
};
template<typename ...T>
constexpr auto asm_sal<zip<reg8>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_sal<ptr<reg8, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD0>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  sal ANY [M] 4  [] D2 

template<typename ...T>
constexpr auto asm_sal<zip<reg8>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_sal<ptr<reg8, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD2>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  sal ANY [MI] 4  [] C0 

template<typename ...T, uint8_t Y>
constexpr auto asm_sal<ptr<reg8, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC0>, typename mrm<T...>::template value<hold<reg<4>>>, typename disp8<Y>::value>>::value;

//  sal ANY [M] 4  [66] D1 

template<typename ...T>
constexpr auto asm_sal<zip<reg16>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_sal<ptr<reg16, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  sal ANY [M] 4  [66] D3 

template<typename ...T>
constexpr auto asm_sal<zip<reg16>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_sal<ptr<reg16, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  sal ANY [MI] 4  [66] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_sal<ptr<reg16, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<4>>>, typename disp8<Y>::value>>::value;

//  sal ANY [M] 4  [] D1 

template<typename ...T>
constexpr auto asm_sal<zip<reg32>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_sal<ptr<reg32, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  sal ANY [M] 4  [] D3 

template<typename ...T>
constexpr auto asm_sal<zip<reg32>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_sal<ptr<reg32, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  sal ANY [MI] 4  [] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_sal<ptr<reg32, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<4>>>, typename disp8<Y>::value>>::value;

//  sal X64 [M] 4  [] D1 

template<typename ...T>
constexpr auto asm_sal<zip<reg64>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_sal<ptr<reg64, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  sal X64 [M] 4  [] D3 

template<typename ...T>
constexpr auto asm_sal<zip<reg64>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_sal<ptr<reg64, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  sal X64 [MI] 4  [] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_sal<ptr<reg64, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<4>>>, typename disp8<Y>::value>>::value;

//  sar ANY [M] 7  [] D0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sar = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','a','r', str...>, hold<T...>> {
    static constexpr auto value = asm_sar<T...>;
};
template<typename ...T>
constexpr auto asm_sar<zip<reg8>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_sar<ptr<reg8, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD0>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  sar ANY [M] 7  [] D2 

template<typename ...T>
constexpr auto asm_sar<zip<reg8>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_sar<ptr<reg8, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD2>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  sar ANY [MI] 7  [] C0 

template<typename ...T, uint8_t Y>
constexpr auto asm_sar<ptr<reg8, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC0>, typename mrm<T...>::template value<hold<reg<7>>>, typename disp8<Y>::value>>::value;

//  sar ANY [M] 7  [66] D1 

template<typename ...T>
constexpr auto asm_sar<zip<reg16>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_sar<ptr<reg16, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  sar ANY [M] 7  [66] D3 

template<typename ...T>
constexpr auto asm_sar<zip<reg16>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_sar<ptr<reg16, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  sar ANY [MI] 7  [66] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_sar<ptr<reg16, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<7>>>, typename disp8<Y>::value>>::value;

//  sar ANY [M] 7  [] D1 

template<typename ...T>
constexpr auto asm_sar<zip<reg32>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_sar<ptr<reg32, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  sar ANY [M] 7  [] D3 

template<typename ...T>
constexpr auto asm_sar<zip<reg32>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_sar<ptr<reg32, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  sar ANY [MI] 7  [] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_sar<ptr<reg32, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<7>>>, typename disp8<Y>::value>>::value;

//  sar X64 [M] 7  [] D1 

template<typename ...T>
constexpr auto asm_sar<zip<reg64>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_sar<ptr<reg64, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  sar X64 [M] 7  [] D3 

template<typename ...T>
constexpr auto asm_sar<zip<reg64>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_sar<ptr<reg64, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  sar X64 [MI] 7  [] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_sar<ptr<reg64, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<7>>>, typename disp8<Y>::value>>::value;

//  sarx ANY [RMV] r  [F3] F7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sarx = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','a','r','x', str...>, hold<T...>> {
    static constexpr auto value = asm_sarx<T...>;
};
//  sarx X64 [RMV] r  [F3] F7 

//  saveprevssp ANY [NONE]   [F3] EA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_saveprevssp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','a','v','e','p','r','e','v','s','s','p', str...>, hold<T...>> {
    static constexpr auto value = asm_saveprevssp<T...>;
};
template <>
constexpr auto asm_saveprevssp<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x01>,  byte_seq<0xEA>>>::value;
//  sbb ANY [I]   [] 1C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sbb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','b','b', str...>, hold<T...>> {
    static constexpr auto value = asm_sbb<T...>;
};
template <uint8_t Y> 
constexpr auto asm_sbb<al, disp8<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x1C>, typename disp8<Y>::value>>::value;
//  sbb ANY [I]   [66] 1D 

template <uint16_t Y> 
constexpr auto asm_sbb<ax, disp16<Y>> =
    seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0x1D>, typename disp16<Y>::value>>::value;
//  sbb ANY [I]   [] 1D 

template <uint32_t Y> 
constexpr auto asm_sbb<eax, disp32<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x1D>, typename disp32<Y>::value>>::value;
//  sbb X64 [I]   [] 1D 

template <uint32_t Y> 
constexpr auto asm_sbb<rax, id<Y>> =
    seq_to_arr<expand_byte_seq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x1D>, typename id<Y>::value>>::value;
//  sbb ANY [MI] 3  [] 80 

template<typename ...T, uint8_t Y>
constexpr auto asm_sbb<ptr<reg8, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x80>, typename mrm<T...>::template value<hold<reg<3>>>, typename disp8<Y>::value>>::value;

//  sbb ANY [MI] 3  [66] 81 

template<typename ...T, uint16_t Y>
constexpr auto asm_sbb<ptr<reg16, T...>, disp16<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<3>>>, typename disp16<Y>::value>>::value;

//  sbb ANY [MI] 3  [] 81 

template<typename ...T, uint32_t Y>
constexpr auto asm_sbb<ptr<reg32, T...>, disp32<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<3>>>, typename disp32<Y>::value>>::value;

//  sbb X64 [MI] 3  [] 81 

template<typename ...T, uint32_t Y>
constexpr auto asm_sbb<ptr<reg64, T...>, id<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<3>>>, typename id<Y>::value>>::value;

//  sbb ANY [MI] 3  [66] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_sbb<ptr<reg16, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<3>>>, typename ib<Y>::value>>::value;

//  sbb ANY [MI] 3  [] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_sbb<ptr<reg32, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<3>>>, typename ib<Y>::value>>::value;

//  sbb X64 [MI] 3  [] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_sbb<ptr<reg64, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<3>>>, typename ib<Y>::value>>::value;

//  sbb ANY [MR] r  [] 18 

template<typename ...T, typename ...Y>
constexpr auto asm_sbb<ptr<reg8, T...>, zip<reg8>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x18>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  sbb ANY [MR] r  [66] 19 

template<typename ...T, typename ...Y>
constexpr auto asm_sbb<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x19>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  sbb ANY [MR] r  [] 19 

template<typename ...T, typename ...Y>
constexpr auto asm_sbb<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x19>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  sbb X64 [MR] r  [] 19 

template<typename ...T, typename ...Y>
constexpr auto asm_sbb<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x19>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  sbb ANY [RM] r  [] 1A 

template<typename ...T, typename ...Y>
constexpr auto asm_sbb<zip<reg8>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_sbb<zip<reg8>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  sbb ANY [RM] r  [66] 1B 

template<typename ...T, typename ...Y>
constexpr auto asm_sbb<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_sbb<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  sbb ANY [RM] r  [] 1B 

template<typename ...T, typename ...Y>
constexpr auto asm_sbb<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_sbb<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  sbb X64 [RM] r  [] 1B 

template<typename ...T, typename ...Y>
constexpr auto asm_sbb<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x1B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_sbb<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x1B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  scasb ANY [NONE]   [] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_scasb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','c','a','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_scasb<T...>;
};
template <>
constexpr auto asm_scasb<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xAE>>>::value;
//  scasd ANY [NONE]   [] AF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_scasd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','c','a','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_scasd<T...>;
};
template <>
constexpr auto asm_scasd<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xAF>>>::value;
//  scasq X64 [NONE]   [] AF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_scasq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','c','a','s','q', str...>, hold<T...>> {
    static constexpr auto value = asm_scasq<T...>;
};
template <>
constexpr auto asm_scasq<> = seq_to_arr<expand_byte_seq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0xAF>>>::value;
//  scasw ANY [NONE]   [66] AF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_scasw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','c','a','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_scasw<T...>;
};
template <>
constexpr auto asm_scasw<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0xAF>>>::value;
//  seamcall ANY [NONE]   [66] CF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_seamcall = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','a','m','c','a','l','l', str...>, hold<T...>> {
    static constexpr auto value = asm_seamcall<T...>;
};
template <>
constexpr auto asm_seamcall<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x01>,  byte_seq<0xCF>>>::value;
//  seamops ANY [NONE]   [66] CE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_seamops = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','a','m','o','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_seamops<T...>;
};
template <>
constexpr auto asm_seamops<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x01>,  byte_seq<0xCE>>>::value;
//  seamret ANY [NONE]   [66] CD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_seamret = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','a','m','r','e','t', str...>, hold<T...>> {
    static constexpr auto value = asm_seamret<T...>;
};
template <>
constexpr auto asm_seamret<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x01>,  byte_seq<0xCD>>>::value;
//  senduipi X64 [R] 6  [F3] C7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_senduipi = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','n','d','u','i','p','i', str...>, hold<T...>> {
    static constexpr auto value = asm_senduipi<T...>;
};
//  serialize ANY [NONE]   [] E8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_serialize = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','r','i','a','l','i','z','e', str...>, hold<T...>> {
    static constexpr auto value = asm_serialize<T...>;
};
template <>
constexpr auto asm_serialize<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xE8>>>::value;
//  seta ANY [M] r  [] 97 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_seta = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','a', str...>, hold<T...>> {
    static constexpr auto value = asm_seta<T...>;
};
template<typename ...T>
constexpr auto asm_seta<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x97>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_seta<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x97>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setae ANY [M] r  [] 93 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setae = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','a','e', str...>, hold<T...>> {
    static constexpr auto value = asm_setae<T...>;
};
template<typename ...T>
constexpr auto asm_setae<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x93>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setae<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x93>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setb ANY [M] r  [] 92 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','b', str...>, hold<T...>> {
    static constexpr auto value = asm_setb<T...>;
};
template<typename ...T>
constexpr auto asm_setb<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x92>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setb<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x92>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setbe ANY [M] r  [] 96 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setbe = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','b','e', str...>, hold<T...>> {
    static constexpr auto value = asm_setbe<T...>;
};
template<typename ...T>
constexpr auto asm_setbe<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x96>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setbe<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x96>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setc ANY [M] r  [] 92 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','c', str...>, hold<T...>> {
    static constexpr auto value = asm_setc<T...>;
};
template<typename ...T>
constexpr auto asm_setc<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x92>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setc<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x92>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  sete ANY [M] r  [] 94 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sete = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','e', str...>, hold<T...>> {
    static constexpr auto value = asm_sete<T...>;
};
template<typename ...T>
constexpr auto asm_sete<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x94>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_sete<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x94>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setg ANY [M] r  [] 9F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setg = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','g', str...>, hold<T...>> {
    static constexpr auto value = asm_setg<T...>;
};
template<typename ...T>
constexpr auto asm_setg<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9F>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setg<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9F>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setge ANY [M] r  [] 9D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setge = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','g','e', str...>, hold<T...>> {
    static constexpr auto value = asm_setge<T...>;
};
template<typename ...T>
constexpr auto asm_setge<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9D>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setge<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9D>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setl ANY [M] r  [] 9C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setl = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','l', str...>, hold<T...>> {
    static constexpr auto value = asm_setl<T...>;
};
template<typename ...T>
constexpr auto asm_setl<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9C>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setl<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9C>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setle ANY [M] r  [] 9E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setle = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','l','e', str...>, hold<T...>> {
    static constexpr auto value = asm_setle<T...>;
};
template<typename ...T>
constexpr auto asm_setle<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9E>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setle<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9E>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setna ANY [M] r  [] 96 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setna = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','a', str...>, hold<T...>> {
    static constexpr auto value = asm_setna<T...>;
};
template<typename ...T>
constexpr auto asm_setna<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x96>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setna<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x96>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setnae ANY [M] r  [] 92 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setnae = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','a','e', str...>, hold<T...>> {
    static constexpr auto value = asm_setnae<T...>;
};
template<typename ...T>
constexpr auto asm_setnae<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x92>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setnae<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x92>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setnb ANY [M] r  [] 93 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setnb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','b', str...>, hold<T...>> {
    static constexpr auto value = asm_setnb<T...>;
};
template<typename ...T>
constexpr auto asm_setnb<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x93>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setnb<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x93>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setnbe ANY [M] r  [] 97 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setnbe = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','b','e', str...>, hold<T...>> {
    static constexpr auto value = asm_setnbe<T...>;
};
template<typename ...T>
constexpr auto asm_setnbe<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x97>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setnbe<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x97>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setnc ANY [M] r  [] 93 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setnc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','c', str...>, hold<T...>> {
    static constexpr auto value = asm_setnc<T...>;
};
template<typename ...T>
constexpr auto asm_setnc<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x93>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setnc<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x93>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setne ANY [M] r  [] 95 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setne = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','e', str...>, hold<T...>> {
    static constexpr auto value = asm_setne<T...>;
};
template<typename ...T>
constexpr auto asm_setne<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x95>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setne<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x95>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setng ANY [M] r  [] 9E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setng = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','g', str...>, hold<T...>> {
    static constexpr auto value = asm_setng<T...>;
};
template<typename ...T>
constexpr auto asm_setng<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9E>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setng<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9E>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setnge ANY [M] r  [] 9C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setnge = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','g','e', str...>, hold<T...>> {
    static constexpr auto value = asm_setnge<T...>;
};
template<typename ...T>
constexpr auto asm_setnge<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9C>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setnge<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9C>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setnl ANY [M] r  [] 9D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setnl = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','l', str...>, hold<T...>> {
    static constexpr auto value = asm_setnl<T...>;
};
template<typename ...T>
constexpr auto asm_setnl<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9D>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setnl<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9D>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setnle ANY [M] r  [] 9F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setnle = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','l','e', str...>, hold<T...>> {
    static constexpr auto value = asm_setnle<T...>;
};
template<typename ...T>
constexpr auto asm_setnle<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9F>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setnle<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9F>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setno ANY [M] r  [] 91 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setno = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','o', str...>, hold<T...>> {
    static constexpr auto value = asm_setno<T...>;
};
template<typename ...T>
constexpr auto asm_setno<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x91>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setno<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x91>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setnp ANY [M] r  [] 9B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setnp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','p', str...>, hold<T...>> {
    static constexpr auto value = asm_setnp<T...>;
};
template<typename ...T>
constexpr auto asm_setnp<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9B>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setnp<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9B>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setns ANY [M] r  [] 99 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setns = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','s', str...>, hold<T...>> {
    static constexpr auto value = asm_setns<T...>;
};
template<typename ...T>
constexpr auto asm_setns<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x99>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setns<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x99>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setnz ANY [M] r  [] 95 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setnz = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','n','z', str...>, hold<T...>> {
    static constexpr auto value = asm_setnz<T...>;
};
template<typename ...T>
constexpr auto asm_setnz<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x95>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setnz<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x95>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  seto ANY [M] r  [] 90 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_seto = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','o', str...>, hold<T...>> {
    static constexpr auto value = asm_seto<T...>;
};
template<typename ...T>
constexpr auto asm_seto<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x90>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_seto<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x90>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setp ANY [M] r  [] 9A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setp = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','p', str...>, hold<T...>> {
    static constexpr auto value = asm_setp<T...>;
};
template<typename ...T>
constexpr auto asm_setp<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9A>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setp<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9A>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setpe ANY [M] r  [] 9A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setpe = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','p','e', str...>, hold<T...>> {
    static constexpr auto value = asm_setpe<T...>;
};
template<typename ...T>
constexpr auto asm_setpe<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9A>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setpe<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9A>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setpo ANY [M] r  [] 9B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setpo = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','p','o', str...>, hold<T...>> {
    static constexpr auto value = asm_setpo<T...>;
};
template<typename ...T>
constexpr auto asm_setpo<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x9B>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setpo<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x9B>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  sets ANY [M] r  [] 98 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sets = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','s', str...>, hold<T...>> {
    static constexpr auto value = asm_sets<T...>;
};
template<typename ...T>
constexpr auto asm_sets<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x98>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_sets<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x98>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  setssbsy ANY [NONE]   [F3] E8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setssbsy = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','s','s','b','s','y', str...>, hold<T...>> {
    static constexpr auto value = asm_setssbsy<T...>;
};
template <>
constexpr auto asm_setssbsy<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x01>,  byte_seq<0xE8>>>::value;
//  setz ANY [M] r  [] 94 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_setz = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','e','t','z', str...>, hold<T...>> {
    static constexpr auto value = asm_setz<T...>;
};
template<typename ...T>
constexpr auto asm_setz<zip<reg8>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x94>, typename modrm<hold<T...>, hold<T...>>::value>>::value;

template<typename ...T>
constexpr auto asm_setz<ptr<reg8, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x94>, typename mrm<T...>::template value<hold<T...>>>>::value;

//  sfence ANY [NONE] 7 0 [] F8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sfence = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','f','e','n','c','e', str...>, hold<T...>> {
    static constexpr auto value = asm_sfence<T...>;
};
template <>
constexpr auto asm_sfence<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0xF8>>>::value;
//  sgdt ANY [M] 0  [] 01 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sgdt = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','g','d','t', str...>, hold<T...>> {
    static constexpr auto value = asm_sgdt<T...>;
};
template<typename ...T>
constexpr auto asm_sgdt<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  sha1msg1 ANY [RM] r  [] C9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sha1msg1 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','a','1','m','s','g','1', str...>, hold<T...>> {
    static constexpr auto value = asm_sha1msg1<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_sha1msg1<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC9>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_sha1msg1<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC9>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  sha1msg2 ANY [RM] r  [] CA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sha1msg2 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','a','1','m','s','g','2', str...>, hold<T...>> {
    static constexpr auto value = asm_sha1msg2<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_sha1msg2<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xCA>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_sha1msg2<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xCA>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  sha1nexte ANY [RM] r  [] C8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sha1nexte = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','a','1','n','e','x','t','e', str...>, hold<T...>> {
    static constexpr auto value = asm_sha1nexte<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_sha1nexte<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC8>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_sha1nexte<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC8>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  sha1rnds4 ANY [RMI] r  [] CC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sha1rnds4 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','a','1','r','n','d','s','4', str...>, hold<T...>> {
    static constexpr auto value = asm_sha1rnds4<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_sha1rnds4<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xCC>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_sha1rnds4<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x3A>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xCC>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  sha256msg1 ANY [RM] r  [] CC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sha256msg1 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','a','2','5','6','m','s','g','1', str...>, hold<T...>> {
    static constexpr auto value = asm_sha256msg1<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_sha256msg1<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xCC>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_sha256msg1<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xCC>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  sha256msg2 ANY [RM] r  [] CD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sha256msg2 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','a','2','5','6','m','s','g','2', str...>, hold<T...>> {
    static constexpr auto value = asm_sha256msg2<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_sha256msg2<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xCD>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_sha256msg2<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xCD>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  sha256rnds2 ANY [RM] r  [] CB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sha256rnds2 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','a','2','5','6','r','n','d','s','2', str...>, hold<T...>> {
    static constexpr auto value = asm_sha256rnds2<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_sha256rnds2<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xCB>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_sha256rnds2<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xCB>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  shl ANY [M] 4  [] D0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_shl = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','l', str...>, hold<T...>> {
    static constexpr auto value = asm_shl<T...>;
};
template<typename ...T>
constexpr auto asm_shl<zip<reg8>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_shl<ptr<reg8, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD0>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  shl ANY [M] 4  [] D2 

template<typename ...T>
constexpr auto asm_shl<zip<reg8>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_shl<ptr<reg8, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD2>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  shl ANY [MI] 4  [] C0 

template<typename ...T, uint8_t Y>
constexpr auto asm_shl<ptr<reg8, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC0>, typename mrm<T...>::template value<hold<reg<4>>>, typename disp8<Y>::value>>::value;

//  shl ANY [M] 4  [66] D1 

template<typename ...T>
constexpr auto asm_shl<zip<reg16>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_shl<ptr<reg16, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  shl ANY [M] 4  [66] D3 

template<typename ...T>
constexpr auto asm_shl<zip<reg16>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_shl<ptr<reg16, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  shl ANY [MI] 4  [66] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_shl<ptr<reg16, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<4>>>, typename disp8<Y>::value>>::value;

//  shl ANY [M] 4  [] D1 

template<typename ...T>
constexpr auto asm_shl<zip<reg32>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_shl<ptr<reg32, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  shl ANY [M] 4  [] D3 

template<typename ...T>
constexpr auto asm_shl<zip<reg32>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_shl<ptr<reg32, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  shl ANY [MI] 4  [] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_shl<ptr<reg32, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<4>>>, typename disp8<Y>::value>>::value;

//  shl X64 [M] 4  [] D1 

template<typename ...T>
constexpr auto asm_shl<zip<reg64>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_shl<ptr<reg64, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  shl X64 [M] 4  [] D3 

template<typename ...T>
constexpr auto asm_shl<zip<reg64>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_shl<ptr<reg64, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  shl X64 [MI] 4  [] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_shl<ptr<reg64, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<4>>>, typename disp8<Y>::value>>::value;

//  shld ANY [MR] r  [66] A5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_shld = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','l','d', str...>, hold<T...>> {
    static constexpr auto value = asm_shld<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_shld<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xA5>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_shld<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xA5>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  shld ANY [MRI] r  [66] A4 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_shld<ptr<reg16, T...>, zip<reg16>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xA4>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  shld ANY [MR] r  [] A5 

template<typename ...T, typename ...Y>
constexpr auto asm_shld<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xA5>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_shld<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xA5>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  shld ANY [MRI] r  [] A4 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_shld<ptr<reg32, T...>, zip<reg32>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xA4>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  shld X64 [MR] r  [] A5 

template<typename ...T, typename ...Y>
constexpr auto asm_shld<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xA5>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_shld<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xA5>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  shld X64 [MRI] r  [] A4 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_shld<ptr<reg64, T...>, zip<reg64>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xA4>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  shlx ANY [RMV] r  [66] F7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_shlx = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','l','x', str...>, hold<T...>> {
    static constexpr auto value = asm_shlx<T...>;
};
//  shlx X64 [RMV] r  [66] F7 

//  shr ANY [M] 5  [] D0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_shr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','r', str...>, hold<T...>> {
    static constexpr auto value = asm_shr<T...>;
};
template<typename ...T>
constexpr auto asm_shr<zip<reg8>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD0>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_shr<ptr<reg8, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD0>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  shr ANY [M] 5  [] D2 

template<typename ...T>
constexpr auto asm_shr<zip<reg8>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD2>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_shr<ptr<reg8, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD2>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  shr ANY [MI] 5  [] C0 

template<typename ...T, uint8_t Y>
constexpr auto asm_shr<ptr<reg8, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC0>, typename mrm<T...>::template value<hold<reg<5>>>, typename disp8<Y>::value>>::value;

//  shr ANY [M] 5  [66] D1 

template<typename ...T>
constexpr auto asm_shr<zip<reg16>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_shr<ptr<reg16, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  shr ANY [M] 5  [66] D3 

template<typename ...T>
constexpr auto asm_shr<zip<reg16>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_shr<ptr<reg16, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  shr ANY [MI] 5  [66] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_shr<ptr<reg16, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<5>>>, typename disp8<Y>::value>>::value;

//  shr ANY [M] 5  [] D1 

template<typename ...T>
constexpr auto asm_shr<zip<reg32>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_shr<ptr<reg32, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  shr ANY [M] 5  [] D3 

template<typename ...T>
constexpr auto asm_shr<zip<reg32>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_shr<ptr<reg32, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  shr ANY [MI] 5  [] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_shr<ptr<reg32, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<5>>>, typename disp8<Y>::value>>::value;

//  shr X64 [M] 5  [] D1 

template<typename ...T>
constexpr auto asm_shr<zip<reg64>::with<T...>, disp8<1>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD1>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_shr<ptr<reg64, T...>, disp8<1>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD1>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  shr X64 [M] 5  [] D3 

template<typename ...T>
constexpr auto asm_shr<zip<reg64>::with<T...>, cl> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xD3>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_shr<ptr<reg64, T...>, cl> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xD3>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  shr X64 [MI] 5  [] C1 

template<typename ...T, uint8_t Y>
constexpr auto asm_shr<ptr<reg64, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<reg<5>>>, typename disp8<Y>::value>>::value;

//  shrd ANY [MR] r  [66] AD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_shrd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','r','d', str...>, hold<T...>> {
    static constexpr auto value = asm_shrd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_shrd<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAD>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_shrd<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAD>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  shrd ANY [MRI] r  [66] AC 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_shrd<ptr<reg16, T...>, zip<reg16>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAC>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  shrd ANY [MR] r  [] AD 

template<typename ...T, typename ...Y>
constexpr auto asm_shrd<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAD>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_shrd<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAD>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  shrd ANY [MRI] r  [] AC 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_shrd<ptr<reg32, T...>, zip<reg32>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAC>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  shrd X64 [MR] r  [] AD 

template<typename ...T, typename ...Y>
constexpr auto asm_shrd<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAD>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_shrd<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAD>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  shrd X64 [MRI] r  [] AC 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_shrd<ptr<reg64, T...>, zip<reg64>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAC>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  shrx ANY [RMV] r  [F2] F7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_shrx = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','r','x', str...>, hold<T...>> {
    static constexpr auto value = asm_shrx<T...>;
};
//  shrx X64 [RMV] r  [F2] F7 

//  shufpd ANY [RMI] r  [66] C6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_shufpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','u','f','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_shufpd<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_shufpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC6>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_shufpd<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC6>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  shufps ANY [RMI] r  [] C6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_shufps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','h','u','f','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_shufps<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_shufps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xC6>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_shufps<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xC6>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  sidt ANY [M] 1  [] 01 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sidt = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','i','d','t', str...>, hold<T...>> {
    static constexpr auto value = asm_sidt<T...>;
};
template<typename ...T>
constexpr auto asm_sidt<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  skinit ANY [NONE]   [] DE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_skinit = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','k','i','n','i','t', str...>, hold<T...>> {
    static constexpr auto value = asm_skinit<T...>;
};
template <>
constexpr auto asm_skinit<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xDE>>>::value;
//  sldt ANY [M] 0  [66] 00 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sldt = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','l','d','t', str...>, hold<T...>> {
    static constexpr auto value = asm_sldt<T...>;
};
template<typename ...T>
constexpr auto asm_sldt<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_sldt<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x00>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  sldt ANY [M] 0  [] 00 

template<typename ...T>
constexpr auto asm_sldt<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

//  sldt X64 [M] 0  [] 00 

template<typename ...T>
constexpr auto asm_sldt<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<0>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

//  slwpcb ANY [M] 1  [] 12 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_slwpcb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','l','w','p','c','b', str...>, hold<T...>> {
    static constexpr auto value = asm_slwpcb<T...>;
};
template<typename ...T>
constexpr auto asm_slwpcb<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<reg<1>>>>, disp8<is_ext_v<hold<T...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

//  slwpcb X64 [M] 1  [] 12 

template<typename ...T>
constexpr auto asm_slwpcb<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<reg<1>>>>, disp8<is_ext_v<hold<T...>>>, disp8<0>, disp8<9>, disp8<1>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

//  smsw ANY [M] 4  [66] 01 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_smsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','m','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_smsw<T...>;
};
template<typename ...T>
constexpr auto asm_smsw<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x01>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_smsw<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x01>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  smsw ANY [M] 4  [] 01 

template<typename ...T>
constexpr auto asm_smsw<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x01>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

//  smsw X64 [M] 4  [] 01 

template<typename ...T>
constexpr auto asm_smsw<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x01>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

//  sqrtpd ANY [RM] r  [66] 51 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sqrtpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','q','r','t','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_sqrtpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_sqrtpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x51>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_sqrtpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x51>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  sqrtps ANY [RM] r  [] 51 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sqrtps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','q','r','t','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_sqrtps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_sqrtps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x51>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_sqrtps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x51>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  sqrtsd ANY [RM] r  [F2] 51 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sqrtsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','q','r','t','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_sqrtsd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_sqrtsd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x51>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_sqrtsd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x51>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  sqrtss ANY [RM] r  [F3] 51 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sqrtss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','q','r','t','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_sqrtss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_sqrtss<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x51>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_sqrtss<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x51>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  stac ANY [NONE]   [] CB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_stac = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','a','c', str...>, hold<T...>> {
    static constexpr auto value = asm_stac<T...>;
};
template <>
constexpr auto asm_stac<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xCB>>>::value;
//  stc ANY [NONE]   [] F9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_stc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','c', str...>, hold<T...>> {
    static constexpr auto value = asm_stc<T...>;
};
template <>
constexpr auto asm_stc<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xF9>>>::value;
//  std ANY [NONE]   [] FD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_std = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','d', str...>, hold<T...>> {
    static constexpr auto value = asm_std<T...>;
};
template <>
constexpr auto asm_std<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xFD>>>::value;
//  stgi ANY [NONE]   [] DC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_stgi = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','g','i', str...>, hold<T...>> {
    static constexpr auto value = asm_stgi<T...>;
};
template <>
constexpr auto asm_stgi<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xDC>>>::value;
//  sti ANY [NONE]   [] FB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sti = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','i', str...>, hold<T...>> {
    static constexpr auto value = asm_sti<T...>;
};
template <>
constexpr auto asm_sti<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xFB>>>::value;
//  stmxcsr ANY [M] 3  [] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_stmxcsr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','m','x','c','s','r', str...>, hold<T...>> {
    static constexpr auto value = asm_stmxcsr<T...>;
};
template<typename ...T>
constexpr auto asm_stmxcsr<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_stmxcsr<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  stosb ANY [NONE]   [] AA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_stosb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','o','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_stosb<T...>;
};
template <>
constexpr auto asm_stosb<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xAA>>>::value;
//  stosd ANY [NONE]   [] AB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_stosd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','o','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_stosd<T...>;
};
template <>
constexpr auto asm_stosd<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xAB>>>::value;
//  stosq X64 [NONE]   [] AB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_stosq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','o','s','q', str...>, hold<T...>> {
    static constexpr auto value = asm_stosq<T...>;
};
template <>
constexpr auto asm_stosq<> = seq_to_arr<expand_byte_seq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0xAB>>>::value;
//  stosw ANY [NONE]   [66] AB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_stosw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','o','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_stosw<T...>;
};
template <>
constexpr auto asm_stosw<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0xAB>>>::value;
//  str ANY [M] 1  [66] 00 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_str = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','r', str...>, hold<T...>> {
    static constexpr auto value = asm_str<T...>;
};
template<typename ...T>
constexpr auto asm_str<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

template<typename ...T>
constexpr auto asm_str<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x00>, typename mrm<T...>::template value<hold<reg<1>>>>>::value;

//  str ANY [M] 1  [] 00 

template<typename ...T>
constexpr auto asm_str<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

//  str X64 [M] 1  [] 00 

template<typename ...T>
constexpr auto asm_str<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<1>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<1>>>::value>>::value;

//  sttilecfg X64 [M] 0  [66] 49 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sttilecfg = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','t','i','l','e','c','f','g', str...>, hold<T...>> {
    static constexpr auto value = asm_sttilecfg<T...>;
};
template<typename ...T>
constexpr auto asm_sttilecfg<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<0>>>>, disp8<is_ext_v<hold<T...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x49>, typename modrm<hold<T...>, hold<reg<0>>>::value>>::value;

template<typename ...T>
constexpr auto asm_sttilecfg<ptr<reg512, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<reg<0>>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x49>, typename mrm<T...>::template value<hold<reg<0>>>>>::value;

//  stui X64 [NONE]   [F3] EF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_stui = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','t','u','i', str...>, hold<T...>> {
    static constexpr auto value = asm_stui<T...>;
};
template <>
constexpr auto asm_stui<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x01>,  byte_seq<0xEF>>>::value;
//  sub ANY [I]   [] 2C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sub = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','u','b', str...>, hold<T...>> {
    static constexpr auto value = asm_sub<T...>;
};
template <uint8_t Y> 
constexpr auto asm_sub<al, disp8<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x2C>, typename disp8<Y>::value>>::value;
//  sub ANY [I]   [66] 2D 

template <uint16_t Y> 
constexpr auto asm_sub<ax, disp16<Y>> =
    seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0x2D>, typename disp16<Y>::value>>::value;
//  sub ANY [I]   [] 2D 

template <uint32_t Y> 
constexpr auto asm_sub<eax, disp32<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x2D>, typename disp32<Y>::value>>::value;
//  sub X64 [I]   [] 2D 

template <uint32_t Y> 
constexpr auto asm_sub<rax, id<Y>> =
    seq_to_arr<expand_byte_seq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x2D>, typename id<Y>::value>>::value;
//  sub ANY [MI] 5  [] 80 

template<typename ...T, uint8_t Y>
constexpr auto asm_sub<ptr<reg8, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x80>, typename mrm<T...>::template value<hold<reg<5>>>, typename disp8<Y>::value>>::value;

//  sub ANY [MI] 5  [66] 81 

template<typename ...T, uint16_t Y>
constexpr auto asm_sub<ptr<reg16, T...>, disp16<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<5>>>, typename disp16<Y>::value>>::value;

//  sub ANY [MI] 5  [] 81 

template<typename ...T, uint32_t Y>
constexpr auto asm_sub<ptr<reg32, T...>, disp32<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<5>>>, typename disp32<Y>::value>>::value;

//  sub X64 [MI] 5  [] 81 

template<typename ...T, uint32_t Y>
constexpr auto asm_sub<ptr<reg64, T...>, id<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<5>>>, typename id<Y>::value>>::value;

//  sub ANY [MI] 5  [66] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_sub<ptr<reg16, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<5>>>, typename ib<Y>::value>>::value;

//  sub ANY [MI] 5  [] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_sub<ptr<reg32, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<5>>>, typename ib<Y>::value>>::value;

//  sub X64 [MI] 5  [] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_sub<ptr<reg64, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<5>>>, typename ib<Y>::value>>::value;

//  sub ANY [MR] r  [] 28 

template<typename ...T, typename ...Y>
constexpr auto asm_sub<ptr<reg8, T...>, zip<reg8>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x28>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  sub ANY [MR] r  [66] 29 

template<typename ...T, typename ...Y>
constexpr auto asm_sub<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x29>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  sub ANY [MR] r  [] 29 

template<typename ...T, typename ...Y>
constexpr auto asm_sub<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x29>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  sub X64 [MR] r  [] 29 

template<typename ...T, typename ...Y>
constexpr auto asm_sub<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x29>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  sub ANY [RM] r  [] 2A 

template<typename ...T, typename ...Y>
constexpr auto asm_sub<zip<reg8>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_sub<zip<reg8>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  sub ANY [RM] r  [66] 2B 

template<typename ...T, typename ...Y>
constexpr auto asm_sub<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_sub<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  sub ANY [RM] r  [] 2B 

template<typename ...T, typename ...Y>
constexpr auto asm_sub<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_sub<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  sub X64 [RM] r  [] 2B 

template<typename ...T, typename ...Y>
constexpr auto asm_sub<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_sub<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  subpd ANY [RM] r  [66] 5C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_subpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','u','b','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_subpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_subpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_subpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  subps ANY [RM] r  [] 5C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_subps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','u','b','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_subps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_subps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_subps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  subsd ANY [RM] r  [F2] 5C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_subsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','u','b','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_subsd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_subsd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_subsd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  subss ANY [RM] r  [F3] 5C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_subss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','u','b','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_subss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_subss<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x5C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_subss<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x5C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  swapgs X64 [NONE]   [] F8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_swapgs = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','w','a','p','g','s', str...>, hold<T...>> {
    static constexpr auto value = asm_swapgs<T...>;
};
template <>
constexpr auto asm_swapgs<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xF8>>>::value;
//  syscall X64 [NONE]   [] 05 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_syscall = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','y','s','c','a','l','l', str...>, hold<T...>> {
    static constexpr auto value = asm_syscall<T...>;
};
template <>
constexpr auto asm_syscall<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x05>>>::value;
//  sysenter ANY [NONE]   [] 34 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sysenter = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','y','s','e','n','t','e','r', str...>, hold<T...>> {
    static constexpr auto value = asm_sysenter<T...>;
};
template <>
constexpr auto asm_sysenter<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x34>>>::value;
//  sysexit ANY [NONE]   [] 35 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sysexit = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','y','s','e','x','i','t', str...>, hold<T...>> {
    static constexpr auto value = asm_sysexit<T...>;
};
template <>
constexpr auto asm_sysexit<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x35>>>::value;
//  sysexitq ANY [NONE]   [] 35 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sysexitq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','y','s','e','x','i','t','q', str...>, hold<T...>> {
    static constexpr auto value = asm_sysexitq<T...>;
};
template <>
constexpr auto asm_sysexitq<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, 0, 0, 0>::value, byte_seq<0x35>>>::value;
//  sysret X64 [NONE]   [] 07 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sysret = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','y','s','r','e','t', str...>, hold<T...>> {
    static constexpr auto value = asm_sysret<T...>;
};
template <>
constexpr auto asm_sysret<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x07>>>::value;
//  sysretq X64 [NONE]   [] 07 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_sysretq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'s','y','s','r','e','t','q', str...>, hold<T...>> {
    static constexpr auto value = asm_sysretq<T...>;
};
template <>
constexpr auto asm_sysretq<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, 0, 0, 0>::value, byte_seq<0x07>>>::value;
//  t1mskc ANY [VM] 7  [] 01 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_t1mskc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','1','m','s','k','c', str...>, hold<T...>> {
    static constexpr auto value = asm_t1mskc<T...>;
};
//  t1mskc X64 [VM] 7  [] 01 

//  tdcall ANY [NONE]   [66] CC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_tdcall = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','d','c','a','l','l', str...>, hold<T...>> {
    static constexpr auto value = asm_tdcall<T...>;
};
template <>
constexpr auto asm_tdcall<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x01>,  byte_seq<0xCC>>>::value;
//  tdpbf16ps X64 [RMV] r  [F3] 5C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_tdpbf16ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','d','p','b','f','1','6','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_tdpbf16ps<T...>;
};
//  tdpbssd X64 [RMV] r  [F2] 5E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_tdpbssd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','d','p','b','s','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_tdpbssd<T...>;
};
//  tdpbsud X64 [RMV] r  [F3] 5E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_tdpbsud = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','d','p','b','s','u','d', str...>, hold<T...>> {
    static constexpr auto value = asm_tdpbsud<T...>;
};
//  tdpbusd X64 [RMV] r  [66] 5E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_tdpbusd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','d','p','b','u','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_tdpbusd<T...>;
};
//  tdpbuud X64 [RMV] r  [] 5E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_tdpbuud = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','d','p','b','u','u','d', str...>, hold<T...>> {
    static constexpr auto value = asm_tdpbuud<T...>;
};
//  test ANY [I]   [] A8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_test = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','e','s','t', str...>, hold<T...>> {
    static constexpr auto value = asm_test<T...>;
};
template <uint8_t Y> 
constexpr auto asm_test<al, disp8<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0xA8>, typename disp8<Y>::value>>::value;
//  test ANY [I]   [66] A9 

template <uint16_t Y> 
constexpr auto asm_test<ax, disp16<Y>> =
    seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0xA9>, typename disp16<Y>::value>>::value;
//  test ANY [I]   [] A9 

template <uint32_t Y> 
constexpr auto asm_test<eax, disp32<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0xA9>, typename disp32<Y>::value>>::value;
//  test X64 [I]   [] A9 

template <uint32_t Y> 
constexpr auto asm_test<rax, id<Y>> =
    seq_to_arr<expand_byte_seq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0xA9>, typename id<Y>::value>>::value;
//  test ANY [MI] 0  [] F6 

template<typename ...T, uint8_t Y>
constexpr auto asm_test<ptr<reg8, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF6>, typename mrm<T...>::template value<hold<reg<0>>>, typename disp8<Y>::value>>::value;

//  test ANY [MI] 0  [66] F7 

template<typename ...T, uint16_t Y>
constexpr auto asm_test<ptr<reg16, T...>, disp16<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF7>, typename mrm<T...>::template value<hold<reg<0>>>, typename disp16<Y>::value>>::value;

//  test ANY [MI] 0  [] F7 

template<typename ...T, uint32_t Y>
constexpr auto asm_test<ptr<reg32, T...>, disp32<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF7>, typename mrm<T...>::template value<hold<reg<0>>>, typename disp32<Y>::value>>::value;

//  test X64 [MI] 0  [] F7 

template<typename ...T, uint32_t Y>
constexpr auto asm_test<ptr<reg64, T...>, id<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<0>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF7>, typename mrm<T...>::template value<hold<reg<0>>>, typename id<Y>::value>>::value;

//  test ANY [MR] r  [] 84 

template<typename ...T, typename ...Y>
constexpr auto asm_test<zip<reg8>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x84>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_test<ptr<reg8, T...>, zip<reg8>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x84>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  test ANY [MR] r  [66] 85 

template<typename ...T, typename ...Y>
constexpr auto asm_test<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x85>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_test<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x85>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  test ANY [MR] r  [] 85 

template<typename ...T, typename ...Y>
constexpr auto asm_test<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x85>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_test<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x85>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  test X64 [MR] r  [] 85 

template<typename ...T, typename ...Y>
constexpr auto asm_test<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x85>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_test<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x85>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  testui X64 [NONE]   [F3] ED 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_testui = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','e','s','t','u','i', str...>, hold<T...>> {
    static constexpr auto value = asm_testui<T...>;
};
template <>
constexpr auto asm_testui<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x01>,  byte_seq<0xED>>>::value;
//  tileloadd X64 [RM] r  [F2] 4B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_tileloadd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','i','l','e','l','o','a','d','d', str...>, hold<T...>> {
    static constexpr auto value = asm_tileloadd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_tileloadd<zip<reg512>::with<T...>, zip<reg1024>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x4B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_tileloadd<zip<reg512>::with<T...>, ptr<reg1024, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x4B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  tileloaddt1 X64 [RM] r  [66] 4B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_tileloaddt1 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','i','l','e','l','o','a','d','d','t','1', str...>, hold<T...>> {
    static constexpr auto value = asm_tileloaddt1<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_tileloaddt1<zip<reg512>::with<T...>, zip<reg1024>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x4B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_tileloaddt1<zip<reg512>::with<T...>, ptr<reg1024, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x4B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  tilerelease X64 [NONE] 0  [] 49 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_tilerelease = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','i','l','e','r','e','l','e','a','s','e', str...>, hold<T...>> {
    static constexpr auto value = asm_tilerelease<T...>;
};
template <>
constexpr auto asm_tilerelease<> = seq_to_arr<expand_byte_seq_v<typename VEX<disp8<0>, disp8<0>, disp8<0>, disp8<2>, disp8<0>, hold<reg<0>>, disp16<128>, disp8<0>>::value, byte_seq<0x49>>>::value;
//  tilestored X64 [MR] r  [F3] 4B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_tilestored = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','i','l','e','s','t','o','r','e','d', str...>, hold<T...>> {
    static constexpr auto value = asm_tilestored<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_tilestored<zip<reg1024>::with<T...>, zip<reg512>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<is_ext_v<hold<T...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x4B>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_tilestored<ptr<reg1024, T...>, zip<reg512>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x4B>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  tilezero X64 [R] r  [F2] 49 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_tilezero = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','i','l','e','z','e','r','o', str...>, hold<T...>> {
    static constexpr auto value = asm_tilezero<T...>;
};
//  tpause ANY [M] 6  [66] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_tpause = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','p','a','u','s','e', str...>, hold<T...>> {
    static constexpr auto value = asm_tpause<T...>;
};
template<typename ...T>
constexpr auto asm_tpause<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

//  tzcnt ANY [RM] r  [66F3] BC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_tzcnt = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','z','c','n','t', str...>, hold<T...>> {
    static constexpr auto value = asm_tzcnt<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_tzcnt<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66, 0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBC>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_tzcnt<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66, 0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBC>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  tzcnt ANY [RM] r  [F3] BC 

template<typename ...T, typename ...Y>
constexpr auto asm_tzcnt<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBC>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_tzcnt<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBC>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  tzcnt X64 [RM] r  [F3] BC 

template<typename ...T, typename ...Y>
constexpr auto asm_tzcnt<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xBC>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_tzcnt<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xBC>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  tzmsk ANY [VM] 4  [] 01 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_tzmsk = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'t','z','m','s','k', str...>, hold<T...>> {
    static constexpr auto value = asm_tzmsk<T...>;
};
//  tzmsk X64 [VM] 4  [] 01 

//  ucomisd ANY [RM] r  [66] 2E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_ucomisd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','c','o','m','i','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_ucomisd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_ucomisd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_ucomisd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  ucomiss ANY [RM] r  [] 2E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_ucomiss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','c','o','m','i','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_ucomiss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_ucomiss<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x2E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_ucomiss<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x2E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  ud0 ANY [RM] r  [] FF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_ud0 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','d','0', str...>, hold<T...>> {
    static constexpr auto value = asm_ud0<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_ud0<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xFF>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_ud0<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xFF>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  ud1 ANY [RM] r  [] B9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_ud1 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','d','1', str...>, hold<T...>> {
    static constexpr auto value = asm_ud1<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_ud1<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0xB9>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_ud1<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0xB9>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  ud2 ANY [NONE]   [] 0B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_ud2 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','d','2', str...>, hold<T...>> {
    static constexpr auto value = asm_ud2<T...>;
};
template <>
constexpr auto asm_ud2<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x0B>>>::value;
//  uiret X64 [NONE]   [F3] EC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_uiret = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','i','r','e','t', str...>, hold<T...>> {
    static constexpr auto value = asm_uiret<T...>;
};
template <>
constexpr auto asm_uiret<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F, 0x01>,  byte_seq<0xEC>>>::value;
//  umonitor ANY [M] 6  [F3] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_umonitor = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','m','o','n','i','t','o','r', str...>, hold<T...>> {
    static constexpr auto value = asm_umonitor<T...>;
};
template<typename ...T>
constexpr auto asm_umonitor<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

//  umonitor X64 [M] 6  [F3] AE 

template<typename ...T>
constexpr auto asm_umonitor<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

//  umwait ANY [M] 6  [F2] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_umwait = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','m','w','a','i','t', str...>, hold<T...>> {
    static constexpr auto value = asm_umwait<T...>;
};
template<typename ...T>
constexpr auto asm_umwait<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

//  unpckhpd ANY [RM] r  [66] 15 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_unpckhpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','n','p','c','k','h','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_unpckhpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_unpckhpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x15>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_unpckhpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x15>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  unpckhps ANY [RM] r  [] 15 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_unpckhps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','n','p','c','k','h','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_unpckhps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_unpckhps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x15>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_unpckhps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x15>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  unpcklpd ANY [RM] r  [66] 14 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_unpcklpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','n','p','c','k','l','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_unpcklpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_unpcklpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x14>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_unpcklpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x14>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  unpcklps ANY [RM] r  [] 14 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_unpcklps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'u','n','p','c','k','l','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_unpcklps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_unpcklps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x14>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_unpcklps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x14>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vaddpd ANY [RVM] r  [66] 58 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vaddpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','d','d','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vaddpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x58>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x58>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vaddpd ANY [RVM] r  [66] 58 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x58>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x58>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vaddps ANY [RVM] r  [] 58 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vaddps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','d','d','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vaddps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x58>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x58>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vaddps ANY [RVM] r  [] 58 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x58>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x58>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vaddsd ANY [RVM] r  [F2] 58 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vaddsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','d','d','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vaddsd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x58>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x58>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vaddss ANY [RVM] r  [F3] 58 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vaddss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','d','d','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vaddss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x58>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x58>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vaddsubpd ANY [RVM] r  [66] D0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vaddsubpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','d','d','s','u','b','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vaddsubpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddsubpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD0>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddsubpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD0>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vaddsubpd ANY [RVM] r  [66] D0 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddsubpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD0>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddsubpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD0>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vaddsubps ANY [RVM] r  [F2] D0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vaddsubps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','d','d','s','u','b','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vaddsubps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddsubps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xD0>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddsubps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xD0>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vaddsubps ANY [RVM] r  [F2] D0 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddsubps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0xD0>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaddsubps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0xD0>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vaesdec ANY [RVM] r  [66] DE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vaesdec = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','e','s','d','e','c', str...>, hold<T...>> {
    static constexpr auto value = asm_vaesdec<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaesdec<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDE>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaesdec<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDE>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vaesdec ANY [RVM] r  [66] DE 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaesdec<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDE>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaesdec<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDE>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vaesdeclast ANY [RVM] r  [66] DF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vaesdeclast = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','e','s','d','e','c','l','a','s','t', str...>, hold<T...>> {
    static constexpr auto value = asm_vaesdeclast<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaesdeclast<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDF>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaesdeclast<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDF>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vaesdeclast ANY [RVM] r  [66] DF 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaesdeclast<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDF>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaesdeclast<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDF>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vaesenc ANY [RVM] r  [66] DC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vaesenc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','e','s','e','n','c', str...>, hold<T...>> {
    static constexpr auto value = asm_vaesenc<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaesenc<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDC>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaesenc<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDC>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vaesenc ANY [RVM] r  [66] DC 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaesenc<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDC>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaesenc<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDC>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vaesenclast ANY [RVM] r  [66] DD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vaesenclast = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','e','s','e','n','c','l','a','s','t', str...>, hold<T...>> {
    static constexpr auto value = asm_vaesenclast<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaesenclast<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDD>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaesenclast<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDD>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vaesenclast ANY [RVM] r  [66] DD 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaesenclast<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDD>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vaesenclast<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDD>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vandnpd ANY [RVM] r  [66] 55 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vandnpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','n','d','n','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vandnpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vandnpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x55>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vandnpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x55>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vandnpd ANY [RVM] r  [66] 55 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vandnpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x55>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vandnpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x55>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vandnps ANY [RVM] r  [] 55 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vandnps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','n','d','n','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vandnps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vandnps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x55>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vandnps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x55>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vandnps ANY [RVM] r  [] 55 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vandnps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x55>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vandnps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x55>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vandpd ANY [RVM] r  [66] 54 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vandpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','n','d','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vandpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vandpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x54>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vandpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x54>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vandpd ANY [RVM] r  [66] 54 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vandpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x54>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vandpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x54>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vandps ANY [RVM] r  [] 54 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vandps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','a','n','d','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vandps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vandps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x54>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vandps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x54>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vandps ANY [RVM] r  [] 54 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vandps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x54>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vandps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x54>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vblendpd ANY [RVMI] r  [66] 0D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vblendpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','b','l','e','n','d','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vblendpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vblendpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0D>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vblendpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0D>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vblendpd ANY [RVMI] r  [66] 0D 

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vblendpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0D>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vblendpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0D>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vblendps ANY [RVMI] r  [66] 0C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vblendps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','b','l','e','n','d','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vblendps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vblendps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0C>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vblendps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0C>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vblendps ANY [RVMI] r  [66] 0C 

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vblendps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0C>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vblendps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0C>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vblendvpd ANY [RVMS] r  [66] 4B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vblendvpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','b','l','e','n','d','v','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vblendvpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vblendvpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x4B>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vblendvpd ANY [RVMS] r  [66] 4B 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vblendvpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x4B>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vblendvps ANY [RVMS] r  [66] 4A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vblendvps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','b','l','e','n','d','v','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vblendvps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vblendvps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x4A>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vblendvps ANY [RVMS] r  [66] 4A 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vblendvps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x4A>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vbroadcastf128 ANY [RM] r  [66] 1A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vbroadcastf128 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','b','r','o','a','d','c','a','s','t','f','1','2','8', str...>, hold<T...>> {
    static constexpr auto value = asm_vbroadcastf128<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vbroadcastf128<zip<reg256>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x1A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vbroadcastf128<zip<reg256>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x1A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vbroadcasti128 ANY [RM] r  [66] 5A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vbroadcasti128 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','b','r','o','a','d','c','a','s','t','i','1','2','8', str...>, hold<T...>> {
    static constexpr auto value = asm_vbroadcasti128<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vbroadcasti128<zip<reg256>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vbroadcasti128<zip<reg256>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vbroadcastsd ANY [RM] r  [66] 19 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vbroadcastsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','b','r','o','a','d','c','a','s','t','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vbroadcastsd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vbroadcastsd<zip<reg256>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x19>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vbroadcastsd<zip<reg256>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x19>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vbroadcastsd ANY [RM] r  [66] 19 

template<typename ...T, typename ...Y>
constexpr auto asm_vbroadcastsd<zip<reg256>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x19>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  vbroadcastss ANY [RM] r  [66] 18 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vbroadcastss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','b','r','o','a','d','c','a','s','t','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vbroadcastss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vbroadcastss<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x18>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vbroadcastss<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x18>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vbroadcastss ANY [RM] r  [66] 18 

template<typename ...T, typename ...Y>
constexpr auto asm_vbroadcastss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x18>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  vbroadcastss ANY [RM] r  [66] 18 

template<typename ...T, typename ...Y>
constexpr auto asm_vbroadcastss<zip<reg256>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x18>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vbroadcastss<zip<reg256>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x18>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vbroadcastss ANY [RM] r  [66] 18 

template<typename ...T, typename ...Y>
constexpr auto asm_vbroadcastss<zip<reg256>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x18>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  vcmppd ANY [RVMI] r  [66] C2 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcmppd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','m','p','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vcmppd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vcmppd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xC2>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vcmppd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xC2>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vcmppd ANY [RVMI] r  [66] C2 

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vcmppd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xC2>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vcmppd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xC2>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vcmpps ANY [RVMI] r  [] C2 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcmpps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','m','p','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vcmpps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vcmpps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xC2>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vcmpps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xC2>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vcmpps ANY [RVMI] r  [] C2 

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vcmpps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0xC2>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vcmpps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0xC2>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vcmpsd ANY [RVMI] r  [F2] C2 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcmpsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','m','p','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vcmpsd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vcmpsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0xC2>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vcmpsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0xC2>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vcmpss ANY [RVMI] r  [F3] C2 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcmpss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','m','p','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vcmpss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vcmpss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0xC2>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vcmpss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0xC2>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vcomisd ANY [RM] r  [66] 2F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcomisd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','o','m','i','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vcomisd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vcomisd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x2F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcomisd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x2F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcomiss ANY [RM] r  [] 2F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcomiss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','o','m','i','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vcomiss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vcomiss<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0>>::value, byte_seq<0x2F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcomiss<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0>>::value, byte_seq<0x2F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvtdq2pd ANY [RM] r  [F3] E6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcvtdq2pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','d','q','2','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vcvtdq2pd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vcvtdq2pd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0xE6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtdq2pd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0xE6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvtdq2pd ANY [RM] r  [F3] E6 

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtdq2pd<zip<reg256>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0xE6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtdq2pd<zip<reg256>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0xE6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvtdq2ps ANY [RM] r  [] 5B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcvtdq2ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','d','q','2','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vcvtdq2ps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vcvtdq2ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x5B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtdq2ps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x5B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvtdq2ps ANY [RM] r  [] 5B 

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtdq2ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x5B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtdq2ps<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x5B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvtpd2dq ANY [RM] r  [F2] E6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcvtpd2dq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','p','d','2','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vcvtpd2dq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vcvtpd2dq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xE6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtpd2dq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xE6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvtpd2dq ANY [RM] r  [F2] E6 

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtpd2dq<zip<reg128>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0xE6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtpd2dq<zip<reg128>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0xE6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvtpd2ps ANY [RM] r  [66] 5A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcvtpd2ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','p','d','2','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vcvtpd2ps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vcvtpd2ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtpd2ps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvtpd2ps ANY [RM] r  [66] 5A 

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtpd2ps<zip<reg128>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtpd2ps<zip<reg128>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvtph2ps ANY [RM] r  [66] 13 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcvtph2ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','p','h','2','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vcvtph2ps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vcvtph2ps<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x13>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtph2ps<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x13>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvtph2ps ANY [RM] r  [66] 13 

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtph2ps<zip<reg256>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x13>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtph2ps<zip<reg256>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x13>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvtps2dq ANY [RM] r  [66] 5B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcvtps2dq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','p','s','2','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vcvtps2dq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vcvtps2dq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtps2dq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvtps2dq ANY [RM] r  [66] 5B 

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtps2dq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtps2dq<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvtps2pd ANY [RM] r  [] 5A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcvtps2pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','p','s','2','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vcvtps2pd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vcvtps2pd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x5A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtps2pd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x5A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvtps2pd ANY [RM] r  [] 5A 

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtps2pd<zip<reg256>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x5A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtps2pd<zip<reg256>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x5A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvtps2ph ANY [MRI] r  [66] 1D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcvtps2ph = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','p','s','2','p','h', str...>, hold<T...>> {
    static constexpr auto value = asm_vcvtps2ph<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vcvtps2ph<ptr<reg64, T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x1D>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  vcvtps2ph ANY [MRI] r  [66] 1D 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vcvtps2ph<ptr<reg128, T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x1D>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  vcvtsd2si ANY [RM] r  [F2] 2D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcvtsd2si = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','s','d','2','s','i', str...>, hold<T...>> {
    static constexpr auto value = asm_vcvtsd2si<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vcvtsd2si<zip<reg32>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<0>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtsd2si<zip<reg32>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<1>, disp8<0>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvtsd2si X64 [RM] r  [F2] 2D 

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtsd2si<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<1>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtsd2si<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<1>, disp8<1>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvtsd2ss ANY [RVM] r  [F2] 5A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcvtsd2ss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','s','d','2','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vcvtsd2ss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vcvtsd2ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5A>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vcvtsd2ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5A>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vcvtsi2sd ANY [RVM] r  [F2] 2A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcvtsi2sd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','s','i','2','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vcvtsi2sd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vcvtsi2sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<1>, disp8<0>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2A>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vcvtsi2sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<1>, disp8<0>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2A>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vcvtsi2sd X64 [RVM] r  [F2] 2A 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vcvtsi2sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<1>, disp8<1>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2A>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vcvtsi2sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<1>, disp8<1>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2A>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vcvtsi2ss ANY [RVM] r  [F3] 2A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcvtsi2ss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','s','i','2','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vcvtsi2ss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vcvtsi2ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<1>, disp8<0>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2A>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vcvtsi2ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<1>, disp8<0>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2A>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vcvtsi2ss X64 [RVM] r  [F3] 2A 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vcvtsi2ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<1>, disp8<1>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2A>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vcvtsi2ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<1>, disp8<1>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2A>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vcvtss2sd ANY [RVM] r  [F3] 5A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcvtss2sd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','s','s','2','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vcvtss2sd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vcvtss2sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5A>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vcvtss2sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5A>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vcvtss2si ANY [RM] r  [F3] 2D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcvtss2si = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','s','s','2','s','i', str...>, hold<T...>> {
    static constexpr auto value = asm_vcvtss2si<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vcvtss2si<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<0>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtss2si<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<1>, disp8<0>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvtss2si X64 [RM] r  [F3] 2D 

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtss2si<zip<reg64>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<1>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvtss2si<zip<reg64>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<1>, disp8<1>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvttpd2dq ANY [RM] r  [66] E6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcvttpd2dq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','t','p','d','2','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vcvttpd2dq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vcvttpd2dq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvttpd2dq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvttpd2dq ANY [RM] r  [66] E6 

template<typename ...T, typename ...Y>
constexpr auto asm_vcvttpd2dq<zip<reg128>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvttpd2dq<zip<reg128>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvttps2dq ANY [RM] r  [F3] 5B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcvttps2dq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','t','p','s','2','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vcvttps2dq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vcvttps2dq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x5B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvttps2dq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x5B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvttps2dq ANY [RM] r  [F3] 5B 

template<typename ...T, typename ...Y>
constexpr auto asm_vcvttps2dq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x5B>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvttps2dq<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x5B>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvttsd2si ANY [RM] r  [F2] 2C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcvttsd2si = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','t','s','d','2','s','i', str...>, hold<T...>> {
    static constexpr auto value = asm_vcvttsd2si<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vcvttsd2si<zip<reg32>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<0>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvttsd2si<zip<reg32>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<1>, disp8<0>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvttsd2si X64 [RM] r  [F2] 2C 

template<typename ...T, typename ...Y>
constexpr auto asm_vcvttsd2si<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<1>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvttsd2si<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<1>, disp8<1>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x2C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvttss2si ANY [RM] r  [F3] 2C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vcvttss2si = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','c','v','t','t','s','s','2','s','i', str...>, hold<T...>> {
    static constexpr auto value = asm_vcvttss2si<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vcvttss2si<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<0>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvttss2si<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<1>, disp8<0>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vcvttss2si X64 [RM] r  [F3] 2C 

template<typename ...T, typename ...Y>
constexpr auto asm_vcvttss2si<zip<reg64>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<1>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vcvttss2si<zip<reg64>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<1>, disp8<1>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x2C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vdivpd ANY [RVM] r  [66] 5E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vdivpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','d','i','v','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vdivpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vdivpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5E>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vdivpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5E>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vdivpd ANY [RVM] r  [66] 5E 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vdivpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5E>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vdivpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5E>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vdivps ANY [RVM] r  [] 5E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vdivps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','d','i','v','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vdivps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vdivps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x5E>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vdivps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x5E>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vdivps ANY [RVM] r  [] 5E 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vdivps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x5E>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vdivps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x5E>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vdivsd ANY [RVM] r  [F2] 5E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vdivsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','d','i','v','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vdivsd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vdivsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5E>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vdivsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5E>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vdivss ANY [RVM] r  [F3] 5E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vdivss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','d','i','v','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vdivss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vdivss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5E>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vdivss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5E>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vdppd ANY [RVMI] r  [66] 41 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vdppd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','d','p','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vdppd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vdppd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x41>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vdppd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x41>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vdpps ANY [RVMI] r  [66] 40 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vdpps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','d','p','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vdpps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vdpps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x40>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vdpps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x40>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vdpps ANY [RVMI] r  [66] 40 

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vdpps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x40>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vdpps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x40>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  verr ANY [M] 4  [] 00 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_verr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','e','r','r', str...>, hold<T...>> {
    static constexpr auto value = asm_verr<T...>;
};
template<typename ...T>
constexpr auto asm_verr<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<4>>>::value>>::value;

template<typename ...T>
constexpr auto asm_verr<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x00>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  verw ANY [M] 5  [] 00 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_verw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','e','r','w', str...>, hold<T...>> {
    static constexpr auto value = asm_verw<T...>;
};
template<typename ...T>
constexpr auto asm_verw<zip<reg16>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<5>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x00>, typename modrm<hold<T...>, hold<reg<5>>>::value>>::value;

template<typename ...T>
constexpr auto asm_verw<ptr<reg16, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x00>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  vextractf128 ANY [MRI] r  [66] 19 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vextractf128 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','e','x','t','r','a','c','t','f','1','2','8', str...>, hold<T...>> {
    static constexpr auto value = asm_vextractf128<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vextractf128<ptr<reg128, T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x19>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  vextracti128 ANY [MRI] r  [66] 39 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vextracti128 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','e','x','t','r','a','c','t','i','1','2','8', str...>, hold<T...>> {
    static constexpr auto value = asm_vextracti128<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vextracti128<ptr<reg128, T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x39>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  vextractps ANY [MRI] r  [66] 17 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vextractps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','e','x','t','r','a','c','t','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vextractps<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vextractps<ptr<reg32, T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x17>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  vfmadd132pd ANY [RVM] r  [66] 98 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmadd132pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','1','3','2','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmadd132pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd132pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x98>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd132pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x98>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmadd132pd ANY [RVM] r  [66] 98 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd132pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x98>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd132pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x98>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmadd132ps ANY [RVM] r  [66] 98 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmadd132ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','1','3','2','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmadd132ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd132ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x98>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd132ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x98>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmadd132ps ANY [RVM] r  [66] 98 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd132ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x98>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd132ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x98>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmadd132sd ANY [RVM] r  [66] 99 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmadd132sd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','1','3','2','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmadd132sd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd132sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x99>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd132sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x99>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmadd132ss ANY [RVM] r  [66] 99 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmadd132ss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','1','3','2','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmadd132ss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd132ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x99>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd132ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x99>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmadd213pd ANY [RVM] r  [66] A8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmadd213pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','2','1','3','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmadd213pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd213pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA8>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd213pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA8>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmadd213pd ANY [RVM] r  [66] A8 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd213pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA8>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd213pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA8>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmadd213ps ANY [RVM] r  [66] A8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmadd213ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','2','1','3','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmadd213ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd213ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA8>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd213ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA8>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmadd213ps ANY [RVM] r  [66] A8 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd213ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA8>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd213ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA8>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmadd213sd ANY [RVM] r  [66] A9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmadd213sd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','2','1','3','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmadd213sd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd213sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xA9>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd213sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xA9>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmadd213ss ANY [RVM] r  [66] A9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmadd213ss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','2','1','3','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmadd213ss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd213ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xA9>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd213ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xA9>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmadd231pd ANY [RVM] r  [66] B8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmadd231pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','2','3','1','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmadd231pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd231pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB8>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd231pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB8>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmadd231pd ANY [RVM] r  [66] B8 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd231pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB8>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd231pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB8>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmadd231ps ANY [RVM] r  [66] B8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmadd231ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','2','3','1','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmadd231ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd231ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB8>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd231ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB8>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmadd231ps ANY [RVM] r  [66] B8 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd231ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB8>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd231ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB8>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmadd231sd ANY [RVM] r  [66] B9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmadd231sd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','2','3','1','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmadd231sd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd231sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xB9>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd231sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xB9>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmadd231ss ANY [RVM] r  [66] B9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmadd231ss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','2','3','1','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmadd231ss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd231ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xB9>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmadd231ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xB9>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmaddpd ANY [RVSM] r  [66] 69 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmaddpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmaddpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x69>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x69>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmaddpd ANY [RVMS] r  [66] 69 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x69>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmaddpd ANY [RVSM] r  [66] 69 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x69>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x69>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmaddpd ANY [RVMS] r  [66] 69 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x69>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmaddps ANY [RVSM] r  [66] 68 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmaddps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmaddps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x68>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x68>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmaddps ANY [RVMS] r  [66] 68 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x68>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmaddps ANY [RVSM] r  [66] 68 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x68>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x68>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmaddps ANY [RVMS] r  [66] 68 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x68>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmaddsd ANY [RVSM] r  [66] 6B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmaddsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmaddsd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg64>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6B>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg64, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6B>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmaddsd ANY [RVMS] r  [66] 6B 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6B>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmaddss ANY [RVSM] r  [66] 6A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmaddss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmaddss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg32>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6A>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg32, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6A>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmaddss ANY [RVMS] r  [66] 6A 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6A>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmaddsub132pd ANY [RVM] r  [66] 96 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmaddsub132pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','u','b','1','3','2','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmaddsub132pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub132pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x96>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub132pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x96>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmaddsub132pd ANY [RVM] r  [66] 96 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub132pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x96>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub132pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x96>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmaddsub132ps ANY [RVM] r  [66] 96 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmaddsub132ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','u','b','1','3','2','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmaddsub132ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub132ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x96>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub132ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x96>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmaddsub132ps ANY [RVM] r  [66] 96 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub132ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x96>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub132ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x96>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmaddsub213pd ANY [RVM] r  [66] A6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmaddsub213pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','u','b','2','1','3','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmaddsub213pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub213pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA6>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub213pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA6>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmaddsub213pd ANY [RVM] r  [66] A6 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub213pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA6>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub213pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA6>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmaddsub213ps ANY [RVM] r  [66] A6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmaddsub213ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','u','b','2','1','3','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmaddsub213ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub213ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA6>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub213ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA6>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmaddsub213ps ANY [RVM] r  [66] A6 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub213ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA6>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub213ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA6>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmaddsub231pd ANY [RVM] r  [66] B6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmaddsub231pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','u','b','2','3','1','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmaddsub231pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub231pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB6>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub231pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB6>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmaddsub231pd ANY [RVM] r  [66] B6 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub231pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB6>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub231pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB6>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmaddsub231ps ANY [RVM] r  [66] B6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmaddsub231ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','u','b','2','3','1','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmaddsub231ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub231ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB6>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub231ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB6>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmaddsub231ps ANY [RVM] r  [66] B6 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub231ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB6>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmaddsub231ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB6>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmaddsubpd ANY [RVSM] r  [66] 5D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmaddsubpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','u','b','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmaddsubpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddsubpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5D>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddsubpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5D>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmaddsubpd ANY [RVMS] r  [66] 5D 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddsubpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5D>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmaddsubpd ANY [RVSM] r  [66] 5D 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddsubpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5D>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddsubpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5D>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmaddsubpd ANY [RVMS] r  [66] 5D 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddsubpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5D>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmaddsubps ANY [RVSM] r  [66] 5C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmaddsubps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','a','d','d','s','u','b','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmaddsubps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddsubps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5C>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddsubps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5C>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmaddsubps ANY [RVMS] r  [66] 5C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddsubps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5C>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmaddsubps ANY [RVSM] r  [66] 5C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddsubps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5C>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddsubps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5C>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmaddsubps ANY [RVMS] r  [66] 5C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmaddsubps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5C>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmsub132pd ANY [RVM] r  [66] 9A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsub132pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','1','3','2','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsub132pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub132pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9A>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub132pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9A>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsub132pd ANY [RVM] r  [66] 9A 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub132pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9A>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub132pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9A>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsub132ps ANY [RVM] r  [66] 9A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsub132ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','1','3','2','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsub132ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub132ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9A>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub132ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9A>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsub132ps ANY [RVM] r  [66] 9A 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub132ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9A>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub132ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9A>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsub132sd ANY [RVM] r  [66] 9B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsub132sd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','1','3','2','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsub132sd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub132sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9B>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub132sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9B>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsub132ss ANY [RVM] r  [66] 9B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsub132ss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','1','3','2','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsub132ss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub132ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9B>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub132ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9B>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsub213pd ANY [RVM] r  [66] AA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsub213pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','2','1','3','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsub213pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub213pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAA>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub213pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAA>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsub213pd ANY [RVM] r  [66] AA 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub213pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAA>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub213pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAA>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsub213ps ANY [RVM] r  [66] AA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsub213ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','2','1','3','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsub213ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub213ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAA>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub213ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAA>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsub213ps ANY [RVM] r  [66] AA 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub213ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAA>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub213ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAA>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsub213sd ANY [RVM] r  [66] AB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsub213sd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','2','1','3','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsub213sd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub213sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAB>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub213sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAB>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsub213ss ANY [RVM] r  [66] AB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsub213ss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','2','1','3','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsub213ss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub213ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAB>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub213ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAB>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsub231pd ANY [RVM] r  [66] BA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsub231pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','2','3','1','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsub231pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub231pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBA>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub231pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBA>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsub231pd ANY [RVM] r  [66] BA 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub231pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBA>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub231pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBA>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsub231ps ANY [RVM] r  [66] BA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsub231ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','2','3','1','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsub231ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub231ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBA>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub231ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBA>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsub231ps ANY [RVM] r  [66] BA 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub231ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBA>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub231ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBA>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsub231sd ANY [RVM] r  [66] BB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsub231sd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','2','3','1','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsub231sd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub231sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBB>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub231sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBB>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsub231ss ANY [RVM] r  [66] BB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsub231ss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','2','3','1','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsub231ss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub231ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBB>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsub231ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBB>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsubadd132pd ANY [RVM] r  [66] 97 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsubadd132pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','a','d','d','1','3','2','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsubadd132pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd132pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x97>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd132pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x97>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsubadd132pd ANY [RVM] r  [66] 97 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd132pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x97>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd132pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x97>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsubadd132ps ANY [RVM] r  [66] 97 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsubadd132ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','a','d','d','1','3','2','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsubadd132ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd132ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x97>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd132ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x97>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsubadd132ps ANY [RVM] r  [66] 97 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd132ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x97>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd132ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x97>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsubadd213pd ANY [RVM] r  [66] A7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsubadd213pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','a','d','d','2','1','3','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsubadd213pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd213pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA7>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd213pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA7>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsubadd213pd ANY [RVM] r  [66] A7 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd213pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA7>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd213pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA7>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsubadd213ps ANY [RVM] r  [66] A7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsubadd213ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','a','d','d','2','1','3','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsubadd213ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd213ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA7>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd213ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xA7>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsubadd213ps ANY [RVM] r  [66] A7 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd213ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA7>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd213ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xA7>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsubadd231pd ANY [RVM] r  [66] B7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsubadd231pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','a','d','d','2','3','1','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsubadd231pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd231pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB7>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd231pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB7>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsubadd231pd ANY [RVM] r  [66] B7 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd231pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB7>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd231pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB7>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsubadd231ps ANY [RVM] r  [66] B7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsubadd231ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','a','d','d','2','3','1','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsubadd231ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd231ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB7>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd231ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xB7>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsubadd231ps ANY [RVM] r  [66] B7 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd231ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB7>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfmsubadd231ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xB7>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfmsubaddpd ANY [RVSM] r  [66] 5F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsubaddpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','a','d','d','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsubaddpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubaddpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5F>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubaddpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5F>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmsubaddpd ANY [RVMS] r  [66] 5F 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubaddpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5F>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmsubaddpd ANY [RVSM] r  [66] 5F 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubaddpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5F>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubaddpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5F>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmsubaddpd ANY [RVMS] r  [66] 5F 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubaddpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5F>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmsubaddps ANY [RVSM] r  [66] 5E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsubaddps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','a','d','d','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsubaddps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubaddps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5E>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubaddps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5E>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmsubaddps ANY [RVMS] r  [66] 5E 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubaddps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5E>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmsubaddps ANY [RVSM] r  [66] 5E 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubaddps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5E>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubaddps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5E>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmsubaddps ANY [RVMS] r  [66] 5E 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubaddps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5E>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmsubpd ANY [RVSM] r  [66] 6D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsubpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsubpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6D>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6D>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmsubpd ANY [RVMS] r  [66] 6D 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6D>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmsubpd ANY [RVSM] r  [66] 6D 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6D>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6D>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmsubpd ANY [RVMS] r  [66] 6D 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6D>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmsubps ANY [RVSM] r  [66] 6C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsubps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsubps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6C>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6C>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmsubps ANY [RVMS] r  [66] 6C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6C>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmsubps ANY [RVSM] r  [66] 6C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6C>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6C>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmsubps ANY [RVMS] r  [66] 6C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6C>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmsubsd ANY [RVSM] r  [66] 6F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsubsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsubsd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg64>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6F>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg64, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6F>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmsubsd ANY [RVMS] r  [66] 6F 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6F>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfmsubss ANY [RVSM] r  [66] 6E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfmsubss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','m','s','u','b','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfmsubss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg32>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6E>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg32, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6E>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfmsubss ANY [RVMS] r  [66] 6E 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfmsubss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6E>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfnmadd132pd ANY [RVM] r  [66] 9C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmadd132pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','1','3','2','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmadd132pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd132pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd132pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmadd132pd ANY [RVM] r  [66] 9C 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd132pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd132pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmadd132ps ANY [RVM] r  [66] 9C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmadd132ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','1','3','2','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmadd132ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd132ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd132ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmadd132ps ANY [RVM] r  [66] 9C 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd132ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd132ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmadd132sd ANY [RVM] r  [66] 9D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmadd132sd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','1','3','2','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmadd132sd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd132sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd132sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmadd132ss ANY [RVM] r  [66] 9D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmadd132ss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','1','3','2','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmadd132ss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd132ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd132ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmadd213pd ANY [RVM] r  [66] AC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmadd213pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','2','1','3','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmadd213pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd213pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAC>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd213pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAC>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmadd213pd ANY [RVM] r  [66] AC 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd213pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAC>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd213pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAC>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmadd213ps ANY [RVM] r  [66] AC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmadd213ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','2','1','3','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmadd213ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd213ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAC>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd213ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAC>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmadd213ps ANY [RVM] r  [66] AC 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd213ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAC>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd213ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAC>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmadd213sd ANY [RVM] r  [66] AD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmadd213sd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','2','1','3','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmadd213sd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd213sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAD>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd213sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAD>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmadd213ss ANY [RVM] r  [66] AD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmadd213ss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','2','1','3','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmadd213ss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd213ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAD>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd213ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAD>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmadd231pd ANY [RVM] r  [66] BC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmadd231pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','2','3','1','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmadd231pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd231pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBC>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd231pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBC>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmadd231pd ANY [RVM] r  [66] BC 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd231pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBC>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd231pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBC>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmadd231ps ANY [RVM] r  [66] BC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmadd231ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','2','3','1','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmadd231ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd231ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBC>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd231ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBC>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmadd231ps ANY [RVM] r  [66] BC 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd231ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBC>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd231ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBC>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmadd231sd ANY [RVM] r  [66] BD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmadd231sd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','2','3','1','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmadd231sd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd231sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBD>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd231sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBD>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmadd231ss ANY [RVM] r  [66] BD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmadd231ss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','2','3','1','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmadd231ss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd231ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBD>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmadd231ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBD>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmaddpd ANY [RVSM] r  [66] 79 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmaddpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmaddpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmaddpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x79>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmaddpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x79>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfnmaddpd ANY [RVMS] r  [66] 79 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmaddpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x79>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfnmaddpd ANY [RVSM] r  [66] 79 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmaddpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x79>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmaddpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x79>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfnmaddpd ANY [RVMS] r  [66] 79 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmaddpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x79>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfnmaddps ANY [RVSM] r  [66] 78 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmaddps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmaddps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmaddps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x78>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmaddps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x78>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfnmaddps ANY [RVMS] r  [66] 78 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmaddps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x78>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfnmaddps ANY [RVSM] r  [66] 78 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmaddps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x78>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmaddps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x78>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfnmaddps ANY [RVMS] r  [66] 78 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmaddps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x78>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfnmaddsd ANY [RVSM] r  [66] 7B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmaddsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmaddsd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmaddsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg64>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7B>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmaddsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg64, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7B>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfnmaddsd ANY [RVMS] r  [66] 7B 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmaddsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7B>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfnmaddss ANY [RVSM] r  [66] 7A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmaddss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','a','d','d','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmaddss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmaddss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg32>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7A>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmaddss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg32, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7A>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfnmaddss ANY [RVMS] r  [66] 7A 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmaddss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7A>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfnmsub132pd ANY [RVM] r  [66] 9E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmsub132pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','1','3','2','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmsub132pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub132pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9E>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub132pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9E>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmsub132pd ANY [RVM] r  [66] 9E 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub132pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9E>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub132pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9E>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmsub132ps ANY [RVM] r  [66] 9E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmsub132ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','1','3','2','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmsub132ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub132ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9E>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub132ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x9E>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmsub132ps ANY [RVM] r  [66] 9E 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub132ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9E>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub132ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x9E>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmsub132sd ANY [RVM] r  [66] 9F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmsub132sd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','1','3','2','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmsub132sd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub132sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9F>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub132sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9F>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmsub132ss ANY [RVM] r  [66] 9F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmsub132ss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','1','3','2','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmsub132ss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub132ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9F>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub132ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x9F>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmsub213pd ANY [RVM] r  [66] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmsub213pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','2','1','3','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmsub213pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub213pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAE>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub213pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAE>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmsub213pd ANY [RVM] r  [66] AE 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub213pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAE>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub213pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAE>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmsub213ps ANY [RVM] r  [66] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmsub213ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','2','1','3','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmsub213ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub213ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAE>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub213ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xAE>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmsub213ps ANY [RVM] r  [66] AE 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub213ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAE>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub213ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xAE>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmsub213sd ANY [RVM] r  [66] AF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmsub213sd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','2','1','3','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmsub213sd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub213sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAF>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub213sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAF>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmsub213ss ANY [RVM] r  [66] AF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmsub213ss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','2','1','3','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmsub213ss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub213ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAF>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub213ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xAF>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmsub231pd ANY [RVM] r  [66] BE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmsub231pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','2','3','1','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmsub231pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub231pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBE>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub231pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBE>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmsub231pd ANY [RVM] r  [66] BE 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub231pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBE>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub231pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBE>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmsub231ps ANY [RVM] r  [66] BE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmsub231ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','2','3','1','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmsub231ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub231ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBE>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub231ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xBE>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmsub231ps ANY [RVM] r  [66] BE 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub231ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBE>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub231ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xBE>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmsub231sd ANY [RVM] r  [66] BF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmsub231sd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','2','3','1','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmsub231sd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub231sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBF>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub231sd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBF>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmsub231ss ANY [RVM] r  [66] BF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmsub231ss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','2','3','1','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmsub231ss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub231ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBF>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vfnmsub231ss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0xBF>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vfnmsubpd ANY [RVSM] r  [66] 7D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmsubpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmsubpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmsubpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7D>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmsubpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7D>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfnmsubpd ANY [RVMS] r  [66] 7D 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmsubpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7D>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfnmsubpd ANY [RVSM] r  [66] 7D 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmsubpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7D>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmsubpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7D>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfnmsubpd ANY [RVMS] r  [66] 7D 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmsubpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7D>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfnmsubps ANY [RVSM] r  [66] 7C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmsubps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmsubps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmsubps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7C>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmsubps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7C>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfnmsubps ANY [RVMS] r  [66] 7C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmsubps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7C>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfnmsubps ANY [RVSM] r  [66] 7C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmsubps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7C>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmsubps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7C>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfnmsubps ANY [RVMS] r  [66] 7C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmsubps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7C>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfnmsubsd ANY [RVSM] r  [66] 7F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmsubsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmsubsd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmsubsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg64>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7F>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmsubsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg64, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7F>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfnmsubsd ANY [RVMS] r  [66] 7F 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmsubsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7F>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfnmsubss ANY [RVSM] r  [66] 7E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfnmsubss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','n','m','s','u','b','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfnmsubss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmsubss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg32>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7E>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmsubss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg32, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7E>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vfnmsubss ANY [RVMS] r  [66] 7E 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vfnmsubss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7E>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vfrczpd ANY [RM] r  [] 81 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfrczpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','r','c','z','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfrczpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vfrczpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x81>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vfrczpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x81>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vfrczpd ANY [RM] r  [] 81 

template<typename ...T, typename ...Y>
constexpr auto asm_vfrczpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x81>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vfrczpd<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x81>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vfrczps ANY [RM] r  [] 80 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfrczps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','r','c','z','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfrczps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vfrczps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x80>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vfrczps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x80>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vfrczps ANY [RM] r  [] 80 

template<typename ...T, typename ...Y>
constexpr auto asm_vfrczps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x80>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vfrczps<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x80>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vfrczsd ANY [RM] r  [] 83 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfrczsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','r','c','z','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vfrczsd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vfrczsd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x83>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vfrczsd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x83>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vfrczss ANY [RM] r  [] 82 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vfrczss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','f','r','c','z','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vfrczss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vfrczss<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x82>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vfrczss<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x82>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vgatherdpd ANY [RMV] r  [66] 92 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vgatherdpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','g','a','t','h','e','r','d','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vgatherdpd<T...>;
};
//  vgatherdpd ANY [RMV] r  [66] 92 

//  vgatherdps ANY [RMV] r  [66] 92 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vgatherdps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','g','a','t','h','e','r','d','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vgatherdps<T...>;
};
//  vgatherdps ANY [RMV] r  [66] 92 

//  vgatherqpd ANY [RMV] r  [66] 93 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vgatherqpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','g','a','t','h','e','r','q','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vgatherqpd<T...>;
};
//  vgatherqpd ANY [RMV] r  [66] 93 

//  vgatherqps ANY [RMV] r  [66] 93 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vgatherqps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','g','a','t','h','e','r','q','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vgatherqps<T...>;
};
//  vgatherqps ANY [RMV] r  [66] 93 

//  vgf2p8affineinvqb ANY [RVMI] r  [66] CF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vgf2p8affineinvqb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','g','f','2','p','8','a','f','f','i','n','e','i','n','v','q','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vgf2p8affineinvqb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vgf2p8affineinvqb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xCF>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vgf2p8affineinvqb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xCF>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vgf2p8affineinvqb ANY [RVMI] r  [66] CF 

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vgf2p8affineinvqb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xCF>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vgf2p8affineinvqb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xCF>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vgf2p8affineqb ANY [RVMI] r  [66] CE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vgf2p8affineqb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','g','f','2','p','8','a','f','f','i','n','e','q','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vgf2p8affineqb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vgf2p8affineqb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xCE>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vgf2p8affineqb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xCE>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vgf2p8affineqb ANY [RVMI] r  [66] CE 

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vgf2p8affineqb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xCE>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vgf2p8affineqb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xCE>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vgf2p8mulb ANY [RVM] r  [66] CF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vgf2p8mulb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','g','f','2','p','8','m','u','l','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vgf2p8mulb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vgf2p8mulb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xCF>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vgf2p8mulb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xCF>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vgf2p8mulb ANY [RVM] r  [66] CF 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vgf2p8mulb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xCF>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vgf2p8mulb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xCF>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vhaddpd ANY [RVM] r  [66] 7C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vhaddpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','h','a','d','d','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vhaddpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vhaddpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vhaddpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vhaddpd ANY [RVM] r  [66] 7C 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vhaddpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vhaddpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vhaddps ANY [RVM] r  [F2] 7C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vhaddps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','h','a','d','d','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vhaddps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vhaddps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x7C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vhaddps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x7C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vhaddps ANY [RVM] r  [F2] 7C 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vhaddps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0x7C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vhaddps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0x7C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vhsubpd ANY [RVM] r  [66] 7D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vhsubpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','h','s','u','b','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vhsubpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vhsubpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vhsubpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vhsubpd ANY [RVM] r  [66] 7D 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vhsubpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vhsubpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vhsubps ANY [RVM] r  [F2] 7D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vhsubps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','h','s','u','b','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vhsubps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vhsubps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x7D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vhsubps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x7D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vhsubps ANY [RVM] r  [F2] 7D 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vhsubps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0x7D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vhsubps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0x7D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vinsertf128 ANY [RVMI] r  [66] 18 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vinsertf128 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','i','n','s','e','r','t','f','1','2','8', str...>, hold<T...>> {
    static constexpr auto value = asm_vinsertf128<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vinsertf128<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x18>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vinsertf128<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x18>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vinserti128 ANY [RVMI] r  [66] 38 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vinserti128 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','i','n','s','e','r','t','i','1','2','8', str...>, hold<T...>> {
    static constexpr auto value = asm_vinserti128<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vinserti128<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x38>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vinserti128<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x38>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vinsertps ANY [RVMI] r  [66] 21 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vinsertps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','i','n','s','e','r','t','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vinsertps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vinsertps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x21>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vinsertps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x21>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vlddqu ANY [RM] r  [F2] F0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vlddqu = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','l','d','d','q','u', str...>, hold<T...>> {
    static constexpr auto value = asm_vlddqu<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vlddqu<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vlddqu<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0xF0>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vlddqu ANY [RM] r  [F2] F0 

template<typename ...T, typename ...Y>
constexpr auto asm_vlddqu<zip<reg256>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0xF0>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vlddqu<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0xF0>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vldmxcsr ANY [M] 2  [] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vldmxcsr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','l','d','m','x','c','s','r', str...>, hold<T...>> {
    static constexpr auto value = asm_vldmxcsr<T...>;
};
template<typename ...T>
constexpr auto asm_vldmxcsr<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<2>>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

template<typename ...T>
constexpr auto asm_vldmxcsr<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<reg<2>>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<2>>>>>::value;

//  vmaskmovdqu ANY [RM] r  [66] F7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmaskmovdqu = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','a','s','k','m','o','v','d','q','u', str...>, hold<T...>> {
    static constexpr auto value = asm_vmaskmovdqu<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmaskmovdqu<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF7>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  vmaskmovpd ANY [MVR] r  [66] 2F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmaskmovpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','a','s','k','m','o','v','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vmaskmovpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaskmovpd<ptr<reg128, T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Z...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2F>, typename mrm<T...>::template value<hold<Z...>>>>::value;

//  vmaskmovpd ANY [MVR] r  [66] 2F 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaskmovpd<ptr<reg256, T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Z...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2F>, typename mrm<T...>::template value<hold<Z...>>>>::value;

//  vmaskmovpd ANY [RVM] r  [66] 2D 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaskmovpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaskmovpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmaskmovpd ANY [RVM] r  [66] 2D 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaskmovpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaskmovpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmaskmovps ANY [MVR] r  [66] 2E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmaskmovps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','a','s','k','m','o','v','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vmaskmovps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaskmovps<ptr<reg128, T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Z...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2E>, typename mrm<T...>::template value<hold<Z...>>>>::value;

//  vmaskmovps ANY [MVR] r  [66] 2E 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaskmovps<ptr<reg256, T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Z...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2E>, typename mrm<T...>::template value<hold<Z...>>>>::value;

//  vmaskmovps ANY [RVM] r  [66] 2C 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaskmovps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaskmovps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmaskmovps ANY [RVM] r  [66] 2C 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaskmovps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaskmovps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmaxpd ANY [RVM] r  [66] 5F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmaxpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','a','x','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vmaxpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaxpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5F>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaxpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5F>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmaxpd ANY [RVM] r  [66] 5F 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaxpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5F>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaxpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5F>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmaxps ANY [RVM] r  [] 5F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmaxps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','a','x','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vmaxps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaxps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x5F>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaxps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x5F>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmaxps ANY [RVM] r  [] 5F 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaxps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x5F>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaxps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x5F>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmaxsd ANY [RVM] r  [F2] 5F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmaxsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','a','x','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vmaxsd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaxsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5F>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaxsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5F>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmaxss ANY [RVM] r  [F3] 5F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmaxss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','a','x','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vmaxss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaxss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5F>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmaxss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5F>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmcall ANY [NONE]   [] C1 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmcall = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','c','a','l','l', str...>, hold<T...>> {
    static constexpr auto value = asm_vmcall<T...>;
};
template <>
constexpr auto asm_vmcall<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xC1>>>::value;
//  vmclear ANY [M] 6  [66] C7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmclear = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','c','l','e','a','r', str...>, hold<T...>> {
    static constexpr auto value = asm_vmclear<T...>;
};
template<typename ...T>
constexpr auto asm_vmclear<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

template<typename ...T>
constexpr auto asm_vmclear<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  vmfunc ANY [NONE]   [] D4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmfunc = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','f','u','n','c', str...>, hold<T...>> {
    static constexpr auto value = asm_vmfunc<T...>;
};
template <>
constexpr auto asm_vmfunc<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xD4>>>::value;
//  vminpd ANY [RVM] r  [66] 5D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vminpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','i','n','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vminpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vminpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vminpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vminpd ANY [RVM] r  [66] 5D 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vminpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vminpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vminps ANY [RVM] r  [] 5D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vminps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','i','n','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vminps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vminps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x5D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vminps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x5D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vminps ANY [RVM] r  [] 5D 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vminps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x5D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vminps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x5D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vminsd ANY [RVM] r  [F2] 5D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vminsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','i','n','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vminsd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vminsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vminsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vminss ANY [RVM] r  [F3] 5D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vminss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','i','n','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vminss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vminss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vminss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmlaunch ANY [NONE]   [] C2 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmlaunch = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','l','a','u','n','c','h', str...>, hold<T...>> {
    static constexpr auto value = asm_vmlaunch<T...>;
};
template <>
constexpr auto asm_vmlaunch<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xC2>>>::value;
//  vmload X86 [NONE]   [] DA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmload = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','l','o','a','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vmload<T...>;
};
template <>
constexpr auto asm_vmload<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xDA>>>::value;
//  vmmcall ANY [NONE]   [] D9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmmcall = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','m','c','a','l','l', str...>, hold<T...>> {
    static constexpr auto value = asm_vmmcall<T...>;
};
template <>
constexpr auto asm_vmmcall<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xD9>>>::value;
//  vmovapd ANY [RM] r  [66] 28 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovapd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','a','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovapd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovapd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x28>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovapd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x28>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovapd ANY [MR] r  [66] 29 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovapd<ptr<reg128, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x29>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovapd ANY [RM] r  [66] 28 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovapd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x28>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovapd<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x28>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovapd ANY [MR] r  [66] 29 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovapd<ptr<reg256, T...>, zip<reg256>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x29>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovaps ANY [RM] r  [] 28 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovaps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','a','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovaps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovaps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x28>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovaps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x28>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovaps ANY [MR] r  [] 29 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovaps<ptr<reg128, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x29>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovaps ANY [RM] r  [] 28 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovaps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x28>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovaps<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x28>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovaps ANY [MR] r  [] 29 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovaps<ptr<reg256, T...>, zip<reg256>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x29>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovd ANY [MR] r  [66] 7E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovd<ptr<reg32, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<1>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7E>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovd ANY [RM] r  [66] 6E 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovd<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovd<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<1>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovddup ANY [RM] r  [F2] 12 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovddup = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','d','d','u','p', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovddup<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovddup<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovddup<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x12>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovddup ANY [RM] r  [F2] 12 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovddup<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovddup<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0x12>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovdqa ANY [RM] r  [66] 6F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovdqa = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','d','q','a', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovdqa<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovdqa<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovdqa<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovdqa ANY [MR] r  [66] 7F 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovdqa<ptr<reg128, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x7F>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovdqa ANY [RM] r  [66] 6F 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovdqa<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovdqa<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovdqa ANY [MR] r  [66] 7F 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovdqa<ptr<reg256, T...>, zip<reg256>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x7F>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovdqu ANY [RM] r  [F3] 6F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovdqu = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','d','q','u', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovdqu<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovdqu<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x6F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovdqu<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x6F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovdqu ANY [MR] r  [F3] 7F 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovdqu<ptr<reg128, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x7F>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovdqu ANY [RM] r  [F3] 6F 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovdqu<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x6F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovdqu<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x6F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovdqu ANY [MR] r  [F3] 7F 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovdqu<ptr<reg256, T...>, zip<reg256>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x7F>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovhlps ANY [RVM] r  [] 12 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovhlps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','h','l','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovhlps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmovhlps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

//  vmovhpd ANY [MR] r  [66] 17 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovhpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','h','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovhpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovhpd<zip<reg64>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x17>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovhpd<ptr<reg64, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x17>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovhpd ANY [RVM] r  [66] 16 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmovhpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x16>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmovhpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x16>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmovhps ANY [MR] r  [] 17 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovhps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','h','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovhps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovhps<zip<reg64>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x17>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovhps<ptr<reg64, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x17>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovhps ANY [RVM] r  [] 16 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmovhps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x16>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmovhps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x16>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmovlhps ANY [RVM] r  [] 16 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovlhps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','l','h','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovlhps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmovlhps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x16>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

//  vmovlpd ANY [MR] r  [66] 13 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovlpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','l','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovlpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovlpd<zip<reg64>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x13>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovlpd<ptr<reg64, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x13>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovlpd ANY [RVM] r  [66] 12 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmovlpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x12>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmovlpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x12>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmovlps ANY [MR] r  [] 13 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovlps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','l','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovlps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovlps<zip<reg64>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x13>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovlps<ptr<reg64, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x13>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovlps ANY [RVM] r  [] 12 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmovlps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmovlps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x12>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmovmskpd ANY [RM] r  [66] 50 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovmskpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','m','s','k','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovmskpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovmskpd<zip<reg32>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x50>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  vmovmskpd ANY [RM] r  [66] 50 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovmskpd<zip<reg32>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x50>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  vmovmskps ANY [RM] r  [] 50 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovmskps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','m','s','k','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovmskps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovmskps<zip<reg32>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x50>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  vmovmskps ANY [RM] r  [] 50 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovmskps<zip<reg32>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x50>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

//  vmovntdq ANY [MR] r  [66] E7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovntdq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','n','t','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovntdq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovntdq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE7>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovntdq<ptr<reg128, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE7>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovntdq ANY [MR] r  [66] E7 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovntdq<zip<reg64>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE7>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovntdq<ptr<reg256, T...>, zip<reg256>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE7>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovntdqa ANY [RM] r  [66] 2A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovntdqa = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','n','t','d','q','a', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovntdqa<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovntdqa<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovntdqa<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovntdqa ANY [RM] r  [66] 2A 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovntdqa<zip<reg256>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2A>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovntdqa<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2A>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovntpd ANY [MR] r  [66] 2B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovntpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','n','t','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovntpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovntpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2B>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovntpd<ptr<reg128, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2B>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovntpd ANY [MR] r  [66] 2B 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovntpd<zip<reg64>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2B>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovntpd<ptr<reg256, T...>, zip<reg256>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2B>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovntps ANY [MR] r  [] 2B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovntps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','n','t','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovntps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovntps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x2B>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovntps<ptr<reg128, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x2B>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovntps ANY [MR] r  [] 2B 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovntps<zip<reg64>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x2B>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovntps<ptr<reg256, T...>, zip<reg256>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x2B>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovq X64 [MR] r  [66] 7E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovq<T...>;
};
//  vmovq ANY [RM] r  [F3] 7E 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovq<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x7E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovq<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x7E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovq X64 [RM] r  [66] 6E 

//  vmovq ANY [MR] r  [66] D6 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovq<ptr<reg64, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD6>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovsd ANY [MR] r  [F2] 11 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovsd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovsd<ptr<reg64, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x11>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovsd ANY [RM] r  [F2] 10 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovsd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovsd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x10>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovsd ANY [MVR] r  [F2] 11 

//  vmovsd ANY [RVM] r  [F2] 10 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmovsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x10>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

//  vmovshdup ANY [RM] r  [F3] 16 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovshdup = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','s','h','d','u','p', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovshdup<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovshdup<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x16>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovshdup<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x16>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovshdup ANY [RM] r  [F3] 16 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovshdup<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x16>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovshdup<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x16>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovsldup ANY [RM] r  [F3] 12 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovsldup = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','s','l','d','u','p', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovsldup<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovsldup<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovsldup<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x12>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovsldup ANY [RM] r  [F3] 12 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovsldup<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x12>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovsldup<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x12>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovss ANY [MR] r  [F3] 11 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovss<ptr<reg32, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x11>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovss ANY [RM] r  [F3] 10 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovss<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovss<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x10>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovss ANY [MVR] r  [F3] 11 

//  vmovss ANY [RVM] r  [F3] 10 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmovss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x10>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

//  vmovupd ANY [RM] r  [] 10 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovupd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','u','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovupd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovupd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovupd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x10>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovupd ANY [MR] r  [] 11 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovupd<ptr<reg128, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x11>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovupd ANY [RM] r  [] 10 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovupd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovupd<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x10>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovupd ANY [MR] r  [] 11 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovupd<ptr<reg256, T...>, zip<reg256>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x11>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovups ANY [RM] r  [66] 10 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmovups = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','o','v','u','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vmovups<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmovups<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovups<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x10>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovups ANY [MR] r  [66] 11 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovups<ptr<reg128, T...>, zip<reg128>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x11>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmovups ANY [RM] r  [66] 10 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovups<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x10>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmovups<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x10>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmovups ANY [MR] r  [66] 11 

template<typename ...T, typename ...Y>
constexpr auto asm_vmovups<ptr<reg256, T...>, zip<reg256>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x11>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmpsadbw ANY [RVMI] r  [66] 42 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmpsadbw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','p','s','a','d','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vmpsadbw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vmpsadbw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x42>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vmpsadbw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x42>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vmpsadbw ANY [RVMI] r  [66] 42 

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vmpsadbw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x42>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vmpsadbw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x42>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vmptrld ANY [M] 6  [] C7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmptrld = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','p','t','r','l','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vmptrld<T...>;
};
template<typename ...T>
constexpr auto asm_vmptrld<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

template<typename ...T>
constexpr auto asm_vmptrld<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  vmptrst ANY [M] 7  [] C7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmptrst = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','p','t','r','s','t', str...>, hold<T...>> {
    static constexpr auto value = asm_vmptrst<T...>;
};
template<typename ...T>
constexpr auto asm_vmptrst<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<7>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<7>>>::value>>::value;

template<typename ...T>
constexpr auto asm_vmptrst<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<7>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, typename mrm<T...>::template value<hold<reg<7>>>>>::value;

//  vmread X86 [MR] r  [] 78 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmread = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','r','e','a','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vmread<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmread<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x78>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmread<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x78>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmread X64 [MR] r  [] 78 

template<typename ...T, typename ...Y>
constexpr auto asm_vmread<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0x78>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmread<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x78>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  vmresume ANY [NONE]   [] C3 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmresume = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','r','e','s','u','m','e', str...>, hold<T...>> {
    static constexpr auto value = asm_vmresume<T...>;
};
template <>
constexpr auto asm_vmresume<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xC3>>>::value;
//  vmrun X86 [NONE]   [] D8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmrun = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','r','u','n', str...>, hold<T...>> {
    static constexpr auto value = asm_vmrun<T...>;
};
template <>
constexpr auto asm_vmrun<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xD8>>>::value;
//  vmsave X86 [NONE]   [] DB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmsave = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','s','a','v','e', str...>, hold<T...>> {
    static constexpr auto value = asm_vmsave<T...>;
};
template <>
constexpr auto asm_vmsave<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xDB>>>::value;
//  vmulpd ANY [RVM] r  [66] 59 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmulpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','u','l','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vmulpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmulpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x59>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmulpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x59>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmulpd ANY [RVM] r  [66] 59 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmulpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x59>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmulpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x59>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmulps ANY [RVM] r  [] 59 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmulps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','u','l','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vmulps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmulps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x59>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmulps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x59>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmulps ANY [RVM] r  [] 59 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmulps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x59>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmulps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x59>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmulsd ANY [RVM] r  [F2] 59 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmulsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','u','l','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vmulsd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmulsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x59>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmulsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x59>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmulss ANY [RVM] r  [F3] 59 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmulss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','u','l','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vmulss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmulss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x59>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vmulss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x59>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vmwrite X86 [RM] r  [] 79 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmwrite = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','w','r','i','t','e', str...>, hold<T...>> {
    static constexpr auto value = asm_vmwrite<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vmwrite<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x79>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmwrite<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x79>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmwrite X64 [RM] r  [] 79 

template<typename ...T, typename ...Y>
constexpr auto asm_vmwrite<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x79>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vmwrite<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x79>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vmxon ANY [M] 6  [F3] C7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vmxon = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','m','x','o','n', str...>, hold<T...>> {
    static constexpr auto value = asm_vmxon<T...>;
};
template<typename ...T>
constexpr auto asm_vmxon<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC7>, typename modrm<hold<T...>, hold<reg<6>>>::value>>::value;

template<typename ...T>
constexpr auto asm_vmxon<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  vorpd ANY [RVM] r  [66] 56 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vorpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','o','r','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vorpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vorpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x56>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vorpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x56>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vorpd ANY [RVM] r  [66] 56 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vorpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x56>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vorpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x56>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vorps ANY [RVM] r  [] 56 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vorps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','o','r','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vorps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vorps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x56>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vorps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x56>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vorps ANY [RVM] r  [] 56 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vorps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x56>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vorps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x56>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpabsb ANY [RM] r  [66] 1C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpabsb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','b','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpabsb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpabsb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x1C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpabsb<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x1C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpabsb ANY [RM] r  [66] 1C 

template<typename ...T, typename ...Y>
constexpr auto asm_vpabsb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x1C>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpabsb<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x1C>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpabsd ANY [RM] r  [66] 1E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpabsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','b','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpabsd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpabsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x1E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpabsd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x1E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpabsd ANY [RM] r  [66] 1E 

template<typename ...T, typename ...Y>
constexpr auto asm_vpabsd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x1E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpabsd<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x1E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpabsw ANY [RM] r  [66] 1D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpabsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','b','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpabsw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpabsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x1D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpabsw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x1D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpabsw ANY [RM] r  [66] 1D 

template<typename ...T, typename ...Y>
constexpr auto asm_vpabsw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x1D>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpabsw<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x1D>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpackssdw ANY [RVM] r  [66] 6B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpackssdw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','c','k','s','s','d','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpackssdw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpackssdw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6B>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpackssdw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6B>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpackssdw ANY [RVM] r  [66] 6B 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpackssdw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6B>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpackssdw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6B>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpacksswb ANY [RVM] r  [66] 63 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpacksswb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','c','k','s','s','w','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpacksswb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpacksswb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x63>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpacksswb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x63>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpacksswb ANY [RVM] r  [66] 63 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpacksswb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x63>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpacksswb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x63>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpackusdw ANY [RVM] r  [66] 2B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpackusdw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','c','k','u','s','d','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpackusdw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpackusdw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2B>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpackusdw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x2B>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpackusdw ANY [RVM] r  [66] 2B 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpackusdw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2B>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpackusdw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x2B>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpackuswb ANY [RVM] r  [66] 67 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpackuswb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','c','k','u','s','w','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpackuswb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpackuswb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x67>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpackuswb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x67>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpackuswb ANY [RVM] r  [66] 67 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpackuswb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x67>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpackuswb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x67>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpaddb ANY [RVM] r  [66] FC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpaddb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','d','d','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpaddb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFC>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFC>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpaddb ANY [RVM] r  [66] FC 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFC>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFC>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpaddd ANY [RVM] r  [66] FE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpaddd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','d','d','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpaddd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFE>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFE>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpaddd ANY [RVM] r  [66] FE 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFE>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFE>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpaddq ANY [RVM] r  [66] D4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpaddq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','d','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpaddq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD4>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD4>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpaddq ANY [RVM] r  [66] D4 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD4>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD4>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpaddsb ANY [RVM] r  [66] EC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpaddsb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','d','d','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpaddsb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddsb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEC>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddsb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEC>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpaddsb ANY [RVM] r  [66] EC 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddsb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEC>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddsb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEC>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpaddsw ANY [RVM] r  [66] ED 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpaddsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','d','d','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpaddsw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xED>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xED>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpaddsw ANY [RVM] r  [66] ED 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddsw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xED>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddsw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xED>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpaddusb ANY [RVM] r  [66] DC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpaddusb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','d','d','u','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpaddusb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddusb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDC>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddusb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDC>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpaddusb ANY [RVM] r  [66] DC 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddusb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDC>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddusb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDC>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpaddusw ANY [RVM] r  [66] DD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpaddusw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','d','d','u','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpaddusw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddusw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDD>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddusw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDD>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpaddusw ANY [RVM] r  [66] DD 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddusw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDD>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddusw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDD>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpaddw ANY [RVM] r  [66] FD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpaddw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','d','d','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpaddw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFD>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFD>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpaddw ANY [RVM] r  [66] FD 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFD>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpaddw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFD>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpalignr ANY [RVMI] r  [66] 0F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpalignr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','l','i','g','n','r', str...>, hold<T...>> {
    static constexpr auto value = asm_vpalignr<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpalignr<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0F>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpalignr<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0F>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpalignr ANY [RVMI] r  [66] 0F 

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpalignr<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0F>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpalignr<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0F>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpand ANY [RVM] r  [66] DB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpand = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','n','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpand<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpand<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDB>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpand<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDB>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpand ANY [RVM] r  [66] DB 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpand<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDB>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpand<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDB>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpandn ANY [RVM] r  [66] DF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpandn = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','n','d','n', str...>, hold<T...>> {
    static constexpr auto value = asm_vpandn<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpandn<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDF>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpandn<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDF>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpandn ANY [RVM] r  [66] DF 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpandn<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDF>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpandn<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDF>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpavgb ANY [RVM] r  [66] E0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpavgb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','v','g','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpavgb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpavgb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE0>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpavgb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE0>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpavgb ANY [RVM] r  [66] E0 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpavgb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE0>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpavgb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE0>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpavgw ANY [RVM] r  [66] E3 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpavgw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','a','v','g','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpavgw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpavgw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE3>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpavgw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE3>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpavgw ANY [RVM] r  [66] E3 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpavgw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE3>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpavgw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE3>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpblendd ANY [RVMI] r  [66] 02 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpblendd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','b','l','e','n','d','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpblendd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpblendd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x02>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpblendd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x02>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpblendd ANY [RVMI] r  [66] 02 

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpblendd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x02>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpblendd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x02>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpblendvb ANY [RVMS] r  [66] 4C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpblendvb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','b','l','e','n','d','v','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpblendvb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpblendvb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x4C>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vpblendvb ANY [RVMS] r  [66] 4C 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpblendvb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x4C>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vpblendw ANY [RVMI] r  [66] 0E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpblendw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','b','l','e','n','d','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpblendw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpblendw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0E>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpblendw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0E>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpblendw ANY [RVMI] r  [66] 0E 

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpblendw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0E>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpblendw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0E>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpbroadcastb ANY [RM] r  [66] 78 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpbroadcastb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','b','r','o','a','d','c','a','s','t','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpbroadcastb<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpbroadcastb<zip<reg128>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x78>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpbroadcastb<zip<reg128>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x78>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpbroadcastb ANY [RM] r  [66] 78 

template<typename ...T, typename ...Y>
constexpr auto asm_vpbroadcastb<zip<reg256>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x78>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpbroadcastb<zip<reg256>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x78>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpbroadcastd ANY [RM] r  [66] 58 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpbroadcastd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','b','r','o','a','d','c','a','s','t','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpbroadcastd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpbroadcastd<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x58>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpbroadcastd<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x58>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpbroadcastd ANY [RM] r  [66] 58 

template<typename ...T, typename ...Y>
constexpr auto asm_vpbroadcastd<zip<reg256>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x58>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpbroadcastd<zip<reg256>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x58>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpbroadcastq ANY [RM] r  [66] 59 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpbroadcastq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','b','r','o','a','d','c','a','s','t','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpbroadcastq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpbroadcastq<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x59>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpbroadcastq<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x59>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpbroadcastq ANY [RM] r  [66] 59 

template<typename ...T, typename ...Y>
constexpr auto asm_vpbroadcastq<zip<reg256>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x59>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpbroadcastq<zip<reg256>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x59>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpbroadcastw ANY [RM] r  [66] 79 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpbroadcastw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','b','r','o','a','d','c','a','s','t','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpbroadcastw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpbroadcastw<zip<reg128>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x79>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpbroadcastw<zip<reg128>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x79>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpbroadcastw ANY [RM] r  [66] 79 

template<typename ...T, typename ...Y>
constexpr auto asm_vpbroadcastw<zip<reg256>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x79>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpbroadcastw<zip<reg256>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x79>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpclmulqdq ANY [RVMI] r  [66] 44 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpclmulqdq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','l','m','u','l','q','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpclmulqdq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpclmulqdq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x44>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpclmulqdq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x44>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpclmulqdq ANY [RVMI] r  [66] 44 

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpclmulqdq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x44>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpclmulqdq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x44>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpcmov ANY [RVSM] r  [] A2 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcmov = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','o','v', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcmov<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpcmov<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<8>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xA2>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpcmov<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<8>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xA2>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vpcmov ANY [RVMS] r  [] A2 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpcmov<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xA2>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vpcmov ANY [RVSM] r  [] A2 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpcmov<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<8>, disp8<1>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0xA2>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpcmov<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<8>, disp8<1>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0xA2>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vpcmov ANY [RVMS] r  [] A2 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpcmov<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0xA2>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vpcmpeqb ANY [RVM] r  [66] 74 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcmpeqb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','e','q','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcmpeqb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpeqb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x74>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpeqb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x74>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpcmpeqb ANY [RVM] r  [66] 74 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpeqb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x74>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpeqb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x74>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpcmpeqd ANY [RVM] r  [66] 76 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcmpeqd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','e','q','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcmpeqd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpeqd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x76>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpeqd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x76>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpcmpeqd ANY [RVM] r  [66] 76 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpeqd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x76>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpeqd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x76>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpcmpeqq ANY [RVM] r  [66] 29 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcmpeqq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','e','q','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcmpeqq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpeqq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x29>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpeqq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x29>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpcmpeqq ANY [RVM] r  [66] 29 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpeqq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x29>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpeqq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x29>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpcmpeqw ANY [RVM] r  [66] 75 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcmpeqw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','e','q','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcmpeqw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpeqw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x75>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpeqw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x75>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpcmpeqw ANY [RVM] r  [66] 75 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpeqw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x75>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpeqw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x75>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpcmpestri ANY [RMI] r  [66] 61 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcmpestri = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','e','s','t','r','i', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcmpestri<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpcmpestri<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x61>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpcmpestri<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x61>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vpcmpestrm ANY [RMI] r  [66] 60 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcmpestrm = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','e','s','t','r','m', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcmpestrm<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpcmpestrm<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x60>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpcmpestrm<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x60>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vpcmpgtb ANY [RVM] r  [66] 64 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcmpgtb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','g','t','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcmpgtb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpgtb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x64>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpgtb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x64>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpcmpgtb ANY [RVM] r  [66] 64 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpgtb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x64>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpgtb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x64>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpcmpgtd ANY [RVM] r  [66] 66 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcmpgtd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','g','t','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcmpgtd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpgtd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x66>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpgtd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x66>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpcmpgtd ANY [RVM] r  [66] 66 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpgtd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x66>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpgtd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x66>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpcmpgtq ANY [RVM] r  [66] 37 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcmpgtq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','g','t','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcmpgtq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpgtq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x37>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpgtq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x37>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpcmpgtq ANY [RVM] r  [66] 37 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpgtq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x37>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpgtq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x37>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpcmpgtw ANY [RVM] r  [66] 65 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcmpgtw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','g','t','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcmpgtw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpgtw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x65>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpgtw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x65>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpcmpgtw ANY [RVM] r  [66] 65 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpgtw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x65>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpcmpgtw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x65>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpcmpistri ANY [RMI] r  [66] 63 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcmpistri = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','i','s','t','r','i', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcmpistri<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpcmpistri<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x63>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpcmpistri<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x63>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vpcmpistrm ANY [RMI] r  [66] 62 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcmpistrm = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','m','p','i','s','t','r','m', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcmpistrm<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpcmpistrm<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x62>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpcmpistrm<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x62>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vpcomb ANY [RVMI] r  [] CC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcomb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','o','m','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcomb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpcomb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xCC>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpcomb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xCC>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpcomd ANY [RVMI] r  [] CE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcomd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','o','m','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcomd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpcomd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xCE>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpcomd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xCE>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpcomq ANY [RVMI] r  [] CF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcomq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','o','m','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcomq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpcomq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xCF>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpcomq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xCF>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpcomub ANY [RVMI] r  [] EC 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcomub = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','o','m','u','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcomub<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpcomub<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xEC>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpcomub<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xEC>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpcomud ANY [RVMI] r  [] EE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcomud = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','o','m','u','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcomud<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpcomud<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xEE>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpcomud<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xEE>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpcomuq ANY [RVMI] r  [] EF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcomuq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','o','m','u','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcomuq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpcomuq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xEF>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpcomuq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xEF>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpcomuw ANY [RVMI] r  [] ED 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcomuw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','o','m','u','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcomuw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpcomuw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xED>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpcomuw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xED>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpcomw ANY [RVMI] r  [] CD 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpcomw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','c','o','m','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpcomw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpcomw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xCD>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpcomw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xCD>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpdpbusd ANY [RVM] r  [66] 50 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpdpbusd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','d','p','b','u','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpdpbusd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpdpbusd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x50>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpdpbusd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x50>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpdpbusd ANY [RVM] r  [66] 50 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpdpbusd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x50>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpdpbusd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x50>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpdpbusds ANY [RVM] r  [66] 51 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpdpbusds = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','d','p','b','u','s','d','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vpdpbusds<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpdpbusds<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x51>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpdpbusds<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x51>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpdpbusds ANY [RVM] r  [66] 51 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpdpbusds<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x51>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpdpbusds<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x51>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpdpwssd ANY [RVM] r  [66] 52 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpdpwssd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','d','p','w','s','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpdpwssd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpdpwssd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x52>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpdpwssd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x52>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpdpwssd ANY [RVM] r  [66] 52 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpdpwssd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x52>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpdpwssd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x52>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpdpwssds ANY [RVM] r  [66] 53 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpdpwssds = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','d','p','w','s','s','d','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vpdpwssds<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpdpwssds<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x53>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpdpwssds<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x53>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpdpwssds ANY [RVM] r  [66] 53 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpdpwssds<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x53>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpdpwssds<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x53>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vperm2f128 ANY [RVMI] r  [66] 06 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vperm2f128 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','2','f','1','2','8', str...>, hold<T...>> {
    static constexpr auto value = asm_vperm2f128<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vperm2f128<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x06>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vperm2f128<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x06>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vperm2i128 ANY [RVMI] r  [66] 46 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vperm2i128 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','2','i','1','2','8', str...>, hold<T...>> {
    static constexpr auto value = asm_vperm2i128<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vperm2i128<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x46>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vperm2i128<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x46>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpermd ANY [RVM] r  [66] 36 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpermd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpermd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpermd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x36>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpermd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x36>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpermil2pd ANY [RVMSI] r  [66] 49 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpermil2pd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','i','l','2','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpermil2pd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
constexpr auto asm_vpermil2pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>, disp8<P>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x49>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4 | P>>>::value;

//  vpermil2pd ANY [RVSMI] r  [66] 49 

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
constexpr auto asm_vpermil2pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>, disp8<P>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x49>, typename modrm<hold<O...>, hold<T...>>::value, byte_seq<reg_n<Z...>::value  << 4 | P>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
constexpr auto asm_vpermil2pd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>, disp8<P>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x49>, typename mrm<O...>::template value<hold<T...>>, byte_seq<reg_n<Z...>::value  << 4 | P>>>::value;

//  vpermil2pd ANY [RVMSI] r  [66] 49 

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
constexpr auto asm_vpermil2pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>, disp8<P>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x49>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4 | P>>>::value;

//  vpermil2pd ANY [RVSMI] r  [66] 49 

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
constexpr auto asm_vpermil2pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>, disp8<P>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x49>, typename modrm<hold<O...>, hold<T...>>::value, byte_seq<reg_n<Z...>::value  << 4 | P>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
constexpr auto asm_vpermil2pd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>, disp8<P>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x49>, typename mrm<O...>::template value<hold<T...>>, byte_seq<reg_n<Z...>::value  << 4 | P>>>::value;

//  vpermil2ps ANY [RVMSI] r  [66] 48 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpermil2ps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','i','l','2','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vpermil2ps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
constexpr auto asm_vpermil2ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>, disp8<P>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x48>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4 | P>>>::value;

//  vpermil2ps ANY [RVSMI] r  [66] 48 

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
constexpr auto asm_vpermil2ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>, disp8<P>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x48>, typename modrm<hold<O...>, hold<T...>>::value, byte_seq<reg_n<Z...>::value  << 4 | P>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
constexpr auto asm_vpermil2ps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>, disp8<P>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x48>, typename mrm<O...>::template value<hold<T...>>, byte_seq<reg_n<Z...>::value  << 4 | P>>>::value;

//  vpermil2ps ANY [RVMSI] r  [66] 48 

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
constexpr auto asm_vpermil2ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, zip<reg256>::with<O...>, disp8<P>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x48>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4 | P>>>::value;

//  vpermil2ps ANY [RVSMI] r  [66] 48 

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
constexpr auto asm_vpermil2ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, zip<reg256>::with<O...>, disp8<P>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x48>, typename modrm<hold<O...>, hold<T...>>::value, byte_seq<reg_n<Z...>::value  << 4 | P>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O, uint8_t P>
constexpr auto asm_vpermil2ps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, ptr<reg256, O...>, disp8<P>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x48>, typename mrm<O...>::template value<hold<T...>>, byte_seq<reg_n<Z...>::value  << 4 | P>>>::value;

//  vpermilpd ANY [RVM] r  [66] 0D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpermilpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','i','l','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpermilpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpermilpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpermilpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpermilpd ANY [RMI] r  [66] 05 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpermilpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x05>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpermilpd<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x05>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vpermilpd ANY [RVM] r  [66] 0D 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpermilpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpermilpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpermilpd ANY [RMI] r  [66] 05 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpermilpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x05>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpermilpd<zip<reg256>::with<T...>, ptr<reg256, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x05>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vpermilps ANY [RVM] r  [66] 0C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpermilps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','i','l','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vpermilps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpermilps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpermilps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpermilps ANY [RMI] r  [66] 04 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpermilps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x04>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpermilps<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x04>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vpermilps ANY [RVM] r  [66] 0C 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpermilps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpermilps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpermilps ANY [RMI] r  [66] 04 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpermilps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x04>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpermilps<zip<reg256>::with<T...>, ptr<reg256, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x04>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vpermpd ANY [RMI] r  [66] 01 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpermpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpermpd<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpermpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<1>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x01>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpermpd<zip<reg256>::with<T...>, ptr<reg256, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<1>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x01>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vpermps ANY [RVM] r  [66] 16 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpermps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vpermps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpermps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x16>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpermps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x16>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpermq ANY [RMI] r  [66] 00 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpermq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','r','m','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpermq<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpermq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<1>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x00>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpermq<zip<reg256>::with<T...>, ptr<reg256, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<1>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x00>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vpextrb ANY [MRI] r  [66] 14 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpextrb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','x','t','r','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpextrb<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpextrb<ptr<reg8, T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x14>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  vpextrd ANY [MRI] r  [66] 16 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpextrd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','x','t','r','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpextrd<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpextrd<ptr<reg32, T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x16>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  vpextrq X64 [MRI] r  [66] 16 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpextrq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','x','t','r','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpextrq<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpextrq<ptr<reg64, T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<3>, disp8<1>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x16>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  vpextrw ANY [RMI] r  [66] C5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpextrw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','e','x','t','r','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpextrw<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpextrw<zip<reg32>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<1>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xC5>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

//  vpextrw ANY [MRI] r  [66] 15 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpextrw<ptr<reg16, T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Y...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x15>, typename mrm<T...>::template value<hold<Y...>>, typename disp8<Z>::value>>::value;

//  vpgatherdd ANY [RMV] r  [66] 90 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpgatherdd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','g','a','t','h','e','r','d','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpgatherdd<T...>;
};
//  vpgatherdd ANY [RMV] r  [66] 90 

//  vpgatherdq ANY [RMV] r  [66] 90 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpgatherdq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','g','a','t','h','e','r','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpgatherdq<T...>;
};
//  vpgatherdq ANY [RMV] r  [66] 90 

//  vpgatherqd ANY [RMV] r  [66] 91 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpgatherqd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','g','a','t','h','e','r','q','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpgatherqd<T...>;
};
//  vpgatherqd ANY [RMV] r  [66] 91 

//  vpgatherqq ANY [RMV] r  [66] 91 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpgatherqq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','g','a','t','h','e','r','q','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpgatherqq<T...>;
};
//  vpgatherqq ANY [RMV] r  [66] 91 

//  vphaddbd ANY [RM] r  [] C2 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphaddbd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','b','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vphaddbd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vphaddbd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC2>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vphaddbd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC2>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vphaddbq ANY [RM] r  [] C3 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphaddbq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','b','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vphaddbq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vphaddbq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC3>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vphaddbq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC3>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vphaddbw ANY [RM] r  [] C1 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphaddbw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vphaddbw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vphaddbw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC1>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vphaddbw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC1>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vphaddd ANY [RVM] r  [66] 02 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphaddd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vphaddd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphaddd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x02>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphaddd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x02>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vphaddd ANY [RVM] r  [66] 02 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphaddd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x02>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphaddd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x02>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vphadddq ANY [RM] r  [] CB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphadddq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vphadddq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vphadddq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xCB>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vphadddq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xCB>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vphaddsw ANY [RVM] r  [66] 03 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphaddsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vphaddsw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphaddsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x03>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphaddsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x03>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vphaddsw ANY [RVM] r  [66] 03 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphaddsw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x03>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphaddsw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x03>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vphaddubd ANY [RM] r  [] D2 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphaddubd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','u','b','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vphaddubd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vphaddubd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD2>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vphaddubd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD2>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vphaddubq ANY [RM] r  [] D3 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphaddubq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','u','b','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vphaddubq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vphaddubq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD3>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vphaddubq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD3>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vphaddubw ANY [RM] r  [] D1 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphaddubw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','u','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vphaddubw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vphaddubw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD1>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vphaddubw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD1>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vphaddudq ANY [RM] r  [] DB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphaddudq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','u','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vphaddudq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vphaddudq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xDB>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vphaddudq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xDB>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vphadduwd ANY [RM] r  [] D6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphadduwd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','u','w','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vphadduwd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vphadduwd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vphadduwd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vphadduwq ANY [RM] r  [] D7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphadduwq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','u','w','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vphadduwq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vphadduwq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD7>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vphadduwq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xD7>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vphaddw ANY [RVM] r  [66] 01 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphaddw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vphaddw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphaddw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x01>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphaddw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x01>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vphaddw ANY [RVM] r  [66] 01 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphaddw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x01>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphaddw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x01>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vphaddwd ANY [RM] r  [] C6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphaddwd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','w','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vphaddwd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vphaddwd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC6>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vphaddwd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC6>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vphaddwq ANY [RM] r  [] C7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphaddwq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','a','d','d','w','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vphaddwq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vphaddwq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC7>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vphaddwq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC7>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vphminposuw ANY [RM] r  [66] 41 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphminposuw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','m','i','n','p','o','s','u','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vphminposuw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vphminposuw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x41>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vphminposuw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x41>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vphsubbw ANY [RM] r  [] E1 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphsubbw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','s','u','b','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vphsubbw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vphsubbw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xE1>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vphsubbw<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xE1>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vphsubd ANY [RVM] r  [66] 06 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphsubd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','s','u','b','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vphsubd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphsubd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x06>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphsubd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x06>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vphsubd ANY [RVM] r  [66] 06 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphsubd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x06>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphsubd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x06>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vphsubdq ANY [RM] r  [] E3 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphsubdq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','s','u','b','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vphsubdq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vphsubdq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xE3>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vphsubdq<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xE3>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vphsubsw ANY [RVM] r  [66] 07 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphsubsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','s','u','b','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vphsubsw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphsubsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x07>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphsubsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x07>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vphsubsw ANY [RVM] r  [66] 07 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphsubsw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x07>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphsubsw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x07>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vphsubw ANY [RVM] r  [66] 05 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphsubw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','s','u','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vphsubw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphsubw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x05>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphsubw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x05>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vphsubw ANY [RVM] r  [66] 05 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphsubw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x05>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vphsubw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x05>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vphsubwd ANY [RM] r  [] E2 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vphsubwd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','h','s','u','b','w','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vphsubwd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vphsubwd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xE2>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vphsubwd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<9>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xE2>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpinsrb ANY [RVMI] r  [66] 20 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpinsrb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','i','n','s','r','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpinsrb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpinsrb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg8>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x20>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpinsrb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg8, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x20>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpinsrd ANY [RVMI] r  [66] 22 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpinsrd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','i','n','s','r','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpinsrd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpinsrd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x22>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpinsrd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x22>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpinsrq X64 [RVMI] r  [66] 22 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpinsrq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','i','n','s','r','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpinsrq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpinsrq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x22>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpinsrq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x22>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpinsrw ANY [RVMI] r  [66] C4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpinsrw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','i','n','s','r','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpinsrw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpinsrw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg16>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<1>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xC4>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vpinsrw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg16, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<1>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xC4>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vpmacsdd ANY [RVMS] r  [] 9E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmacsdd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','d','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmacsdd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpmacsdd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x9E>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vpmacsdqh ANY [RVMS] r  [] 9F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmacsdqh = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','d','q','h', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmacsdqh<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpmacsdqh<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x9F>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vpmacsdql ANY [RVMS] r  [] 97 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmacsdql = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','d','q','l', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmacsdql<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpmacsdql<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x97>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vpmacssdd ANY [RVMS] r  [] 8E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmacssdd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','s','d','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmacssdd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpmacssdd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x8E>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vpmacssdqh ANY [RVMS] r  [] 8F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmacssdqh = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','s','d','q','h', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmacssdqh<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpmacssdqh<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x8F>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vpmacssdql ANY [RVMS] r  [] 87 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmacssdql = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','s','d','q','l', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmacssdql<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpmacssdql<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x87>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vpmacsswd ANY [RVMS] r  [] 86 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmacsswd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','s','w','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmacsswd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpmacsswd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x86>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vpmacssww ANY [RVMS] r  [] 85 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmacssww = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','s','w','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmacssww<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpmacssww<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x85>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vpmacswd ANY [RVMS] r  [] 96 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmacswd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','w','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmacswd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpmacswd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x96>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vpmacsww ANY [RVMS] r  [] 95 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmacsww = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','c','s','w','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmacsww<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpmacsww<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x95>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vpmadcsswd ANY [RVMS] r  [] A6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmadcsswd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','d','c','s','s','w','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmadcsswd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpmadcsswd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xA6>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vpmadcswd ANY [RVMS] r  [] B6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmadcswd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','d','c','s','w','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmadcswd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpmadcswd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xB6>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vpmaddubsw ANY [RVM] r  [66] 04 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmaddubsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','d','d','u','b','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmaddubsw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaddubsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x04>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaddubsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x04>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaddubsw ANY [RVM] r  [66] 04 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaddubsw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x04>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaddubsw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x04>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaddwd ANY [RVM] r  [66] F5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmaddwd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','d','d','w','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmaddwd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaddwd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF5>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaddwd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF5>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaddwd ANY [RVM] r  [66] F5 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaddwd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF5>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaddwd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF5>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaskmovd ANY [MVR] r  [66] 8E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmaskmovd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','s','k','m','o','v','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmaskmovd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaskmovd<ptr<reg128, T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Z...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x8E>, typename mrm<T...>::template value<hold<Z...>>>>::value;

//  vpmaskmovd ANY [MVR] r  [66] 8E 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaskmovd<ptr<reg256, T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Z...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x8E>, typename mrm<T...>::template value<hold<Z...>>>>::value;

//  vpmaskmovd ANY [RVM] r  [66] 8C 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaskmovd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x8C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaskmovd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x8C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaskmovd ANY [RVM] r  [66] 8C 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaskmovd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x8C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaskmovd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x8C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaskmovq ANY [MVR] r  [66] 8E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmaskmovq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','s','k','m','o','v','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmaskmovq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaskmovq<ptr<reg128, T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Z...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x8E>, typename mrm<T...>::template value<hold<Z...>>>>::value;

//  vpmaskmovq ANY [MVR] r  [66] 8E 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaskmovq<ptr<reg256, T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<Z...>>>, disp8<mrm<T...>::X>, disp8<mrm<T...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x8E>, typename mrm<T...>::template value<hold<Z...>>>>::value;

//  vpmaskmovq ANY [RVM] r  [66] 8C 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaskmovq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x8C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaskmovq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x8C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaskmovq ANY [RVM] r  [66] 8C 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaskmovq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x8C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaskmovq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x8C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaxsb ANY [RVM] r  [66] 3C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmaxsb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','x','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmaxsb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxsb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxsb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaxsb ANY [RVM] r  [66] 3C 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxsb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxsb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaxsd ANY [RVM] r  [66] 3D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmaxsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','x','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmaxsd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaxsd ANY [RVM] r  [66] 3D 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxsd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxsd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaxsw ANY [RVM] r  [66] EE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmaxsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','x','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmaxsw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEE>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEE>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaxsw ANY [RVM] r  [66] EE 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxsw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEE>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxsw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEE>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaxub ANY [RVM] r  [66] DE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmaxub = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','x','u','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmaxub<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxub<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDE>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxub<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDE>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaxub ANY [RVM] r  [66] DE 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxub<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDE>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxub<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDE>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaxud ANY [RVM] r  [66] 3F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmaxud = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','x','u','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmaxud<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxud<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3F>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxud<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3F>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaxud ANY [RVM] r  [66] 3F 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxud<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3F>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxud<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3F>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaxuw ANY [RVM] r  [66] 3E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmaxuw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','a','x','u','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmaxuw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxuw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3E>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxuw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3E>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmaxuw ANY [RVM] r  [66] 3E 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxuw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3E>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmaxuw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3E>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpminsb ANY [RVM] r  [66] 38 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpminsb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','i','n','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpminsb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminsb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x38>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminsb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x38>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpminsb ANY [RVM] r  [66] 38 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminsb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x38>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminsb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x38>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpminsd ANY [RVM] r  [66] 39 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpminsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','i','n','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpminsd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x39>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x39>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpminsd ANY [RVM] r  [66] 39 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminsd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x39>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminsd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x39>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpminsw ANY [RVM] r  [66] EA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpminsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','i','n','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpminsw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEA>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEA>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpminsw ANY [RVM] r  [66] EA 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminsw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEA>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminsw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEA>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpminub ANY [RVM] r  [66] DA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpminub = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','i','n','u','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpminub<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminub<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDA>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminub<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xDA>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpminub ANY [RVM] r  [66] DA 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminub<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDA>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminub<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xDA>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpminud ANY [RVM] r  [66] 3B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpminud = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','i','n','u','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpminud<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminud<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3B>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminud<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x3B>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpminud ANY [RVM] r  [66] 3B 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminud<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3B>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpminud<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x3B>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmovsxbd ANY [RM] r  [66] 21 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmovsxbd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','s','x','b','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmovsxbd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxbd<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x21>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxbd<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x21>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovsxbd ANY [RM] r  [66] 21 

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxbd<zip<reg256>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x21>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxbd<zip<reg256>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x21>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovsxbq ANY [RM] r  [66] 22 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmovsxbq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','s','x','b','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmovsxbq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxbq<zip<reg128>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x22>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxbq<zip<reg128>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x22>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovsxbq ANY [RM] r  [66] 22 

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxbq<zip<reg256>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x22>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxbq<zip<reg256>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x22>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovsxbw ANY [RM] r  [66] 20 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmovsxbw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','s','x','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmovsxbw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxbw<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x20>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxbw<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x20>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovsxbw ANY [RM] r  [66] 20 

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxbw<zip<reg256>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x20>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxbw<zip<reg256>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x20>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovsxdq ANY [RM] r  [66] 25 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmovsxdq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','s','x','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmovsxdq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxdq<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x25>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxdq<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x25>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovsxdq ANY [RM] r  [66] 25 

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxdq<zip<reg256>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x25>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxdq<zip<reg256>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x25>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovsxwd ANY [RM] r  [66] 23 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmovsxwd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','s','x','w','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmovsxwd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxwd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x23>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxwd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x23>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovsxwd ANY [RM] r  [66] 23 

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxwd<zip<reg256>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x23>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxwd<zip<reg256>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x23>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovsxwq ANY [RM] r  [66] 24 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmovsxwq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','s','x','w','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmovsxwq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxwq<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x24>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxwq<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x24>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovsxwq ANY [RM] r  [66] 24 

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxwq<zip<reg256>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x24>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovsxwq<zip<reg256>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x24>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovzxbd ANY [RM] r  [66] 31 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmovzxbd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','z','x','b','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmovzxbd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxbd<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x31>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxbd<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x31>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovzxbd ANY [RM] r  [66] 31 

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxbd<zip<reg256>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x31>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxbd<zip<reg256>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x31>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovzxbq ANY [RM] r  [66] 32 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmovzxbq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','z','x','b','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmovzxbq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxbq<zip<reg128>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x32>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxbq<zip<reg128>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x32>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovzxbq ANY [RM] r  [66] 32 

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxbq<zip<reg256>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x32>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxbq<zip<reg256>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x32>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovzxbw ANY [RM] r  [66] 30 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmovzxbw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','z','x','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmovzxbw<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxbw<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x30>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxbw<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x30>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovzxbw ANY [RM] r  [66] 30 

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxbw<zip<reg256>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x30>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxbw<zip<reg256>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x30>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovzxdq ANY [RM] r  [66] 35 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmovzxdq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','z','x','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmovzxdq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxdq<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x35>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxdq<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x35>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovzxdq ANY [RM] r  [66] 35 

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxdq<zip<reg256>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x35>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxdq<zip<reg256>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x35>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovzxwd ANY [RM] r  [66] 33 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmovzxwd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','z','x','w','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmovzxwd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxwd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x33>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxwd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x33>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovzxwd ANY [RM] r  [66] 33 

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxwd<zip<reg256>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x33>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxwd<zip<reg256>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x33>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovzxwq ANY [RM] r  [66] 34 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmovzxwq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','o','v','z','x','w','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmovzxwq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxwq<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x34>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxwq<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x34>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmovzxwq ANY [RM] r  [66] 34 

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxwq<zip<reg256>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x34>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vpmovzxwq<zip<reg256>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x34>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpmuldq ANY [RVM] r  [66] 28 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmuldq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','u','l','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmuldq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmuldq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x28>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmuldq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x28>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmuldq ANY [RVM] r  [66] 28 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmuldq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x28>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmuldq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x28>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmulhrsw ANY [RVM] r  [66] 0B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmulhrsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','u','l','h','r','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmulhrsw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmulhrsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0B>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmulhrsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0B>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmulhrsw ANY [RVM] r  [66] 0B 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmulhrsw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0B>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmulhrsw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0B>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmulhuw ANY [RVM] r  [66] E4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmulhuw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','u','l','h','u','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmulhuw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmulhuw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE4>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmulhuw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE4>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmulhuw ANY [RVM] r  [66] E4 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmulhuw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE4>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmulhuw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE4>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmulhw ANY [RVM] r  [66] E5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmulhw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','u','l','h','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmulhw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmulhw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE5>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmulhw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE5>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmulhw ANY [RVM] r  [66] E5 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmulhw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE5>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmulhw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE5>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmulld ANY [RVM] r  [66] 40 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmulld = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','u','l','l','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmulld<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmulld<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x40>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmulld<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x40>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmulld ANY [RVM] r  [66] 40 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmulld<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x40>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmulld<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x40>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmullw ANY [RVM] r  [66] D5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmullw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','u','l','l','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmullw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmullw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD5>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmullw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD5>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmullw ANY [RVM] r  [66] D5 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmullw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD5>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmullw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD5>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmuludq ANY [RVM] r  [66] F4 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpmuludq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','m','u','l','u','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpmuludq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmuludq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF4>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmuludq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF4>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpmuludq ANY [RVM] r  [66] F4 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmuludq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF4>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpmuludq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF4>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpor ANY [RVM] r  [66] EB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpor = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','o','r', str...>, hold<T...>> {
    static constexpr auto value = asm_vpor<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpor<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEB>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpor<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEB>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpor ANY [RVM] r  [66] EB 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpor<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEB>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpor<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEB>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpperm ANY [RVSM] r  [] A3 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpperm = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','p','e','r','m', str...>, hold<T...>> {
    static constexpr auto value = asm_vpperm<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpperm<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, zip<reg128>::with<O...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<O...>>>, disp8<is_ext_v<hold<O...>>>, disp8<0>, disp8<8>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xA3>, typename modrm<hold<O...>, hold<O...>>::value, byte_seq<reg_n<Z...>::value << 4>>>::value;

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpperm<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, ptr<reg128, O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<O...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<O...>>>, disp8<mrm<O...>::X>, disp8<mrm<O...>::B>, disp8<8>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xA3>, typename mrm<O...>::template value<hold<O...>>, byte_seq<reg_n<Z...>::value << 4>>>::value;

//  vpperm ANY [RVMS] r  [] A3 

template<typename ...T, typename ...Y, typename ...Z, typename ...O>
constexpr auto asm_vpperm<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, zip<reg128>::with<O...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<8>, disp8<0>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xA3>, typename mrm<Z...>::template value<hold<T...>>, byte_seq<reg_n<O...>::value << 4>>>::value;

//  vprotb ANY [RVM] r  [] 90 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vprotb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','r','o','t','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vprotb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vprotb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x90>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vprotb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x90>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vprotb ANY [RMI] r  [] C0 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vprotb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<8>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC0>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vprotb<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<8>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC0>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vprotb ANY [RMV] r  [] 90 

//  vprotd ANY [RVM] r  [] 92 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vprotd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','r','o','t','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vprotd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vprotd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x92>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vprotd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x92>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vprotd ANY [RMI] r  [] C2 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vprotd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<8>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC2>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vprotd<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<8>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC2>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vprotd ANY [RMV] r  [] 92 

//  vprotq ANY [RVM] r  [] 93 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vprotq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','r','o','t','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vprotq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vprotq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x93>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vprotq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x93>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vprotq ANY [RMI] r  [] C3 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vprotq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<8>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC3>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vprotq<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<8>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC3>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vprotq ANY [RMV] r  [] 93 

//  vprotw ANY [RVM] r  [] 91 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vprotw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','r','o','t','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vprotw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vprotw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x91>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vprotw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x91>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vprotw ANY [RMI] r  [] C1 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vprotw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<8>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC1>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vprotw<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<8>, disp8<0>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xC1>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vprotw ANY [RMV] r  [] 91 

//  vpsadbw ANY [RVM] r  [66] F6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsadbw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','a','d','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsadbw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsadbw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF6>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsadbw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF6>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsadbw ANY [RVM] r  [66] F6 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsadbw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF6>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsadbw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF6>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpshab ANY [RVM] r  [] 98 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpshab = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','a','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpshab<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshab<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x98>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshab<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x98>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpshab ANY [RMV] r  [] 98 

//  vpshad ANY [RVM] r  [] 9A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpshad = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','a','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpshad<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshad<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x9A>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshad<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x9A>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpshad ANY [RMV] r  [] 9A 

//  vpshaq ANY [RVM] r  [] 9B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpshaq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','a','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpshaq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshaq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x9B>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshaq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x9B>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpshaq ANY [RMV] r  [] 9B 

//  vpshaw ANY [RVM] r  [] 99 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpshaw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','a','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpshaw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshaw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x99>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshaw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x99>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpshaw ANY [RMV] r  [] 99 

//  vpshlb ANY [RVM] r  [] 94 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpshlb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','l','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpshlb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshlb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x94>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshlb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x94>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpshlb ANY [RMV] r  [] 94 

//  vpshld ANY [RVM] r  [] 96 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpshld = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','l','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpshld<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshld<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x96>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshld<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x96>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpshld ANY [RMV] r  [] 96 

//  vpshlq ANY [RVM] r  [] 97 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpshlq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','l','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpshlq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshlq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x97>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshlq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x97>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpshlq ANY [RMV] r  [] 97 

//  vpshlw ANY [RVM] r  [] 95 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpshlw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','l','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpshlw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshlw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x95>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshlw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename XOP<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<9>, disp8<1>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x95>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpshlw ANY [RMV] r  [] 95 

//  vpshufb ANY [RVM] r  [66] 00 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpshufb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','u','f','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpshufb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshufb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x00>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshufb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x00>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpshufb ANY [RVM] r  [66] 00 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshufb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x00>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpshufb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x00>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpshufd ANY [RMI] r  [66] 70 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpshufd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','u','f','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpshufd<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpshufd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpshufd<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x70>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vpshufd ANY [RMI] r  [66] 70 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpshufd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpshufd<zip<reg256>::with<T...>, ptr<reg256, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x70>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vpshufhw ANY [RMI] r  [F3] 70 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpshufhw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','u','f','h','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpshufhw<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpshufhw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpshufhw<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF3>>::value, byte_seq<0x70>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vpshufhw ANY [RMI] r  [F3] 70 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpshufhw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpshufhw<zip<reg256>::with<T...>, ptr<reg256, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF3>>::value, byte_seq<0x70>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vpshuflw ANY [RMI] r  [F2] 70 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpshuflw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','h','u','f','l','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpshuflw<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpshuflw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpshuflw<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0xF2>>::value, byte_seq<0x70>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vpshuflw ANY [RMI] r  [F2] 70 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpshuflw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0x70>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpshuflw<zip<reg256>::with<T...>, ptr<reg256, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0xF2>>::value, byte_seq<0x70>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vpsignb ANY [RVM] r  [66] 08 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsignb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','i','g','n','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsignb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsignb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x08>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsignb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x08>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsignb ANY [RVM] r  [66] 08 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsignb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x08>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsignb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x08>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsignd ANY [RVM] r  [66] 0A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsignd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','i','g','n','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsignd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsignd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0A>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsignd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0A>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsignd ANY [RVM] r  [66] 0A 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsignd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0A>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsignd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0A>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsignw ANY [RVM] r  [66] 09 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsignw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','i','g','n','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsignw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsignw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x09>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsignw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x09>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsignw ANY [RVM] r  [66] 09 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsignw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x09>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsignw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x09>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpslld ANY [VMI] 6  [66] 72 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpslld = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','l','l','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpslld<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpslld<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<6>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x72>, typename modrm<hold<Y...>, hold<reg<6>>>::value, typename disp8<Z>::value>>::value;

//  vpslld ANY [RVM] r  [66] F2 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpslld<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF2>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpslld<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF2>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpslld ANY [VMI] 6  [66] 72 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpslld<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<6>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x72>, typename modrm<hold<Y...>, hold<reg<6>>>::value, typename disp8<Z>::value>>::value;

//  vpslld ANY [RVM] r  [66] F2 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpslld<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF2>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpslld<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF2>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpslldq ANY [VMI] 7  [66] 73 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpslldq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','l','l','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpslldq<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpslldq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<7>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x73>, typename modrm<hold<Y...>, hold<reg<7>>>::value, typename disp8<Z>::value>>::value;

//  vpslldq ANY [VMI] 7  [66] 73 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpslldq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<7>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x73>, typename modrm<hold<Y...>, hold<reg<7>>>::value, typename disp8<Z>::value>>::value;

//  vpsllq ANY [VMI] 6  [66] 73 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsllq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','l','l','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsllq<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpsllq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<6>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x73>, typename modrm<hold<Y...>, hold<reg<6>>>::value, typename disp8<Z>::value>>::value;

//  vpsllq ANY [RVM] r  [66] F3 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsllq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF3>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsllq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF3>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsllq ANY [VMI] 6  [66] 73 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpsllq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<6>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x73>, typename modrm<hold<Y...>, hold<reg<6>>>::value, typename disp8<Z>::value>>::value;

//  vpsllq ANY [RVM] r  [66] F3 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsllq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF3>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsllq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF3>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsllvd ANY [RVM] r  [66] 47 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsllvd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','l','l','v','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsllvd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsllvd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x47>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsllvd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x47>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsllvd ANY [RVM] r  [66] 47 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsllvd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x47>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsllvd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x47>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsllvq ANY [RVM] r  [66] 47 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsllvq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','l','l','v','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsllvq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsllvq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x47>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsllvq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x47>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsllvq ANY [RVM] r  [66] 47 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsllvq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x47>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsllvq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x47>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsllw ANY [VMI] 6  [66] 71 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsllw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','l','l','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsllw<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpsllw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<6>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x71>, typename modrm<hold<Y...>, hold<reg<6>>>::value, typename disp8<Z>::value>>::value;

//  vpsllw ANY [RVM] r  [66] F1 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsllw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF1>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsllw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF1>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsllw ANY [VMI] 6  [66] 71 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpsllw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<6>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x71>, typename modrm<hold<Y...>, hold<reg<6>>>::value, typename disp8<Z>::value>>::value;

//  vpsllw ANY [RVM] r  [66] F1 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsllw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF1>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsllw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF1>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsrad ANY [VMI] 4  [66] 72 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsrad = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','r','a','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsrad<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpsrad<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<4>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x72>, typename modrm<hold<Y...>, hold<reg<4>>>::value, typename disp8<Z>::value>>::value;

//  vpsrad ANY [RVM] r  [66] E2 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrad<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE2>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrad<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE2>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsrad ANY [VMI] 4  [66] 72 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpsrad<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<4>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x72>, typename modrm<hold<Y...>, hold<reg<4>>>::value, typename disp8<Z>::value>>::value;

//  vpsrad ANY [RVM] r  [66] E2 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrad<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE2>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrad<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE2>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsravd ANY [RVM] r  [66] 46 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsravd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','r','a','v','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsravd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsravd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x46>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsravd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x46>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsravd ANY [RVM] r  [66] 46 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsravd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x46>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsravd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x46>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsraw ANY [VMI] 4  [66] 71 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsraw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','r','a','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsraw<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpsraw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<4>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x71>, typename modrm<hold<Y...>, hold<reg<4>>>::value, typename disp8<Z>::value>>::value;

//  vpsraw ANY [RVM] r  [66] E1 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsraw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE1>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsraw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE1>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsraw ANY [VMI] 4  [66] 71 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpsraw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<4>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x71>, typename modrm<hold<Y...>, hold<reg<4>>>::value, typename disp8<Z>::value>>::value;

//  vpsraw ANY [RVM] r  [66] E1 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsraw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE1>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsraw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE1>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsrld ANY [VMI] 2  [66] 72 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsrld = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','r','l','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsrld<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpsrld<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<2>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x72>, typename modrm<hold<Y...>, hold<reg<2>>>::value, typename disp8<Z>::value>>::value;

//  vpsrld ANY [RVM] r  [66] D2 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrld<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD2>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrld<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD2>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsrld ANY [VMI] 2  [66] 72 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpsrld<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<2>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x72>, typename modrm<hold<Y...>, hold<reg<2>>>::value, typename disp8<Z>::value>>::value;

//  vpsrld ANY [RVM] r  [66] D2 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrld<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD2>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrld<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD2>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsrldq ANY [VMI] 3  [66] 73 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsrldq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','r','l','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsrldq<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpsrldq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<3>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x73>, typename modrm<hold<Y...>, hold<reg<3>>>::value, typename disp8<Z>::value>>::value;

//  vpsrldq ANY [VMI] 3  [66] 73 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpsrldq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<3>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x73>, typename modrm<hold<Y...>, hold<reg<3>>>::value, typename disp8<Z>::value>>::value;

//  vpsrlq ANY [VMI] 2  [66] 73 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsrlq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','r','l','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsrlq<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpsrlq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<2>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x73>, typename modrm<hold<Y...>, hold<reg<2>>>::value, typename disp8<Z>::value>>::value;

//  vpsrlq ANY [RVM] r  [66] D3 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrlq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD3>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrlq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD3>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsrlq ANY [VMI] 2  [66] 73 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpsrlq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<2>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x73>, typename modrm<hold<Y...>, hold<reg<2>>>::value, typename disp8<Z>::value>>::value;

//  vpsrlq ANY [RVM] r  [66] D3 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrlq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD3>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrlq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD3>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsrlvd ANY [RVM] r  [66] 45 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsrlvd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','r','l','v','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsrlvd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrlvd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x45>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrlvd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x45>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsrlvd ANY [RVM] r  [66] 45 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrlvd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x45>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrlvd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<0>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x45>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsrlvq ANY [RVM] r  [66] 45 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsrlvq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','r','l','v','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsrlvq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrlvq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x45>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrlvq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x45>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsrlvq ANY [RVM] r  [66] 45 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrlvq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x45>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrlvq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<2>, disp8<1>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x45>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsrlw ANY [VMI] 2  [66] 71 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsrlw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','r','l','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsrlw<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpsrlw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<2>>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x71>, typename modrm<hold<Y...>, hold<reg<2>>>::value, typename disp8<Z>::value>>::value;

//  vpsrlw ANY [RVM] r  [66] D1 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrlw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD1>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrlw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD1>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsrlw ANY [VMI] 2  [66] 71 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vpsrlw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<2>>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x71>, typename modrm<hold<Y...>, hold<reg<2>>>::value, typename disp8<Z>::value>>::value;

//  vpsrlw ANY [RVM] r  [66] D1 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrlw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD1>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsrlw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD1>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsubb ANY [RVM] r  [66] F8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsubb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','u','b','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsubb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF8>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF8>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsubb ANY [RVM] r  [66] F8 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF8>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF8>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsubd ANY [RVM] r  [66] FA 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsubd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','u','b','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsubd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFA>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFA>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsubd ANY [RVM] r  [66] FA 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFA>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFA>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsubq ANY [RVM] r  [66] FB 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsubq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','u','b','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsubq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFB>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xFB>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsubq ANY [RVM] r  [66] FB 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFB>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xFB>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsubsb ANY [RVM] r  [66] E8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsubsb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','u','b','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsubsb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubsb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE8>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubsb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE8>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsubsb ANY [RVM] r  [66] E8 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubsb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE8>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubsb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE8>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsubsw ANY [RVM] r  [66] E9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsubsw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','u','b','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsubsw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE9>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubsw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xE9>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsubsw ANY [RVM] r  [66] E9 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubsw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE9>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubsw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xE9>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsubusb ANY [RVM] r  [66] D8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsubusb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','u','b','u','s','b', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsubusb<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubusb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD8>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubusb<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD8>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsubusb ANY [RVM] r  [66] D8 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubusb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD8>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubusb<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD8>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsubusw ANY [RVM] r  [66] D9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsubusw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','u','b','u','s','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsubusw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubusw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD9>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubusw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xD9>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsubusw ANY [RVM] r  [66] D9 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubusw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD9>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubusw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xD9>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsubw ANY [RVM] r  [66] F9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpsubw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','s','u','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpsubw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF9>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xF9>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpsubw ANY [RVM] r  [66] F9 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF9>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpsubw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xF9>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vptest ANY [RM] r  [66] 17 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vptest = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','t','e','s','t', str...>, hold<T...>> {
    static constexpr auto value = asm_vptest<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vptest<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x17>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vptest<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x17>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vptest ANY [RM] r  [66] 17 

template<typename ...T, typename ...Y>
constexpr auto asm_vptest<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x17>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vptest<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x17>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vpunpckhbw ANY [RVM] r  [66] 68 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpunpckhbw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','u','n','p','c','k','h','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpunpckhbw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckhbw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x68>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckhbw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x68>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpunpckhbw ANY [RVM] r  [66] 68 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckhbw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x68>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckhbw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x68>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpunpckhdq ANY [RVM] r  [66] 6A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpunpckhdq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','u','n','p','c','k','h','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpunpckhdq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckhdq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6A>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckhdq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6A>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpunpckhdq ANY [RVM] r  [66] 6A 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckhdq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6A>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckhdq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6A>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpunpckhqdq ANY [RVM] r  [66] 6D 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpunpckhqdq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','u','n','p','c','k','h','q','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpunpckhqdq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckhqdq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckhqdq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpunpckhqdq ANY [RVM] r  [66] 6D 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckhqdq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6D>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckhqdq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6D>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpunpckhwd ANY [RVM] r  [66] 69 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpunpckhwd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','u','n','p','c','k','h','w','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpunpckhwd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckhwd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x69>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckhwd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x69>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpunpckhwd ANY [RVM] r  [66] 69 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckhwd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x69>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckhwd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x69>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpunpcklbw ANY [RVM] r  [66] 60 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpunpcklbw = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','u','n','p','c','k','l','b','w', str...>, hold<T...>> {
    static constexpr auto value = asm_vpunpcklbw<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpcklbw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x60>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpcklbw<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x60>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpunpcklbw ANY [RVM] r  [66] 60 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpcklbw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x60>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpcklbw<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x60>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpunpckldq ANY [RVM] r  [66] 62 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpunpckldq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','u','n','p','c','k','l','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpunpckldq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckldq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x62>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckldq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x62>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpunpckldq ANY [RVM] r  [66] 62 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckldq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x62>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpckldq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x62>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpunpcklqdq ANY [RVM] r  [66] 6C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpunpcklqdq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','u','n','p','c','k','l','q','d','q', str...>, hold<T...>> {
    static constexpr auto value = asm_vpunpcklqdq<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpcklqdq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpcklqdq<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x6C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpunpcklqdq ANY [RVM] r  [66] 6C 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpcklqdq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpcklqdq<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x6C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpunpcklwd ANY [RVM] r  [66] 61 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpunpcklwd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','u','n','p','c','k','l','w','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vpunpcklwd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpcklwd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x61>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpcklwd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x61>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpunpcklwd ANY [RVM] r  [66] 61 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpcklwd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x61>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpunpcklwd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x61>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpxor ANY [RVM] r  [66] EF 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vpxor = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','p','x','o','r', str...>, hold<T...>> {
    static constexpr auto value = asm_vpxor<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpxor<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEF>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpxor<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xEF>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vpxor ANY [RVM] r  [66] EF 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpxor<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEF>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vpxor<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xEF>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vrcpps ANY [RM] r  [] 53 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vrcpps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','r','c','p','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vrcpps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vrcpps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x53>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vrcpps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x53>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vrcpps ANY [RM] r  [] 53 

template<typename ...T, typename ...Y>
constexpr auto asm_vrcpps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x53>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vrcpps<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x53>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vrcpss ANY [RVM] r  [F3] 53 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vrcpss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','r','c','p','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vrcpss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vrcpss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x53>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vrcpss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x53>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vroundpd ANY [RMI] r  [66] 09 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vroundpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','r','o','u','n','d','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vroundpd<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vroundpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x09>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vroundpd<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x09>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vroundpd ANY [RMI] r  [66] 09 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vroundpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x09>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vroundpd<zip<reg256>::with<T...>, ptr<reg256, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x09>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vroundps ANY [RMI] r  [66] 08 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vroundps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','r','o','u','n','d','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vroundps<T...>;
};
template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vroundps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x08>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vroundps<zip<reg128>::with<T...>, ptr<reg128, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x08>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vroundps ANY [RMI] r  [66] 08 

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vroundps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, disp8<Z>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x08>, typename modrm<hold<Y...>, hold<T...>>::value, typename disp8<Z>::value>>::value;

template<typename ...T, typename ...Y, uint8_t Z>
constexpr auto asm_vroundps<zip<reg256>::with<T...>, ptr<reg256, Y...>, disp8<Z>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<3>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x08>, typename mrm<Y...>::template value<hold<T...>>, typename disp8<Z>::value>>::value;

//  vroundsd ANY [RVMI] r  [66] 0B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vroundsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','r','o','u','n','d','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vroundsd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vroundsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x0B>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vroundsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x0B>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vroundss ANY [RVMI] r  [66] 0A 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vroundss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','r','o','u','n','d','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vroundss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vroundss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Z...>>>, disp8<0>, disp8<3>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x0A>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vroundss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Z...>::X>, disp8<mrm<Z...>::B>, disp8<3>, disp8<0>, hold<Y...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x0A>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vrsqrtps ANY [RM] r  [] 52 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vrsqrtps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','r','s','q','r','t','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vrsqrtps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vrsqrtps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x52>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vrsqrtps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x52>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vrsqrtps ANY [RM] r  [] 52 

template<typename ...T, typename ...Y>
constexpr auto asm_vrsqrtps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x52>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vrsqrtps<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x52>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vrsqrtss ANY [RVM] r  [F3] 52 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vrsqrtss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','r','s','q','r','t','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vrsqrtss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vrsqrtss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x52>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vrsqrtss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x52>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vshufpd ANY [RVMI] r  [66] C6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vshufpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','h','u','f','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vshufpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vshufpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xC6>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vshufpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0xC6>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vshufpd ANY [RVMI] r  [66] C6 

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vshufpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xC6>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vshufpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0xC6>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vshufps ANY [RVMI] r  [] C6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vshufps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','h','u','f','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vshufps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vshufps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xC6>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vshufps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0xC6>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vshufps ANY [RVMI] r  [] C6 

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vshufps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>, disp8<O>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0xC6>, typename modrm<hold<Z...>, hold<T...>>::value, typename disp8<O>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z, uint8_t O>
constexpr auto asm_vshufps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>, disp8<O>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0xC6>, typename mrm<Z...>::template value<hold<T...>>, typename disp8<O>::value>>::value;

//  vsqrtpd ANY [RM] r  [66] 51 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vsqrtpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','q','r','t','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vsqrtpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vsqrtpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x51>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vsqrtpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x51>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vsqrtpd ANY [RM] r  [66] 51 

template<typename ...T, typename ...Y>
constexpr auto asm_vsqrtpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x51>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vsqrtpd<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x51>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vsqrtps ANY [RM] r  [] 51 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vsqrtps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','q','r','t','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vsqrtps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vsqrtps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x51>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vsqrtps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0x51>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vsqrtps ANY [RM] r  [] 51 

template<typename ...T, typename ...Y>
constexpr auto asm_vsqrtps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x51>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vsqrtps<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<256>, disp8<0>>::value, byte_seq<0x51>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vsqrtsd ANY [RVM] r  [F2] 51 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vsqrtsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','q','r','t','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vsqrtsd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vsqrtsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x51>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vsqrtsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x51>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vsqrtss ANY [RVM] r  [F3] 51 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vsqrtss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','q','r','t','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vsqrtss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vsqrtss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x51>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vsqrtss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x51>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vstmxcsr ANY [M] 3  [] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vstmxcsr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','t','m','x','c','s','r', str...>, hold<T...>> {
    static constexpr auto value = asm_vstmxcsr<T...>;
};
template<typename ...T>
constexpr auto asm_vstmxcsr<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<reg<3>>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

template<typename ...T>
constexpr auto asm_vstmxcsr<ptr<reg32, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<reg<3>>>>, hold<T...>, disp16<128>, disp8<0>>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  vsubpd ANY [RVM] r  [66] 5C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vsubpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','u','b','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vsubpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vsubpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vsubpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x5C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vsubpd ANY [RVM] r  [66] 5C 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vsubpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vsubpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x5C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vsubps ANY [RVM] r  [] 5C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vsubps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','u','b','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vsubps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vsubps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x5C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vsubps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x5C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vsubps ANY [RVM] r  [] 5C 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vsubps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x5C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vsubps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x5C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vsubsd ANY [RVM] r  [F2] 5C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vsubsd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','u','b','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vsubsd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vsubsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg64>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vsubsd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg64, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF2>>::value, byte_seq<0x5C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vsubss ANY [RVM] r  [F3] 5C 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vsubss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','s','u','b','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vsubss<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vsubss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg32>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5C>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vsubss<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg32, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<0>, disp8<0xF3>>::value, byte_seq<0x5C>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vtestpd ANY [RM] r  [66] 0F 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vtestpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','t','e','s','t','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vtestpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vtestpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vtestpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vtestpd ANY [RM] r  [66] 0F 

template<typename ...T, typename ...Y>
constexpr auto asm_vtestpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0F>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vtestpd<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0F>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vtestps ANY [RM] r  [66] 0E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vtestps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','t','e','s','t','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vtestps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vtestps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vtestps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x0E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vtestps ANY [RM] r  [66] 0E 

template<typename ...T, typename ...Y>
constexpr auto asm_vtestps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<is_ext_v<hold<Y...>>>, disp8<0>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vtestps<zip<reg256>::with<T...>, ptr<reg256, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, disp8<mrm<Y...>::X>, disp8<mrm<Y...>::B>, disp8<2>, disp8<0>, hold<T...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x0E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vucomisd ANY [RM] r  [66] 2E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vucomisd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','u','c','o','m','i','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vucomisd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vucomisd<zip<reg128>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x2E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vucomisd<zip<reg128>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0x66>>::value, byte_seq<0x2E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vucomiss ANY [RM] r  [] 2E 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vucomiss = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','u','c','o','m','i','s','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vucomiss<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_vucomiss<zip<reg128>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0>>::value, byte_seq<0x2E>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_vucomiss<zip<reg128>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<T...>, disp16<0>, disp8<0>>::value, byte_seq<0x2E>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  vunpckhpd ANY [RVM] r  [66] 15 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vunpckhpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','u','n','p','c','k','h','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vunpckhpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vunpckhpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x15>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vunpckhpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x15>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vunpckhpd ANY [RVM] r  [66] 15 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vunpckhpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x15>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vunpckhpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x15>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vunpckhps ANY [RVM] r  [] 15 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vunpckhps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','u','n','p','c','k','h','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vunpckhps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vunpckhps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x15>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vunpckhps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x15>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vunpckhps ANY [RVM] r  [] 15 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vunpckhps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x15>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vunpckhps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x15>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vunpcklpd ANY [RVM] r  [66] 14 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vunpcklpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','u','n','p','c','k','l','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vunpcklpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vunpcklpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x14>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vunpcklpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x14>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vunpcklpd ANY [RVM] r  [66] 14 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vunpcklpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x14>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vunpcklpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x14>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vunpcklps ANY [RVM] r  [] 14 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vunpcklps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','u','n','p','c','k','l','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vunpcklps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vunpcklps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x14>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vunpcklps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x14>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vunpcklps ANY [RVM] r  [] 14 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vunpcklps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x14>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vunpcklps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x14>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vxorpd ANY [RVM] r  [66] 57 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vxorpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','x','o','r','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_vxorpd<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vxorpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x57>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vxorpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0x66>>::value, byte_seq<0x57>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vxorpd ANY [RVM] r  [66] 57 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vxorpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x57>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vxorpd<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0x66>>::value, byte_seq<0x57>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vxorps ANY [RVM] r  [] 57 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vxorps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','x','o','r','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_vxorps<T...>;
};
template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vxorps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, zip<reg128>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x57>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vxorps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>, ptr<reg128, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<128>, disp8<0>>::value, byte_seq<0x57>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vxorps ANY [RVM] r  [] 57 

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vxorps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, zip<reg256>::with<Z...>> = 
  seq_to_arr<expand_byte_seq_v<typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x57>, typename modrm<hold<Z...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y, typename ...Z>
constexpr auto asm_vxorps<zip<reg256>::with<T...>, zip<reg256>::with<Y...>, ptr<reg256, Z...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Z...>::_67h>::value, typename VEX<disp8<is_ext_v<hold<T...>>>, hold<Y...>, disp16<256>, disp8<0>>::value, byte_seq<0x57>, typename mrm<Z...>::template value<hold<T...>>>>::value;

//  vzeroall ANY [NONE]   [] 77 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vzeroall = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','z','e','r','o','a','l','l', str...>, hold<T...>> {
    static constexpr auto value = asm_vzeroall<T...>;
};
template <>
constexpr auto asm_vzeroall<> = seq_to_arr<expand_byte_seq_v<typename VEX<disp8<0>, hold<reg<0>>, disp16<256>, disp8<0>>::value, byte_seq<0x77>>>::value;
//  vzeroupper ANY [NONE]   [] 77 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_vzeroupper = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'v','z','e','r','o','u','p','p','e','r', str...>, hold<T...>> {
    static constexpr auto value = asm_vzeroupper<T...>;
};
template <>
constexpr auto asm_vzeroupper<> = seq_to_arr<expand_byte_seq_v<typename VEX<disp8<0>, hold<reg<0>>, disp16<128>, disp8<0>>::value, byte_seq<0x77>>>::value;
//  wait ANY [NONE]   [] 9B 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_wait = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','a','i','t', str...>, hold<T...>> {
    static constexpr auto value = asm_wait<T...>;
};
template <>
constexpr auto asm_wait<> = seq_to_arr<expand_byte_seq_v< byte_seq<0x9B>>>::value;
//  wbinvd ANY [NONE]   [] 09 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_wbinvd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','b','i','n','v','d', str...>, hold<T...>> {
    static constexpr auto value = asm_wbinvd<T...>;
};
template <>
constexpr auto asm_wbinvd<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x09>>>::value;
//  wbnoinvd ANY [NONE]   [F3] 09 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_wbnoinvd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','b','n','o','i','n','v','d', str...>, hold<T...>> {
    static constexpr auto value = asm_wbnoinvd<T...>;
};
template <>
constexpr auto asm_wbnoinvd<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>,  byte_seq<0x09>>>::value;
//  wrfsbase X64 [M] 2  [F3] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_wrfsbase = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','r','f','s','b','a','s','e', str...>, hold<T...>> {
    static constexpr auto value = asm_wrfsbase<T...>;
};
template<typename ...T>
constexpr auto asm_wrfsbase<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

//  wrfsbase X64 [M] 2  [F3] AE 

template<typename ...T>
constexpr auto asm_wrfsbase<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<2>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<2>>>::value>>::value;

//  wrgsbase X64 [M] 3  [F3] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_wrgsbase = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','r','g','s','b','a','s','e', str...>, hold<T...>> {
    static constexpr auto value = asm_wrgsbase<T...>;
};
template<typename ...T>
constexpr auto asm_wrgsbase<zip<reg32>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

//  wrgsbase X64 [M] 3  [F3] AE 

template<typename ...T>
constexpr auto asm_wrgsbase<zip<reg64>::with<T...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0xF3>, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<3>>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xAE>, typename modrm<hold<T...>, hold<reg<3>>>::value>>::value;

//  wrmsr ANY [NONE]   [] 30 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_wrmsr = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','r','m','s','r', str...>, hold<T...>> {
    static constexpr auto value = asm_wrmsr<T...>;
};
template <>
constexpr auto asm_wrmsr<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>,  byte_seq<0x30>>>::value;
//  wrssd ANY [MR] r  [] F6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_wrssd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','r','s','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_wrssd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_wrssd<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_wrssd<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF6>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  wrssq X64 [MR] r  [] F6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_wrssq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','r','s','s','q', str...>, hold<T...>> {
    static constexpr auto value = asm_wrssq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_wrssq<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF6>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_wrssq<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF6>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  wrussd ANY [MR] r  [66] F5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_wrussd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','r','u','s','s','d', str...>, hold<T...>> {
    static constexpr auto value = asm_wrussd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_wrussd<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF5>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_wrussd<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF5>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  wrussq X64 [MR] r  [66] F5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_wrussq = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'w','r','u','s','s','q', str...>, hold<T...>> {
    static constexpr auto value = asm_wrussq<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_wrussq<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xF5>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_wrussq<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F, 0x38>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xF5>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  xabort ANY [I] 7  [] C6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xabort = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','a','b','o','r','t', str...>, hold<T...>> {
    static constexpr auto value = asm_xabort<T...>;
};
template <uint8_t T> 
constexpr auto asm_xabort<disp8<T>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0xC6>, typename disp8<T>::value>>::value;
//  xadd ANY [MR] r  [] C0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xadd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','a','d','d', str...>, hold<T...>> {
    static constexpr auto value = asm_xadd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_xadd<zip<reg8>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC0>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_xadd<ptr<reg8, T...>, zip<reg8>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC0>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  xadd ANY [MR] r  [66] C1 

template<typename ...T, typename ...Y>
constexpr auto asm_xadd<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC1>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_xadd<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  xadd ANY [MR] r  [] C1 

template<typename ...T, typename ...Y>
constexpr auto asm_xadd<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC1>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_xadd<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  xadd X64 [MR] r  [] C1 

template<typename ...T, typename ...Y>
constexpr auto asm_xadd<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, is_ext_v<hold<T...>>, 0>::value, byte_seq<0xC1>, typename modrm<hold<T...>, hold<Y...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_xadd<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC1>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  xbegin ANY [NONE] 7  [66] C7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xbegin = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','b','e','g','i','n', str...>, hold<T...>> {
    static constexpr auto value = asm_xbegin<T...>;
};
template <uint16_t T>
constexpr auto asm_xbegin<disp16<T>> = seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0xC7>, typename disp16<T>::value>>::value;
//  xchg ANY [O]   [66] 90 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xchg = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','c','h','g', str...>, hold<T...>> {
    static constexpr auto value = asm_xchg<T...>;
};
//  xchg ANY [O]   [] 90 

//  xchg X64 [O]   [] 90 

//  xchg ANY [O]   [66] 90 

//  xchg ANY [O]   [] 90 

//  xchg X64 [O]   [] 90 

//  xchg ANY [MR] r  [] 86 

template<typename ...T, typename ...Y>
constexpr auto asm_xchg<ptr<reg8, T...>, zip<reg8>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x86>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  xchg ANY [MR] r  [66] 87 

template<typename ...T, typename ...Y>
constexpr auto asm_xchg<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x87>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  xchg ANY [MR] r  [] 87 

template<typename ...T, typename ...Y>
constexpr auto asm_xchg<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x87>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  xchg X64 [MR] r  [] 87 

template<typename ...T, typename ...Y>
constexpr auto asm_xchg<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x87>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  xchg ANY [RM] r  [] 86 

template<typename ...T, typename ...Y>
constexpr auto asm_xchg<zip<reg8>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x86>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_xchg<zip<reg8>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x86>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  xchg ANY [RM] r  [66] 87 

template<typename ...T, typename ...Y>
constexpr auto asm_xchg<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x87>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_xchg<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x87>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  xchg ANY [RM] r  [] 87 

template<typename ...T, typename ...Y>
constexpr auto asm_xchg<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x87>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_xchg<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x87>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  xchg X64 [RM] r  [] 87 

template<typename ...T, typename ...Y>
constexpr auto asm_xchg<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x87>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_xchg<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x87>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  xend ANY [NONE]   [] D5 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xend = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','e','n','d', str...>, hold<T...>> {
    static constexpr auto value = asm_xend<T...>;
};
template <>
constexpr auto asm_xend<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xD5>>>::value;
//  xgetbv ANY [NONE]   [] D0 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xgetbv = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','g','e','t','b','v', str...>, hold<T...>> {
    static constexpr auto value = asm_xgetbv<T...>;
};
template <>
constexpr auto asm_xgetbv<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xD0>>>::value;
//  xlatb ANY [NONE]   [] D7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xlatb = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','l','a','t','b', str...>, hold<T...>> {
    static constexpr auto value = asm_xlatb<T...>;
};
template <>
constexpr auto asm_xlatb<> = seq_to_arr<expand_byte_seq_v< byte_seq<0xD7>>>::value;
//  xor ANY [I]   [] 34 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xor = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','o','r', str...>, hold<T...>> {
    static constexpr auto value = asm_xor<T...>;
};
template <uint8_t Y> 
constexpr auto asm_xor<al, disp8<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x34>, typename disp8<Y>::value>>::value;
//  xor ANY [I]   [66] 35 

template <uint16_t Y> 
constexpr auto asm_xor<ax, disp16<Y>> =
    seq_to_arr<expand_byte_seq_v<byte_seq<0x66>,  byte_seq<0x35>, typename disp16<Y>::value>>::value;
//  xor ANY [I]   [] 35 

template <uint32_t Y> 
constexpr auto asm_xor<eax, disp32<Y>> =
    seq_to_arr<expand_byte_seq_v< byte_seq<0x35>, typename disp32<Y>::value>>::value;
//  xor X64 [I]   [] 35 

template <uint32_t Y> 
constexpr auto asm_xor<rax, id<Y>> =
    seq_to_arr<expand_byte_seq_v<typename REX<1, 0, 0, 0>::value, byte_seq<0x35>, typename id<Y>::value>>::value;
//  xor ANY [MI] 6  [] 80 

template<typename ...T, uint8_t Y>
constexpr auto asm_xor<ptr<reg8, T...>, disp8<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x80>, typename mrm<T...>::template value<hold<reg<6>>>, typename disp8<Y>::value>>::value;

//  xor ANY [MI] 6  [66] 81 

template<typename ...T, uint16_t Y>
constexpr auto asm_xor<ptr<reg16, T...>, disp16<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<6>>>, typename disp16<Y>::value>>::value;

//  xor ANY [MI] 6  [] 81 

template<typename ...T, uint32_t Y>
constexpr auto asm_xor<ptr<reg32, T...>, disp32<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<6>>>, typename disp32<Y>::value>>::value;

//  xor X64 [MI] 6  [] 81 

template<typename ...T, uint32_t Y>
constexpr auto asm_xor<ptr<reg64, T...>, id<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x81>, typename mrm<T...>::template value<hold<reg<6>>>, typename id<Y>::value>>::value;

//  xor ANY [MI] 6  [66] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_xor<ptr<reg16, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<6>>>, typename ib<Y>::value>>::value;

//  xor ANY [MI] 6  [] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_xor<ptr<reg32, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<6>>>, typename ib<Y>::value>>::value;

//  xor X64 [MI] 6  [] 83 

template<typename ...T, uint8_t Y>
constexpr auto asm_xor<ptr<reg64, T...>, ib<Y>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x83>, typename mrm<T...>::template value<hold<reg<6>>>, typename ib<Y>::value>>::value;

//  xor ANY [MR] r  [] 30 

template<typename ...T, typename ...Y>
constexpr auto asm_xor<ptr<reg8, T...>, zip<reg8>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x30>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  xor ANY [MR] r  [66] 31 

template<typename ...T, typename ...Y>
constexpr auto asm_xor<ptr<reg16, T...>, zip<reg16>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x31>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  xor ANY [MR] r  [] 31 

template<typename ...T, typename ...Y>
constexpr auto asm_xor<ptr<reg32, T...>, zip<reg32>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<0, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x31>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  xor X64 [MR] r  [] 31 

template<typename ...T, typename ...Y>
constexpr auto asm_xor<ptr<reg64, T...>, zip<reg64>::with<Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, typename REX<1, is_ext_v<hold<Y...>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0x31>, typename mrm<T...>::template value<hold<Y...>>>>::value;

//  xor ANY [RM] r  [] 32 

template<typename ...T, typename ...Y>
constexpr auto asm_xor<zip<reg8>::with<T...>, zip<reg8>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x32>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_xor<zip<reg8>::with<T...>, ptr<reg8, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x32>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  xor ANY [RM] r  [66] 33 

template<typename ...T, typename ...Y>
constexpr auto asm_xor<zip<reg16>::with<T...>, zip<reg16>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x33>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_xor<zip<reg16>::with<T...>, ptr<reg16, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x33>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  xor ANY [RM] r  [] 33 

template<typename ...T, typename ...Y>
constexpr auto asm_xor<zip<reg32>::with<T...>, zip<reg32>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x33>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_xor<zip<reg32>::with<T...>, ptr<reg32, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x33>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  xor X64 [RM] r  [] 33 

template<typename ...T, typename ...Y>
constexpr auto asm_xor<zip<reg64>::with<T...>, zip<reg64>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<typename REX<1, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x33>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_xor<zip<reg64>::with<T...>, ptr<reg64, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, typename REX<1, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x33>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  xorpd ANY [RM] r  [66] 57 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xorpd = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','o','r','p','d', str...>, hold<T...>> {
    static constexpr auto value = asm_xorpd<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_xorpd<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x57>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_xorpd<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x66>, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x57>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  xorps ANY [RM] r  [] 57 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xorps = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','o','r','p','s', str...>, hold<T...>> {
    static constexpr auto value = asm_xorps<T...>;
};
template<typename ...T, typename ...Y>
constexpr auto asm_xorps<zip<reg128>::with<T...>, zip<reg128>::with<Y...>> = 
  seq_to_arr<expand_byte_seq_v<byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, is_ext_v<hold<Y...>>, 0>::value, byte_seq<0x57>, typename modrm<hold<Y...>, hold<T...>>::value>>::value;

template<typename ...T, typename ...Y>
constexpr auto asm_xorps<zip<reg128>::with<T...>, ptr<reg128, Y...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<Y...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<T...>>, mrm<Y...>::X, mrm<Y...>::B>::value, byte_seq<0x57>, typename mrm<Y...>::template value<hold<T...>>>>::value;

//  xresldtrk ANY [NONE]   [F2] E9 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xresldtrk = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','r','e','s','l','d','t','r','k', str...>, hold<T...>> {
    static constexpr auto value = asm_xresldtrk<T...>;
};
template <>
constexpr auto asm_xresldtrk<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x01>,  byte_seq<0xE9>>>::value;
//  xrstor ANY [M] 5  [] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xrstor = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','r','s','t','o','r', str...>, hold<T...>> {
    static constexpr auto value = asm_xrstor<T...>;
};
template<typename ...T>
constexpr auto asm_xrstor<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  xrstor64 X64 [M] 5  [] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xrstor64 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','r','s','t','o','r','6','4', str...>, hold<T...>> {
    static constexpr auto value = asm_xrstor64<T...>;
};
template<typename ...T>
constexpr auto asm_xrstor64<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  xrstors ANY [M] 3  [] C7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xrstors = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','r','s','t','o','r','s', str...>, hold<T...>> {
    static constexpr auto value = asm_xrstors<T...>;
};
template<typename ...T>
constexpr auto asm_xrstors<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  xrstors64 X64 [M] 3  [] C7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xrstors64 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','r','s','t','o','r','s','6','4', str...>, hold<T...>> {
    static constexpr auto value = asm_xrstors64<T...>;
};
template<typename ...T>
constexpr auto asm_xrstors64<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<3>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, typename mrm<T...>::template value<hold<reg<3>>>>>::value;

//  xsave ANY [M] 4  [] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xsave = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','a','v','e', str...>, hold<T...>> {
    static constexpr auto value = asm_xsave<T...>;
};
template<typename ...T>
constexpr auto asm_xsave<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  xsave64 X64 [M] 4  [] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xsave64 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','a','v','e','6','4', str...>, hold<T...>> {
    static constexpr auto value = asm_xsave64<T...>;
};
template<typename ...T>
constexpr auto asm_xsave64<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  xsavec ANY [M] 4  [] C7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xsavec = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','a','v','e','c', str...>, hold<T...>> {
    static constexpr auto value = asm_xsavec<T...>;
};
template<typename ...T>
constexpr auto asm_xsavec<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  xsavec64 X64 [M] 4  [] C7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xsavec64 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','a','v','e','c','6','4', str...>, hold<T...>> {
    static constexpr auto value = asm_xsavec64<T...>;
};
template<typename ...T>
constexpr auto asm_xsavec64<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<4>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, typename mrm<T...>::template value<hold<reg<4>>>>>::value;

//  xsaveopt ANY [M] 6  [] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xsaveopt = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','a','v','e','o','p','t', str...>, hold<T...>> {
    static constexpr auto value = asm_xsaveopt<T...>;
};
template<typename ...T>
constexpr auto asm_xsaveopt<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  xsaveopt64 X64 [M] 6  [] AE 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xsaveopt64 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','a','v','e','o','p','t','6','4', str...>, hold<T...>> {
    static constexpr auto value = asm_xsaveopt64<T...>;
};
template<typename ...T>
constexpr auto asm_xsaveopt64<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<6>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xAE>, typename mrm<T...>::template value<hold<reg<6>>>>>::value;

//  xsaves ANY [M] 5  [] C7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xsaves = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','a','v','e','s', str...>, hold<T...>> {
    static constexpr auto value = asm_xsaves<T...>;
};
template<typename ...T>
constexpr auto asm_xsaves<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<0, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  xsaves64 X64 [M] 5  [] C7 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xsaves64 = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','a','v','e','s','6','4', str...>, hold<T...>> {
    static constexpr auto value = asm_xsaves64<T...>;
};
template<typename ...T>
constexpr auto asm_xsaves64<ptr<reg64, T...>> = 
seq_to_arr<expand_byte_seq_v<typename byte_67h<mrm<T...>::_67h>::value, byte_seq<0x0F>, typename REX<1, is_ext_v<hold<reg<5>>>, mrm<T...>::X, mrm<T...>::B>::value, byte_seq<0xC7>, typename mrm<T...>::template value<hold<reg<5>>>>>::value;

//  xsetbv ANY [NONE]   [] D1 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xsetbv = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','e','t','b','v', str...>, hold<T...>> {
    static constexpr auto value = asm_xsetbv<T...>;
};
template <>
constexpr auto asm_xsetbv<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xD1>>>::value;
//  xsusldtrk ANY [NONE]   [F2] E8 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xsusldtrk = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','s','u','s','l','d','t','r','k', str...>, hold<T...>> {
    static constexpr auto value = asm_xsusldtrk<T...>;
};
template <>
constexpr auto asm_xsusldtrk<> = seq_to_arr<expand_byte_seq_v<byte_seq<0xF2>, byte_seq<0x0F, 0x01>,  byte_seq<0xE8>>>::value;
//  xtest ANY [NONE]   [] D6 
template<typename... T> static constexpr std::array<uint8_t, 0> asm_xtest = {};
template <char... str, typename... T>
struct parse_instr_name<char_seq<'x','t','e','s','t', str...>, hold<T...>> {
    static constexpr auto value = asm_xtest<T...>;
};
template <>
constexpr auto asm_xtest<> = seq_to_arr<expand_byte_seq_v<byte_seq<0x0F, 0x01>,  byte_seq<0xD6>>>::value;
